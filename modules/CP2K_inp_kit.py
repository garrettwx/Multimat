#!/usr/bin/env python
# coding: utf-8

# In[6]:


# This is the new version for creaking the inp file for CP2K, to be more flexible

############################
'''
Created by: Dr. Xuan Wang
Email:xw97259@gmail.com
'''
############################

from pymatgen.core.structure import Structure
from pymatgen.core.lattice import Lattice
from pymatgen.symmetry.analyzer import SpacegroupAnalyzer
from pymatgen.symmetry.bandstructure import HighSymmKpath
from pymatgen.symmetry.kpath import KPathSeek, KPathSetyawanCurtarolo
from pymatgen.io.cp2k.inputs import Section,Cp2kInput,Keyword

from ase.io import read
from ase import Atoms
from ase.dft.kpoints import bandpath

import numpy as np
import pandas as pd
import os
import yaml
import re
import copy

from collections import Counter

from typing import NewType, List, Dict
cp2k_section = NewType('Section',object)     #for developer to know about the return of functions
structure_information = NewType('Structure information',object)

def create_inp():

    def file_choose(file_type:str) -> Dict[int,str]:
        
        '''
        define the function to read the structure, support POSCAR, CONTCAR, cif
        to avoid the bug in cif by ase, i will use pymatgen to read cif
        
        file_type:
        
        all-for all files
        poscar-vasp structure file
        contcar-vasp structure file
        restart-cp2k file
        cif-crystal structure file
        inp-cp2k file
        '''
        
        files = []
        file_cluster = os.getcwd()

        if file_type == 'all':
            for filename in os.listdir(file_cluster):
                files.append(filename)
                
        else:
            types = file_type.split(',')
            for t_i in types:
                for filename in os.listdir(file_cluster):
                    if filename.endswith(t_i):
                        files.append(filename)
        
        files_dict = {}
        for x_i in range(len(files)):
            files_dict[x_i] = files[x_i]
        files_dict

        return files_dict      #this retuns a dictionary

    
    def write_cp2k_inp(project_name:str, sections_dict:Dict[str,cp2k_section]) -> None:    #input the project name and dictionary of sections
        
        '''
        create the cp2k.inp file by Multimat
        
        project_name: the project name of cp2k inp file
        sections_dict: sections to be added in inp file, must be the python dictionary
        '''
        
        cp2k_inp = Cp2kInput(project_name, sections_dict)
        cp2k_inp.write_file(input_filename = '{}.inp'.format(project_name), output_dir = '.')
    
        with open('{}.inp'.format(project_name), mode = 'r') as f:
            inp_lines = f.readlines()       
            inp_lines.insert(0,'#cp2k.inp file generated by Multimat\n')  #first comment line
        with open('{}.inp'.format(project_name), mode = 'w') as g:
            g.writelines(inp_lines)
            
        print('\nGenerate {}.inp by Multimat successfully!\n'.format(project_name))


    def parse_cp2k_restart(restart_filename:str) -> structure_information:
        with open(restart_filename, mode = 'r') as f:
            lines = f.readlines()
        
        #locate the &CELL and &COORD section 
        for x_i,line_i in enumerate(lines):
            if line_i.strip() == '&CELL': 
                begin_cell_line = x_i
        
            if line_i.strip() == '&END CELL':
                end_cell_line = x_i
        
            if line_i.strip() == '&COORD':
                begin_coord_line = x_i
                
            if line_i.strip() == '&END COORD':
                end_coord_line = x_i
        
        #parse the &CELL
        cell_section_list = []
        for x_i in lines[begin_cell_line:end_cell_line]:
             cell_section_list.append(re.sub('\\s+',' ', x_i).strip().split(' '))
            
        for y_i in cell_section_list:
            if y_i[0] == 'A':    #lattice A
                cell_A_vector = np.array([y_i[1],y_i[2],y_i[3]]).astype(np.float64)
        
            if y_i[0] == 'B':    #lattice B
                cell_B_vector = np.array([y_i[1],y_i[2],y_i[3]]).astype(np.float64) 
        
            if y_i[0] == 'C':    #lattice C
                cell_C_vector = np.array([y_i[1],y_i[2],y_i[3]]).astype(np.float64)  
        
            if y_i[0] == 'ABC':  #this is ABC in a line, must be with angles
                length_ABC = [float(y_i[1]), float(y_i[2]), float(y_i[3])]
        
            if y_i[0] == 'ALPHA_BETA_GAMMA':    #angles part
                angles = [float(y_i[1]), float(y_i[2]), float(y_i[3])]
        
        #add the cell info into structure
        try:
            if len(cell_A_vector) > 0 and len(cell_B_vector) > 0 and len(cell_B_vector) > 0:
                lattice_matrix_arr = np.array([cell_A_vector,cell_B_vector,cell_C_vector])
                
                print('\nFind lattice matrix in restart [Angstrom]:')
                print(lattice_matrix_arr)
        
        except:
            if len(length_ABC) > 0 and len(angles) > 0:
                lattice_info = Lattice.from_parameters(a = length_ABC[0], 
                                                       b = length_ABC[1], 
                                                       c = length_ABC[2], 
                                                       alpha = angles[0], 
                                                       beta = angles[1], 
                                                       gamma = angles[2])
                lattice_matrix_arr = lattice_info.matrix
                
                print('\nFind lattice length in restart, now transform into lattice matrix [Angstrom]:\n')
                print(lattice_matrix_arr)
        
        
        #add the coord info into structure
        coords_section_list = []
        for x_i in lines[begin_coord_line:end_coord_line]:
             coords_section_list.append(re.sub('\\s+',' ', x_i).strip().split(' '))
            
        #if frac_coord or cart_coord
        symbols_list = []
        coords_list = []
        scaled_T = []
        
        for y_i in coords_section_list:
            if len(y_i) == 4:   #this is the right line of coords
                symbols_list.append(y_i[0])
                coords_list.append(y_i[1:4])    #a list of string
        
    
            if y_i[0] == 'SCALED' and y_i[1] == 'T':
                scaled_T.append('scaled T')
                    
        coords_arr = np.array(coords_list).astype(np.float64)   #transform the string into float format
    
        #to change the unknown chemical symbols
        print('\nFind chemical symbols:')
        print(list(set(symbols_list)))

        print('\nIf abnormal chemical symbols in your structure, may crash, so you need to replace the unknown ones!')
        replace_symbol = input('\nIf to replace abnormal chemical symbols? [y/n]\n')
        if replace_symbol.strip() == 'y':
            symbols_before_replace = input('\nPlease type in the symbol(s) to replace, e.g. Co_A,Co_B,Co_C\n')
    
            symbols_ini = symbols_before_replace.strip().split(',')
            
            symbols_after_replace = input('\nPlease type in {} symbol(s) after replace, e.g. Fe,Co,Ni\n'.format(len(symbols_ini)))
    
            symbols_fin = symbols_after_replace.strip().split(',')
    
            for x_i in range(len(symbols_ini)):
                for y_i in range(len(symbols_list)):
                    if symbols_list[y_i] == symbols_ini[x_i]:
                        symbols_list[y_i] = symbols_fin[x_i]
    
        if replace_symbol.strip() == 'n':
            print('\nIf you use unrecognized symbols, may crash!\n')
            
        #create the structure info
        if len(scaled_T) > 0:   #frac_coords
            structure_info =  Structure(lattice = lattice_matrix_arr, 
                                       species = symbols_list,
                                      coords = coords_arr,
                                      coords_are_cartesian = False
                                     )
               
        
        if len(scaled_T) == 0:   #frac_coords
            structure_info =  Structure(lattice = lattice_matrix_arr, 
                                       species = symbols_list,
                                       coords = coords_arr,
                                       coords_are_cartesian = True
                                      )
        
        
        return structure_info




    '''
    Begin the reading of structure information
    '''
    files_dict = file_choose('cif,vasp,poscar,contcar,restart,inp')

    if len(files_dict) == 0:    #avoid the crash of multimat when empty files
        print('\nUnavailable files! Now return to the main plate!\n')
        return 
        
    elif len(files_dict) > 0:
        print('\nCurrently available structure files:\n')
        print(yaml.dump(files_dict, sort_keys = False, default_flow_style = False)) 
        
        structure_index = input('\nPlease choose the structure file for .inp file construction in cp2k, e.g. 2:\n')
        structure_filename = files_dict[int(structure_index.strip())]
    
        if structure_filename.endswith('cif'):
            print('\nYour selected filename:', structure_filename, '\n')
            
            structure = Structure.from_file(structure_filename)
            
            vector_A = structure.lattice.matrix[0]
            A = [f'{x:.8f}' for x in np.around(vector_A,8)]
            vector_B = structure.lattice.matrix[1]
            B = [f'{x:.8f}' for x in np.around(vector_B,8)]
            vector_C = structure.lattice.matrix[2]
            C = [f'{x:.8f}' for x in np.around(vector_C,8)]
            
            angles = structure.lattice.angles
            alpha = np.around(angles[0],1)
            beta = np.around(angles[1],1)
            gamma = np.around(angles[2],1)
            
            cell_length_a = structure.lattice.a
            cell_length_b = structure.lattice.b
            cell_length_c = structure.lattice.c
    
            atoms = structure.to_ase_atoms()
            #cartesian_coords = atoms.get_positions()
            #fraction_coords = atoms.get_scaled_positions()
            
            cartesian_coords = structure.cart_coords
            fraction_coords = structure.frac_coords
            for x in range(len(cartesian_coords)):
                for y in range(len(cartesian_coords[x])):
                    cartesian_coords[x][y] = f'{cartesian_coords[x][y]:.8f}'
            cartesian_coords
            
            labels = atoms.get_chemical_symbols()
            #labels = [str(site.specie) for site in structure]   #sometimes strange if using this order
            element = list(set(labels))
            
            element_succint = np.unique(labels)
            
            car_coords = {}
            for x_i in range(len(cartesian_coords)):
                car_coords[x_i] = Keyword('{label}'.format(label = labels[x_i].strip()),'  ',
                                        f'{cartesian_coords[x_i][0]:.8f}', '  ',
                                        f'{cartesian_coords[x_i][1]:.8f}', '  ',
                                        f'{cartesian_coords[x_i][2]:.8f}'
                                       )
    
            fra_coords = {}
            for x_i in range(len(fraction_coords)):
                fra_coords[x_i] = Keyword('{label}'.format(label = labels[x_i].strip()),'  ',
                                        f'{fraction_coords[x_i][0]:.8f}', '  ',
                                        f'{fraction_coords[x_i][1]:.8f}', '  ',
                                        f'{fraction_coords[x_i][2]:.8f}'
                                       )
            #use cartesian or not
            use_cartesian_y_n = input('\nIf to use cartesian coordination during calc. [y/n]:\n')
            if use_cartesian_y_n.strip() == 'y':
                print('\nUse cartesian coordination!\n')
                coord_sec = car_coords
                
            elif use_cartesian_y_n.strip() == 'n':
                print('\nUse cartesian coordination!\n')
                coord_sec = fra_coords
                
        if structure_filename.endswith('vasp') or structure_filename.endswith('poscar') or structure_filename.endswith('contcar'):
            #atoms = Atoms(read(structure_filename, format = 'vasp'))
            structure = Structure.from_file(structure_filename)
            
            vector_A = structure.lattice.matrix[0]
            A = [f'{x:.8f}' for x in np.around(vector_A,8)]
            vector_B = structure.lattice.matrix[1]
            B = [f'{x:.8f}' for x in np.around(vector_B,8)]
            vector_C = structure.lattice.matrix[2]
            C = [f'{x:.8f}' for x in np.around(vector_C,8)]
            
            angles = structure.lattice.angles
            alpha = np.around(angles[0],1)
            beta = np.around(angles[1],1)
            gamma = np.around(angles[2],1)
            
            cell_length_a = structure.lattice.a
            cell_length_b = structure.lattice.b
            cell_length_c = structure.lattice.c
            
            cartesian_coords = structure.cart_coords
            #cartesian_coords = atoms.get_positions()
            fraction_coords = structure.frac_coords
            for x in range(len(cartesian_coords)):
                for y in range(len(cartesian_coords[x])):
                    cartesian_coords[x][y] = f'{cartesian_coords[x][y]:.8f}'
            cartesian_coords
    
            atoms = structure.to_ase_atoms()  #one method
            labels = atoms.get_chemical_symbols()
            
            #labels = [str(site.specie) for site in structure]
            element = list(set(labels))
            
            element_succint = np.unique(labels)
            
            car_coords = {}
            for x_i in range(len(cartesian_coords)):
                car_coords[x_i] = Keyword('{label}'.format(label = labels[x_i].strip()),'  ',
                                        f'{cartesian_coords[x_i][0]:.8f}', '  ',
                                        f'{cartesian_coords[x_i][1]:.8f}', '  ',
                                        f'{cartesian_coords[x_i][2]:.8f}'
                                       )
    
            fra_coords = {}
            fra_coords['scaled'] = Keyword('SCALED','T')
            for x_i in range(len(fraction_coords)):
                fra_coords[x_i] = Keyword('{label}'.format(label = labels[x_i].strip()),'  ',
                                        f'{fraction_coords[x_i][0]:.8f}', '  ',
                                        f'{fraction_coords[x_i][1]:.8f}', '  ',
                                        f'{fraction_coords[x_i][2]:.8f}'
                                       )
    
            #use cartesian or not
            use_cartesian_y_n = input('\nIf to use cartesian coordination during calc. [y/n]:\n')
            if use_cartesian_y_n.strip() == 'y':
                print('\nUse cartesian coordination!\n')
                coord_sec = car_coords
                
            elif use_cartesian_y_n.strip() == 'n':
                print('\nUse cartesian coordination!\n')
                coord_sec = fra_coords

        if structure_filename.endswith('restart') or structure_filename.endswith('inp'):   #parse the cp2k inp or restart file
            structure_info = parse_cp2k_restart(structure_filename)
            
            vector_A = structure_info.lattice.matrix[0]
            A = [f'{x:.8f}' for x in np.around(vector_A,8)]
            vector_B = structure_info.lattice.matrix[1]
            B = [f'{x:.8f}' for x in np.around(vector_B,8)]
            vector_C = structure_info.lattice.matrix[2]
            C = [f'{x:.8f}' for x in np.around(vector_C,8)]
            
            angles = structure_info.lattice.angles
            alpha = np.around(angles[0],1)
            beta = np.around(angles[1],1)
            gamma = np.around(angles[2],1)
            
            cell_length_a = structure_info.lattice.a
            cell_length_b = structure_info.lattice.b
            cell_length_c = structure_info.lattice.c
            
            cartesian_coords = structure_info.cart_coords
            #cartesian_coords = atoms.get_positions()
            fraction_coords = structure_info.frac_coords
            for x in range(len(cartesian_coords)):
                for y in range(len(cartesian_coords[x])):
                    cartesian_coords[x][y] = f'{cartesian_coords[x][y]:.8f}'
            cartesian_coords
    
            atoms = structure_info.to_ase_atoms()  #one method
            labels = atoms.get_chemical_symbols()
            
            #labels = [str(site.specie) for site in structure_info]
            element = list(set(labels))
            
            element_succint = np.unique(labels)
            
            car_coords = {}
            for x_i in range(len(cartesian_coords)):
                car_coords[x_i] = Keyword('{label}'.format(label = labels[x_i].strip()),'  ',
                                        f'{cartesian_coords[x_i][0]:.8f}', '  ',
                                        f'{cartesian_coords[x_i][1]:.8f}', '  ',
                                        f'{cartesian_coords[x_i][2]:.8f}'
                                       )
    
            fra_coords = {}
            fra_coords['scaled'] = Keyword('SCALED','T')
            for x_i in range(len(fraction_coords)):
                fra_coords[x_i] = Keyword('{label}'.format(label = labels[x_i].strip()),'  ',
                                        f'{fraction_coords[x_i][0]:.8f}', '  ',
                                        f'{fraction_coords[x_i][1]:.8f}', '  ',
                                        f'{fraction_coords[x_i][2]:.8f}'
                                       )
    
            #use cartesian or not
            use_cartesian_y_n = input('\nIf to use cartesian coordination during calc. [y/n]:\n')
            if use_cartesian_y_n.strip() == 'y':
                print('\nUse cartesian coordination!\n')
                coord_sec = car_coords
                
            elif use_cartesian_y_n.strip() == 'n':
                print('\nUse cartesian coordination!\n')
                coord_sec = fra_coords    
    
    '''
    End the reading of structure information
    '''

    ###########################################################################################
    
    '''
    Begin the GLOBAL section in cp2k
    '''
    def global_section(project_name:str,run_type:str) -> cp2k_section:
        GLOBAL = Section(name = 'GLOBAL',
                         keywords = {'project_name':Keyword('PROJECT_NAME',project_name),
                                     'run_type':Keyword('RUN_TYPE',run_type),
                                     'print_level':Keyword('PRINT_LEVEL','MEDIUM'),
                                     'prefer_diag_lib':Keyword('#PREFERRED_DIAG_LIBRARY','SCALAPACK','\t #default-ELPA, when scf discontinues, uncomment this tag'),
                                     'prefer_fft_library':Keyword('#PREFERRED_FFT_LIBRARY','FFTSG','\t #Stefan Goedecker-FFT(FFTSG), cp2k recommends for PSOLVER of WAVELET, default-FFTW3'),
                                     'walltime':Keyword('#WALLTIME',86400,'\t#total time in seconds, or in the form of {HH:MM:SS}'),
                                    }
                        )
        return GLOBAL        
    '''
    End the GLOBAL section in cp2k
    '''
    
    ############################################################################################
    
    '''
    Begin the FORCE_EVAL section in cp2k
    '''
    def subsys_section(subsys_subs:Dict[str,cp2k_section]) -> cp2k_section:
        '''
        how to use:
        subsys_section(cell_coord(coord_sec))
        subsys_section(cell_coord_kind_normal(coord_sec,basis_set_list,potential))
        subsys_section(cell_coord_kind_admm(coord_sec,basis_set_list,basis_set_admm_list,potential))
        where basis_set_list = basis_set(),
        basis_set_admm_list = basis_set_admm(),
        potential = potential()
        '''
        SUBSYS = Section(name = 'SUBSYS', subsections = subsys_subs)
        return SUBSYS   #return a section

    
    def cell_coord(coord_sec:Dict[str,object]) -> Dict[str,cp2k_section]:
        '''
        This definition is for semi_emperical calc., such as XTB, SE, PM6...
        Perhaps you use this section for the large supercell, so I define the multiple_unit_cell function
        '''
        #input the super cell dimension
        super_cell_dim_inp = input('\nPlease type in the supercell dimension, e.g. 3,3,3:\n')
        dim_indexes = super_cell_dim_inp.strip().split(',')
        
        cell_coord_subs = {}
        cell_coord_subs['topology'] = Section(name = 'TOPOLOGY', 
                                              keywords = {'multiple_unit_cell':Keyword('MULTIPLE_UNIT_CELL', int(dim_indexes[0]),int(dim_indexes[1]),int(dim_indexes[2]))}
                                             )
        
        #add the &CELL
        cell_coord_subs['cell'] = Section(name = 'CELL',
                                          keywords = {'A':Keyword('A','  ',A[0],'  ',A[1],'  ',A[2]),
                                                      'B':Keyword('B','  ',B[0],'  ',B[1],'  ',B[2]),
                                                      'C':Keyword('C','  ',C[0],'  ',C[1],'  ',C[2]),
                                                      'PERIODIC':Keyword('PERIODIC','XYZ','\t #should match with that in &PSOLVER'),
                                                      'ALPHA_BETA_GAMMA': Keyword('ALPHA_BETA_GAMMA',alpha,beta,gamma),
                                                      'multiple_unit_cell':Keyword('MULTIPLE_UNIT_CELL', int(dim_indexes[0]),int(dim_indexes[1]),int(dim_indexes[2])),
                                                     }
                                         )
        #add the &COORD
        cell_coord_subs['COORD'] = Section(name = 'COORD', keywords = coord_sec)

        return cell_coord_subs

    
    def cell_coord_kind_normal(coord_sec:Dict[str,object], basis_set_list:List[str], potential_list:List[str]) -> Dict[str,cp2k_section]:
        '''
        This is the normal section definition of &SUBSYS with &CELL and &COORD
        input: coord_sec <- a dictionary of like {'Fe':Keyword('Fe','5.0  5.0  5.0')}
        '''
        cell_coord_kind_subs = {}
        
        #add the &CELL
        cell_coord_kind_subs['cell'] = Section(name = 'CELL',
                                               keywords = {'A':Keyword('A','  ',A[0],'  ',A[1],'  ',A[2]),
                                                           'B':Keyword('B','  ',B[0],'  ',B[1],'  ',B[2]),
                                                           'C':Keyword('C','  ',C[0],'  ',C[1],'  ',C[2]),
                                                           'PERIODIC':Keyword('PERIODIC','XYZ','\t #should match with that in &PSOLVER'),
                                                           'ALPHA_BETA_GAMMA': Keyword('ALPHA_BETA_GAMMA',alpha,beta,gamma),
                                                          }
                                              )

        #add the &COORD
        cell_coord_kind_subs['COORD'] = Section(name = 'COORD', keywords = coord_sec)            

        #add the &KIND for each element
        for e_i,bs_i,p_i in zip(element, basis_set_list, potential_list):
            cell_coord_kind_subs['KIND_{}'.format(e_i)] = Section(name = 'KIND',
                                                                section_parameters = [e_i],
                                                                keywords = {'ELEMENT': Keyword('ELEMENT', e_i),
                                                                            'BASIS_SET': Keyword('BASIS_SET', bs_i),
                                                                            'POTENTIAL': Keyword('POTENTIAL', p_i),
                                                                            'MAGNETIZATION':Keyword('#MAGNETIZATION',1),
                                                                           },
                                                      )

        return cell_coord_kind_subs


    def cell_coord_kind_admm(coord_sec:Dict[str,object],basis_set_list:List[str],basis_set_admm_list:List[str],potential_list:List[str]) -> Dict[str,cp2k_section]:
        cell_coord_kind_subs = {}

        #add the &CELL
        cell_coord_kind_subs['cell'] = Section(name = 'CELL',
                                               keywords = {'A':Keyword('A','  ',A[0],'  ',A[1],'  ',A[2]),
                                                           'B':Keyword('B','  ',B[0],'  ',B[1],'  ',B[2]),
                                                           'C':Keyword('C','  ',C[0],'  ',C[1],'  ',C[2]),
                                                           'PERIODIC':Keyword('PERIODIC','XYZ','\t #should match with that in &PSOLVER'),
                                                           'ALPHA_BETA_GAMMA': Keyword('ALPHA_BETA_GAMMA',alpha,beta,gamma),
                                                          }
                                              )

        #add the &COORD
        cell_coord_kind_subs['COORD'] = Section(name = 'COORD', keywords = coord_sec)            

        #add the &KIND for each element
        for e_i,bs_i,bs_admm_i,p_i in zip(element, basis_set_list, basis_set_admm_list,potential_list):
            cell_coord_kind_subs['KIND_{}'.format(e_i)] = Section(name = 'KIND',
                                                                section_parameters = [e_i],
                                                                keywords = {'ELEMENT': Keyword('ELEMENT', e_i),
                                                                            'BASIS_SET_main': Keyword('BASIS_SET', bs_i),
                                                                            'BASIS_SET_aux':Keyword('BASIS_SET','AUX_FIT',bs_admm_i),
                                                                            'POTENTIAL': Keyword('POTENTIAL', p_i),
                                                                            'MAGNETIZATION':Keyword('#MAGNETIZATION',1),
                                                                           },
                                                      )

        return cell_coord_kind_subs    



    #DFT definition
    def dft_normal(project_name:str,dft_subs:cp2k_section,bs_filename_list:List[str],potential_filename:List[str]) -> Dict[str,cp2k_section]:
        '''
        how to use: dft_normal(dft_subs, basis_set_filename(), potential_filename())
        '''
        dft_normal_keywords_dict = {}
        for x_i,bs_filename_i in enumerate(bs_filename_list):
            dft_normal_keywords_dict[x_i] = Keyword('BASIS_SET_FILE_NAME',bs_filename_i)

        dft_normal_keywords_dict['potential_file_name'] = Keyword('POTENTIAL_FILE_NAME',potential_filename)
        dft_normal_keywords_dict['WFN_RESTART_FILE_NAME'] = Keyword('#WFN_RESTART_FILE_NAME','{}-RESTART.kp(.wfn)'.format(project_name))
        dft_normal_keywords_dict['sort_basis'] = Keyword('SORT_BASIS','EXP')
        dft_normal_keywords_dict['charge'] = Keyword('CHARGE',0)
        dft_normal_keywords_dict['multiplicity'] = Keyword('MULTIPLICITY',1,'\t #if hard convergence, try different values')
        dft_normal_keywords_dict['relax_multiplicity'] = Keyword('#RELAX_MULTIPLICITY','1E-04','\t #1E-03~1E-05, large value for easy spin flip, if hard convergence, uncomment this tag')
        dft_normal_keywords_dict['uks'] = Keyword('#UKS','T','\t #when using spin-polarized calculation')
        
        DFT = Section(name = 'DFT',
                      keywords = dft_normal_keywords_dict,
                      subsections = dft_subs
                     )
        return DFT     #this returns a section


    def dft_admm(project_name:str, dft_admm_subs:cp2k_section,bs_filename_list:List[str],bs_admm_filename_list:List[str],potential_filename:List[str]) -> Dict[str,cp2k_section]:
        dft_admm_keywords_dict = {}
        for x_i,bs_filename_i in enumerate(bs_filename_list):
            dft_admm_keywords_dict[str(x_i) + 'main'] = Keyword('BASIS_SET_FILE_NAME',bs_filename_i)
        
        for x_i,bs_admm_filename_i in enumerate(bs_admm_filename_list):
            dft_admm_keywords_dict[str(x_i) + 'aux'] = Keyword('BASIS_SET_FILE_NAME',bs_admm_filename_i)
        
        dft_admm_keywords_dict['potential_file_name'] = Keyword('POTENTIAL_FILE_NAME',potential_filename)
        dft_admm_keywords_dict['WFN_RESTART_FILE_NAME'] = Keyword('#WFN_RESTART_FILE_NAME','{}-RESTART.kp(.wfn)'.format(project_name))
        dft_admm_keywords_dict['sort_basis'] = Keyword('SORT_BASIS','EXP')
        dft_admm_keywords_dict['charge'] = Keyword('CHARGE',0)
        dft_admm_keywords_dict['multiplicity'] = Keyword('MULTIPLICITY',1,'\t #if hard convergence, try different values')
        dft_admm_keywords_dict['relax_multiplicity'] = Keyword('#RELAX_MULTIPLICITY','1E-04','\t #1E-03~1E-05, large value for easy spin flip, if hard convergence, uncomment this tag')
        dft_admm_keywords_dict['uks'] = Keyword('#UKS','T','\t #when using spin-polarized calculation')
        
        DFT = Section(name = 'DFT',
                      keywords = dft_admm_keywords_dict,
                      subsections = dft_admm_subs
                     )
        return DFT     #this returns a section

    def dft_admm_RI_HFX(project_name:str,dft_admm_RI_HFX_subs:cp2k_section,bs_filename_list:List[str],bs_admm_filename_list:List[str],potential_filename:List[str]) -> Dict[str,cp2k_section]:
        dft_admm_RI_HFX_keywords_dict = {}
        for x_i,bs_filename_i in enumerate(bs_filename_list):
            dft_admm_RI_HFX_keywords_dict[str(x_i) + 'main'] = Keyword('BASIS_SET_FILE_NAME',bs_filename_i)
        
        for x_i,bs_admm_filename_i in enumerate(bs_admm_filename_list):
            dft_admm_RI_HFX_keywords_dict[str(x_i) + 'aux'] = Keyword('BASIS_SET_FILE_NAME',bs_admm_filename_i)
        
        dft_admm_RI_HFX_keywords_dict['potential_file_name'] = Keyword('POTENTIAL_FILE_NAME',potential_filename)
        dft_admm_RI_HFX_keywords_dict['WFN_RESTART_FILE_NAME'] = Keyword('#WFN_RESTART_FILE_NAME','{}-RESTART.kp(.wfn)'.format(project_name))
        dft_admm_RI_HFX_keywords_dict['sort_basis'] = Keyword('SORT_BASIS','EXP')
        dft_admm_RI_HFX_keywords_dict['auto_basis'] = Keyword('AUTO_BASIS','RI_HFX','MEDIUM','\t #when using RI-HFX, others: SMALL,LARGE,HUGE')
        dft_admm_RI_HFX_keywords_dict['charge'] = Keyword('CHARGE',0)
        dft_admm_RI_HFX_keywords_dict['multiplicity'] = Keyword('MULTIPLICITY',1,'\t #if hard convergence, try different values')
        dft_admm_RI_HFX_keywords_dict['relax_multiplicity'] = Keyword('#RELAX_MULTIPLICITY','1E-04','\t #1E-03~1E-05, large value for easy spin flip, if hard convergence, uncomment this tag')
        dft_admm_RI_HFX_keywords_dict['uks'] = Keyword('#UKS','T','\t #when using spin-polarized calculation')
        
        DFT = Section(name = 'DFT',
                      keywords = dft_admm_RI_HFX_keywords_dict,
                      subsections = dft_admm_RI_HFX_subs
                     )
        return DFT   #this returns a section


    def dft_print() -> Dict[str,cp2k_section]:   #currently only print e_density cube
        EACH = Section(name = 'EACH', 
                       keywords = {'qs_scf':Keyword('QS_SCF',0), 
                                   'geo_opt':Keyword('#GEO_OPT',0),
                                   'cell_opt':Keyword('#CELL_OPT',0),
                                   'md':Keyword('#MD',50)
                                  }
                      )
        dft_print_subs = {}
        dft_print_subs['e_density_cube'] = Section(name = 'E_DENSITY_CUBE',
                                                   keywords = {'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                               'common_iter_levels':Keyword('COMMON_ITERATION_LEVELS',3),
                                                               'stride':Keyword('STRIDE',2,2,2),
                                                              },
                                                   subsections = {'each':EACH}
                                                  )
        dft_print_subs['v_hartree_cube'] = Section(name = 'V_HARTREE_CUBE',
                                                   keywords = {'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                               'common_iter_levels':Keyword('COMMON_ITERATION_LEVELS',3),
                                                               'stride':Keyword('STRIDE',2,2,2),
                                                              },
                                                   subsections = {'each':EACH}
                                                  )
        dft_print_subs['mo_info'] = Section(name = 'MO',
                                           keywords = {'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                       'common_iter_levels':Keyword('COMMON_ITERATION_LEVELS',3),
                                                       'ndigits':Keyword('NDIGITS',8),
                                                       'filename':Keyword('FILENAME','mo_info'),
                                                       'coefficients':Keyword('#COEFFICIENTS','T'),
                                                       'energies':Keyword('ENERGIES','T'),
                                                       'occupation_num':Keyword('OCCUPATION_NUMBERS','T'),
                                                       'mo_index_range':Keyword('#MO_INDEX_RANGE',1,7),
                                                      },
                                           subsections = {'each':EACH}
                                                  )
        
        #note that the default setting of CP2K to print hirshfeld charge based on shape function of Gaussian is inappropriate
        dft_print_subs['hirshfeld'] = Section(name = 'HIRSHFELD',
                                              keywords = {'SHAPE_FUNCTION':Keyword('SHAPE_FUNCTION','DENSITY', '\t #default-GAUSSIAN'),
                                                          'self_consistent':Keyword('#SELF_CONSISTENT','T','\t #default-F, T-is to calculate HIRSHFELD-I charge')
                                                         }
                                             )
        
        DFT_print = Section(name = 'PRINT', subsections = dft_print_subs)
        return DFT_print   #this returns a section
        
           
    def aux_density_matrix_admm(use_ot:str) -> Dict[str,cp2k_section]:
        if use_ot == 'n':
            puri_method = 'NONE'
        elif use_ot == 'y':
            puri_method = 'MO_DIAG'
        
        aux_den_matr_admm = Section(name = 'AUXILIARY_DENSITY_MATRIX_METHOD',
                                    keywords = {'admm_type':Keyword('ADMM_TYPE','ADMM1','\t #default-NONE, ADMM1-use pure, ADMM2-no pure, ADMMS and ADMMP-no pure'),
                                                'method':Keyword('METHOD','BASIS_PROJECTION','\t #default, others: BLOCKED_PROJECTION_PURIFY_FULL, BLOCKED_PROJECTION, CHARGE_CONSTRAINED_PROJECTION'),
                                                'purify':Keyword('#ADMM_PURIFICATION_METHOD',puri_method,'\t #wfn purify, MO_DIAG only for OT,if not OT, set NONE'), 
                                                'exch_corr_func':Keyword('EXCH_CORRECTION_FUNC','DEFAULT','\t #default-PBE correction, OPTX may be better, others:PBEX, BECKE88X')
                                               })
        return aux_den_matr_admm   #this returns a section

    
    def aux_density_matrix_admm_RI() -> Dict[str,cp2k_section]:     #needs the kpoints, so not support for OT, currently
        aux_den_matr_admm_RI = Section(name = 'AUXILIARY_DENSITY_MATRIX_METHOD',
                                     keywords = {'admm_type':Keyword('ADMM_TYPE','ADMMS','\t #best choice for RI_HFX'),
                                                 'method':Keyword('METHOD','BASIS_PROJECTION','\t #default, others: BLOCKED_PROJECTION_PURIFY_FULL, BLOCKED_PROJECTION, CHARGE_CONSTRAINED_PROJECTION'),
                                                 'purify':Keyword('#ADMM_PURIFICATION_METHOD','NONE','\t #RI_HFX not support purification')
                                                }
                                      )
        return aux_den_matr_admm_RI   #this returns a section

    
    def kpoints() -> Dict[str,cp2k_section]:
        k_a = int(np.ceil(45 / cell_length_a))
        k_b = int(np.ceil(45 / cell_length_b))
        k_c = int(np.ceil(45 / cell_length_c))
        
        kpts_inp = input('\nType in the kpoints, e.g. 3,3,3; very strict-{},{},{}; 1 for non-periodic direction!:\n'.format(k_a, k_b, k_c))
        kpts_list = kpts_inp.split(',')
        
        KPOINTS = Section(name = 'KPOINTS',
                         keywords = {'scheme':Keyword('SCHEME','MONKHORST-PACK',
                                                      int(kpts_list[0]),
                                                      int(kpts_list[1]),
                                                      int(kpts_list[2]),
                                                      '\t #currently not support: OT, DFT+U, output PDOS, output molden, phonon, LSSCF, SCCS, TDDFT, IR,Raman,NMR...'
                                                     ),
                                     'full_grid':Keyword('#FULL_GRID','T','\t #default-F, use full non-reduced kpoint grid, T considers the inversion to reduce kpoints')
                                    }
                         )
        return KPOINTS    #this returns a section

    
    def qs(method_index:int, qs_subs:cp2k_section) -> Dict[str,cp2k_section]:           #quickstep module methods
        qs_method_dict = {-2:'GPW',
                         -1:'GAPW',
                          0:'GAPW_XC',
                          1:'LRIGPW',
                          2:'RIGPW',
                          3:'DFTB',
                          4:'XTB',
                          5:'OFGPW',
                          6:'MNDO',
                          7:'MNDOD',
                          8:'AM1',
                          9:'PM3',
                          10:'PM6',
                          11:'PM6-FM',
                          12:'PDG',
                          13:'RM1',
                          14:'PNNL'
                         }
        
        need_qs_subs = [1,3,4,10]
        
        if method_index in need_qs_subs:
            QS = Section(name = 'QS',
                keywords = {'eps_default':Keyword('EPS_DEFAULT','1E-12','\t #1E-14-vibration, 1E-10-MD'),
                            'eps_pgf_orb':Keyword('EPS_PGF_ORB','1E-6','\t #precision of the overlap matrix elements, value is sqrt(EPS_DEFAULT)'),
                            'extrapolation':Keyword('#EXTRAPOLATION','USE_PREV_P','\t #for geo_opt, montcarlo,default-ASPC (or PS, for stable MD, not for kpoints), USE_GUESS'),
                            'extrapolation order':Keyword('#EXTRAPOLATION_ORDER',3,'\t #default, typical 2-4, higher value for accuracy with cost'),
                            'method':Keyword('METHOD',qs_method_dict[method_index])
                           },
                subsections = qs_subs
                )
        else: 
            QS = Section(name = 'QS',
                keywords = {'eps_default':Keyword('EPS_DEFAULT','1E-12','\t #1E-14-vibration, 1E-10-MD'),
                            'eps_pgf_orb':Keyword('EPS_PGF_ORB','1E-6','\t #precision of the overlap matrix elements, value is sqrt(EPS_DEFAULT)'),
                            'extrapolation':Keyword('#EXTRAPOLATION','USE_PREV_P','\t #for geo_opt, montcarlo,default-ASPC (or PS, for stable MD, not for kpoints), USE_GUESS'),
                            'extrapolation order':Keyword('#EXTRAPOLATION_ORDER',3,'\t #default, typical 2-4, higher value for accuracy with cost'),
                            'method':Keyword('METHOD',qs_method_dict[method_index])
                           },
                )    
            
        return QS        #this returns a section


    def poisson() -> Dict[str,cp2k_section]:
        POISSON = Section(name = 'POISSON',
                         keywords = {'periodic':Keyword('PERIODIC','XYZ', '\t # should match with that in &CELL'),
                                     'psolver':Keyword('PSOLVER','PERIODIC',
                                                       '\t #others:MT-0D,2D-twice lattice cell size, WAVELET-0D,2D(only XZ),3D-must cubic box and centered molecule')
                                    })
        return POISSON   #this returns a section
    
       
    def mgrid(cutoff:int,rel_cutoff:int) -> Dict[str,cp2k_section]:
        MGRID = Section(name = 'MGRID',
                       keywords = {'cutoff':Keyword('CUTOFF', 400,'\t #300, 400, 600, [Ry], not need for semi-emperical calc.'),
                                   'rel_cutoff':Keyword('REL_CUTOFF', 55,'\t # 45, 55, 65, [Ry], 50+-10Ry might be highly accurate results'), 
                                   'ngrids':Keyword('NGRIDS', 5,'\t #number of multigrids to use, default-4')
                                  }
                       )
        return MGRID    #this returns a section    


    def scf(subs_for_scf:Dict[str,cp2k_section], use_ot:str) -> Dict[str,cp2k_section]:
        if use_ot == 'y':
            SCF = Section(name = 'SCF',
                          keywords = {'max_scf':Keyword('MAX_SCF',30,'\t #decrease this value when using OT, e.g. 15-35'),
                                      'max_diis':Keyword('#MAX_DIIS',6,'\t #default-4, increase this value may be better'),
                                      'eps_diis':Keyword('#EPS_DIIS',0.3,'\t #a small value, can increase this value'),
                                      'eps_scf':Keyword('EPS_SCF','1E-06','\t #set to <1E-07, 1E-08-if imaginary vibs'),
                                      'scf_guess':Keyword('#SCF_GUESS','RESTART',
                                                          '\t #default-ATOMIC(using atomic code, can use &BS in &KIND), RESTART-change to ATOMIC if not present'),
                                      'ignore':Keyword('IGNORE_CONVERGENCE_FAILURE','T'),
                                     },
                          subsections = subs_for_scf
                         )

        elif use_ot == 'n':
            SCF = Section(name = 'SCF',
                          keywords = {'max_scf':Keyword('MAX_SCF',130,'\t #decrease this value when using OT, e.g. 15-35'),
                                      'max_diis':Keyword('#MAX_DIIS',6,'\t #default-4, increase this value may be better'),
                                      'eps_diis':Keyword('#EPS_DIIS',0.3,'\t #a small value, can increase this value'),
                                      'eps_scf':Keyword('EPS_SCF','1E-06','\t #set to <1E-07, 1E-08-if imaginary vibs'),
                                      'scf_guess':Keyword('#SCF_GUESS','RESTART',
                                                          '\t #default-ATOMIC(using atomic code, can use &BS in &KIND), RESTART-change to ATOMIC if not present'),
                                      'ignore':Keyword('IGNORE_CONVERGENCE_FAILURE','T'),
                                      'add_mos':Keyword('ADDED_MOS',50,'\t #create virtual MOs, not support for &OT, set -1 for all(may crash for some systems)'),
                                     },
                          subsections = subs_for_scf
                         )
            
        return SCF   #this returns a section


    def scf_diag() -> Dict[str,cp2k_section]:
        DIAGONALIZATION = Section(name = 'DIAGONALIZATION',
                                 keywords = {'algo':Keyword('ALGORITHM','STANDARD')
                                            }
                                 )
        return DIAGONALIZATION  #this returns a section

    def scf_smear() -> Dict[str,cp2k_section]:
        SMEAR = Section(name = 'SMEAR', section_parameters = ['ON'],
                        keywords = {'electronic_temp':Keyword('ELECTRONIC_TEMPERATURE',300),
                                    'method':Keyword('METHOD','FERMI_DIRAC'),
                                    'window_size':Keyword('#WINDOW_SIZE','[eV]',0.3),
                                   }
                       )
        return SMEAR

    def scf_mixing() -> Dict[str,cp2k_section]:
        MIXING = Section(name = 'MIXING',
                         keywords = {'method':Keyword('METHOD','BROYDEN_MIXING','\t #PULAY_MIXING is also acceptable, default-DIRECT_P_MIXING-typically bad'),
                                     'alpha':Keyword('ALPHA', 0.2,'\t #default-0.4, mixing of new density matrix with old component, may decrease for convergence'),
                                     'nbroyden':Keyword('NBROYDEN',10,'\t #default-4, large value for easy convergence when using BROYDEN_MIXING'),
                                     'npulay':Keyword('#NPULAY',10,'\t #default-4, large value for easy convergence when using PULAY_MIXING'),
                                    }
                        )
        return MIXING   #this returns a section

    
    def scf_ot() -> Dict[str,cp2k_section]:
        OT = Section(name = 'OT', section_parameters = ['T \t #not used for smearing, metallic system, kpoints'],
                    keywords = {'preconditioner':Keyword('PRECONDITIONER','FULL_SINGLE_INVERSE',
                                                         '\t #FULL_SINGLE_INVERSE-for large systems, FULL_ALL-almost all systems except very large ones but with cost (should always for GAPW), FULL_KINETIC-very large ones'),
                                'minimizer':Keyword('MINIMIZER','DIIS','\t #CG for difficult cases, BROYDEN for inverse Hessian'),
                                'linesearch':Keyword('LINESEARCH','2PNT', 
                                                     '\t #2PNT-default, 3PNT-better but cost, GOLD is best but expensive, not recommend SD'),
                                'algorithm':Keyword('ALGORITHM','STRICT','\t #default, others:IRAC-iterative refinement of the Approximative Congruence transformation'),
                                'ortho_irac':Keyword('#ORTHO_IRAC','CHOL','\t #default, orthogonality method, others: POLY-polynomial, LWDN-Lowdin')
                               }
                    )
        return OT  #this returns a section


    def scf_outer_scf() -> Dict[str,cp2k_section]:   #work for OT
        OUTER_SCF = Section(name = 'OUTER_SCF',
                           keywords = {'max_scf':Keyword('MAX_SCF',20,'\t #smaller value for easy convergence, but large cost'),
                                       'eps_scf':Keyword('EPS_SCF','1E-06','\t #convergence threshold of outer scf, value <= EPS_SCF in &SCF'),
                                      }
                           )
        return OUTER_SCF   #this returns a section
    
    
    def scf_print() -> Dict[str,cp2k_section]:
        EACH = Section(name = 'EACH', 
                       keywords = {'qs_scf':Keyword('QS_SCF',0,'\t #default-20, 0-never print after each scf'),
                                   'cell_opt':Keyword('#CELL_OPT',0),
                                   'geo_opt':Keyword('#GEO_OPT',0),
                                   'md':Keyword('#MD',50),
                                  }
                      )
        scf_print_subs = {}
        scf_print_subs['restart'] = Section(name = 'RESTART',
                                            section_parameters = ['#OFF \t #avoid the output of .wfn/.kp'],
                                            keywords = {'back_copies':Keyword('BACKUP_COPIES',0,'\t #never print any .bak file'),
                                                        'filename':Keyword('FILENAME','RESTART'),
                                                        'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                        'iter_level':Keyword('COMMON_ITERATION_LEVELS',3,'\t #default'),
                                                       },
                                            subsections = {'each':EACH}
                                           )
        scf_print_subs['restart_history'] = Section(name = 'RESTART_HISTORY', 
                                                    section_parameters = ['OFF'])
        scf_print_subs['detailed_energy'] = Section(name = 'DETAILED_ENERGY',
                                                    section_parameters = ['OFF \t #others:LOW'])
        SCF_PRINT = Section(name = 'PRINT', subsections = scf_print_subs)
        return SCF_PRINT   #this returns a section

    
    def force_eval_print(run_type:str) -> Dict[str,cp2k_section]:
        if run_type == 'ENERGY':
            force_eval_print_subs = {}
            force_eval_print_subs['program_run_info'] = Section(name = 'PROGRAM_RUN_INFO',
                                                                keywords = {'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last')},
                                                                subsections = {'each':Section(name = 'EACH', keywords = {'qs_scf':Keyword('QS_SCF',1)})}
                                                               )
            FORCE_EVAL_PRINT = Section(name = 'PRINT', subsections = force_eval_print_subs)
            return FORCE_EVAL_PRINT
            
        elif run_type == 'ENERGY_FORCE':
            force_eval_print_subs = {}
            stress_tensor_subs = {}
            forces_subs = {}
            
            stress_tensor_subs['each'] = Section(name = 'EACH',
                                                 keywords = {'qs_scf':Keyword('QS_SCF',1,'\t #if SP calculation, set 1')
                                                            })        
            force_eval_print_subs['STRESS_TENSOR'] = Section(name = 'STRESS_TENSOR',
                                                             section_parameters = ['ON'], 
                                                             keywords = {'filename':Keyword('FILENAME'),
                                                                         'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                                        'common_iter_levels':Keyword('COMMON_ITERATION_LEVELS',1,
                                                                                                     '\t #if 0, create projectname-1_steps.stress_tensor')}, 
                                                             subsections = stress_tensor_subs)
            
            forces_subs['each'] = Section(name = 'EACH',
                                          keywords = {'qs_scf':Keyword('QS_SCF',1,'\t #if SP calculation, set 1')
                                                     })
            
            force_eval_print_subs['FORCES'] = Section(name = 'FORCES',
                                                      section_parameters = ['ON'], 
                                                      keywords = {'filename':Keyword('FILENAME','atomic_forces'), 
                                                                  'add_last':Keyword('ADD_LAST', 'NUMERIC', '\t #even each set to 0, might print the last'),
                                                                  'common_iter_levels':Keyword('COMMON_ITERATION_LEVELS',1,
                                                                                               '\t #if 0, create projectname-1_atomic_forces_steps.xyz')}, 
                                                      subsections = forces_subs)
            
            FORCE_EVAL_PRINT = Section(name = 'PRINT', subsections = force_eval_print_subs)
            return FORCE_EVAL_PRINT
            
        elif run_type == 'GEO_OPT':
            force_eval_print_subs = {}
            stress_tensor_subs = {}
            forces_subs = {}
            
            stress_tensor_subs['each'] = Section(name = 'EACH',keywords = {'geo_opt':Keyword('GEO_OPT',1),
                                                                           'qs_scf':Keyword('QS_SCF',0)})        
            force_eval_print_subs['STRESS_TENSOR'] = Section(name = 'STRESS_TENSOR',
                                                             section_parameters = ['ON'], 
                                                             keywords = {'filename':Keyword('FILENAME'), 
                                                                         'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                                         'common_iter_levels':Keyword('COMMON_ITERATION_LEVELS',1,
                                                                                                      '\t #if 0, create projectname-1_steps.stress_tensor')},
                                                             subsections = stress_tensor_subs)
            
            forces_subs['each'] = Section(name = 'EACH',keywords = {'geo_opt':Keyword('GEO_OPT',1), 'qs_scf': Keyword('QS_SCF',0)})
            force_eval_print_subs['FORCES'] = Section(name = 'FORCES',
                                                      section_parameters = ['ON'], 
                                                      keywords = {'filename':Keyword('FILENAME','atomic_forces'), 
                                                                  'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                                  'common_iter_levels':Keyword('COMMON_ITERATION_LEVELS',1,
                                                                                               '\t #if 0, create projectname-1_atomic_forces_steps.xyz')},
                                                      subsections = forces_subs
                                                     )
            
            FORCE_EVAL_PRINT = Section(name = 'PRINT',
                                       subsections = force_eval_print_subs)
            return FORCE_EVAL_PRINT
            
        elif run_type == 'CELL_OPT':
            force_eval_print_subs = {}
            stress_tensor_subs = {}
            forces_subs = {}
            
            stress_tensor_subs['each'] = Section(name = 'EACH',keywords = {'cell_opt':Keyword('CELL_OPT',1),'qs_scf':Keyword('QS_SCF',0)})        
            force_eval_print_subs['STRESS_TENSOR'] = Section(name = 'STRESS_TENSOR',
                                                             section_parameters = ['ON'], 
                                                             keywords = {'filename':Keyword('FILENAME'),
                                                                         'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                                         'common_iter_levels':Keyword('COMMON_ITERATION_LEVELS',1,
                                                                                               '\t #if 0, create projectname-1_steps.stress_tensor')
                                                                        },
                                                             subsections = stress_tensor_subs)
            
            forces_subs['each'] = Section(name = 'EACH',
                                          keywords = {'cell_opt':Keyword('CELL_OPT',1), 'qs_scf': Keyword('QS_SCF',0)})
            force_eval_print_subs['FORCES'] = Section(name = 'FORCES',
                                                      section_parameters = ['ON'], 
                                                      keywords = {'filename':Keyword('FILENAME','atomic_forces'),
                                                                  'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                                  'common_iter_levels':Keyword('COMMON_ITERATION_LEVELS',1,
                                                                                               '\t #if 0, create projectname-1_atomic_forces_steps.xyz')
                                                                 },
                                                      subsections = forces_subs
                                                     )
            
            FORCE_EVAL_print = Section(name = 'PRINT',
                                       subsections = force_eval_print_subs)
            return FORCE_EVAL_print
        else: 
            force_eval_print_subs = {}
            force_eval_print_subs['program_run_info'] = Section(name = 'PROGRAM_RUN_INFO',
                                                                keywords = {'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last')},
                                                                subsections = {'each':Section(name = 'EACH', keywords = {'qs_scf':Keyword('QS_SCF',1),
                                                                                                                             'md':Keyword('#MD',0)
                                                                                                                                              }
                                                                                                                   )
                                                                                             
                                                                              }
                                                               )
            FORCE_EVAL_print = Section(name = 'PRINT', subsections = force_eval_print_subs)
            
            return FORCE_EVAL_print     #this returns a section
    
    
    def force_eval_section(method:str,force_eval_subs:Dict[str,cp2k_section]) -> cp2k_section:
        '''
        load the &FORCE_EVAL section,
        how to use: force_eval_section('QUICKSTEP', sections_dict)
        where sections_dict stores all the subsections in &FORCE_EVAL,
        include &SUBSYS, &DFT, &PRINT
        '''
        FORCE_EVAL_section = Section(name = 'FORCE_EVAL',
                                     keywords = {'method':Keyword('METHOD',str(method)),
                                                 'stress_tensor':Keyword('#STRESS_TENSOR','ANALYTICAL',
                                                                 '\t #others:NUMERICAL, DIAGONAL_ANALYTICAL, DIAGONAL_NUMERICAL, uncomment for CELL_OPT, GEO_OPT, BAROSTAT(MD)')},
                                     subsections = force_eval_subs
                                    )
        return FORCE_EVAL_section      #this returns a section
    
    '''
    End the FORCE_EVAL section in cp2k
    '''
    
    #############################################################################################################
    
    '''
    Begin the basis set and potential, including admm basis set
    '''
    basis_set_dict = {-2:'DZVP-MOLOPT-SR-GTH-qX',
                      -1:'TZVP-MOLOPT-SR-GTH-qX',
                       0:'SZV-MOLOPT-SR-GTH-qX',
                       1:'TZV2P-MOLOPT-SR-GTH-qX',
                       2:'SZV-MOLOPT-GTH-qX',
                       3:'DZVP-MOLOPT-GTH-qX',
                       4:'TZVP-MOLOPT-GTH-qX',
                       5:'TZV2P-MOLOPT-GTH-qX',
                       6:'TZV2PX-MOLOPT-GTH-qX',
                      10:'pob-TZVP',
                      11:'pob-DZVP',
                      12:'pob-TZVPP',
                      13:'pob-DZVP-rev2',
                      14:'pob-TZVP-rev2',
                      20:'6-31G*',
                      30:'Ahlrichs-def2-QZVP',
                      47:'pcseg-0',
                      48:'pcseg-1',
                      49:'pcseg-2',
                      50:'pcseg-3',
                      51:'pcseg-4',
                      52:'pcX-1',
                      53:'pcX-2',
                      54:'pcX-3',
                      55:'pcX-4',
                     }
    def basis_set() -> List[str]:
        print('\nAvailable basis sets:\n')
        print(yaml.dump(basis_set_dict, sort_keys = False, default_flow_style = False))

        print('\nFind elements from structure:')
        print(element)
        basis_set_indexes_inp = input('\nChoose {} index(es) of basis set for each element, e.g. 1,2,3:\n'.format(len(element), len(element)))
        basis_set_indexes_list = basis_set_indexes_inp.strip().split(',')

        while len(basis_set_indexes_list) != len(element):   #to avoid the crash of user's wrong type number!
            if len(basis_set_indexes_list) > len(element):
                print('\nYour type-in number > {} element(s)!'.format(len(element)))

                re_type_inp_1 = input('\nPlease re-type, e.g. 1,2,3:\n')
                re_type_basis_set_indexes_list = re_type_inp_1.split(',')

                basis_set_indexes_list = re_type_basis_set_indexes_list

            if len(basis_set_indexes_list) < len(element):
                print('\nYour type-in number < {} element(s)!'.format(len(element)))

                re_type_inp_1 = input('\nPlease re-type, e.g. 1,2,3:\n')
                re_type_basis_set_indexes_list = re_type_inp_1.split(',')

                basis_set_indexes_list = re_type_basis_set_indexes_list 
        
        basis_set_list = []
        for x_i in basis_set_indexes_list:
            basis_set_list.append(basis_set_dict[int(x_i)])

                
        #new function: to replace the 'X' in qX within MOLOPT basis set
        #type in the valence electron number
        need_qX_replace_list = []
        for x_i, bs_i in enumerate(basis_set_list):
            if bs_i[-2:] == 'qX':         #only replace the MOLOLT basis set
                need_qX_replace_list.append(x_i)


        if len(need_qX_replace_list) > 0:
            print('\nFind elements from structure:')
            print(element)
            z_val_inp = input('\nPlease type in {} valence electron number(s) for each element within MOLOPT basis set, e.g., 10,12,14:\n'.format(len(element)))
            z_val_list = z_val_inp.strip().split(',')
    
            while len(z_val_list) != len(element):   #to avoid the crash of user's wrong type number!
                if len(z_val_list) > len(element):
                    print('\nYour type-in number > {} element(s)!'.format(len(element)))
    
                    re_type_inp_2 = input('\nPlease re-type, e.g. 1,2,3:\n')
                    re_type_zval_list = re_type_inp_2.split(',')
    
                    z_val_list = re_type_zval_list
    
                if len(z_val_list) < len(element):
                    print('\nYour type-in number < {} element(s)!'.format(len(element)))
    
                    re_type_inp_2 = input('\nPlease re-type, e.g. 1,2,3:\n')
                    re_type_zval_list = re_type_inp_2.split(',')
    
                    z_val_list = re_type_zval_list

            for x_i in need_qX_replace_list:
                basis_set_list[x_i] = f'{basis_set_list[x_i][0:-1]}{int(z_val_list[x_i])}'

            #instantly calculate the total number of electrons
            labels_count_results = Counter(labels)
            count_element_num_list = []
            for e_i in element:
                count_element_num_list.append(labels_count_results[e_i])
                
            total_e_num = sum(np.array(z_val_list).astype(np.int16) * np.array(count_element_num_list).astype(np.int16))
            if total_e_num % 2 == 0:
                type_e_sys = 'EVEN'
            else:
                type_e_sys = 'SINGLE'
                
            print('\n==========================ELECTRON==========================')
            print('Chemical labels:','\t', '\t',element)
            print('Atom numbers:','\t', '\t','\t',count_element_num_list)
            print('Number of valence electrons:','\t', np.array(z_val_list).astype(np.int16))
            print('Total electron number of system:',total_e_num)
            print('Type of electron number of system:',type_e_sys)
            print('==========================END ELECTRON======================\n')

            return basis_set_list   #stores basis set name for each element KIND
            
        elif len(need_qX_replace_list) == 0: 
            return basis_set_list   #stores basis set name for each element KIND            

    
    ##here is basis set admm dictionary
    basis_set_admm_dict = {-5:'admm-1',
                           -4:'admm-2',
                           -3:'admm-3',
                           -2:'admm-dz-qX',
                           -1:'admm-dzp-qX',
                            0:'admm-tzp-qX',
                            1:'admm-tz2p-qX',
                            2:'cFIT3',
                            3:'cpFIT3',
                            4:'aug-FIT3',
                           20:'GTH-def2-QZVP',
                           21:'aug-GTH-def2-QZVP',
                           22:'aug-admm-1',
                           23:'aug-admm-2',
                           24:'aug-admm-3',
                          }
    def basis_set_admm() -> List[str]:
        print('\nAvailable basis sets for admm:\n')
        print(yaml.dump(basis_set_admm_dict, sort_keys = False, default_flow_style = False))
        
        print('\nFind elements from structure:')
        print(element)
        basis_set_admm_indexes_inp = input('\nChoose {} index(es) of admm basis set for each element, e.g. 1,2,3:\n'.format(len(element), len(element)))
        basis_set_admm_indexes_list = basis_set_admm_indexes_inp.strip().split(',')

        while len(basis_set_admm_indexes_list) != len(element):   #to avoid the crash of user's wrong type number!
            if len(basis_set_admm_indexes_list) > len(element):
                print('\nYour type-in number > {} element(s)!'.format(len(element)))

                re_type_inp = input('\nPlease re-type, e.g. 1,2,3:\n')
                re_type_basis_set_indexes_admm_list = re_type_inp.split(',')

                basis_set_admm_indexes_list = re_type_basis_set_indexes_admm_list

            if len(basis_set_admm_indexes_list) < len(element):
                print('\nYour type-in number < {} element(s)!'.format(len(element)))

                re_type_inp = input('\nPlease re-type, e.g. 1,2,3:\n')
                re_type_basis_set_indexes_admm_list = re_type_inp.split(',')

                basis_set_admm_indexes_list = re_type_basis_set_indexes_admm_list
        
        basis_set_admm_list = []
        for x_i in basis_set_admm_indexes_list:
            basis_set_admm_list.append(basis_set_admm_dict[int(x_i)])


        #new function: to replace the 'X' in qX within admm basis set
        #type in the valence electron number
        need_qX_replace_list = []        
        for x_i, bs_i in enumerate(basis_set_admm_list):
            if bs_i[-2:] == 'qX':         #only replace the admm basis set
                need_qX_replace_list.append(x_i)

        if len(need_qX_replace_list) > 0:
            print('\nFind elements from structure:')
            print(element)
            z_val_inp = input('\nPlease type in {} valence electron number(s) for each element within ADMM basis set, e.g., 10,12,14:\n'.format(len(element)))
            z_val_list = z_val_inp.strip().split(',')
    
            while len(z_val_list) != len(element):   #to avoid the crash of user's wrong type number!
                if len(z_val_list) > len(element):
                    print('\nYour type-in number > {} element(s)!'.format(len(element)))
    
                    re_type_inp_2 = input('\nPlease re-type, e.g. 1,2,3:\n')
                    re_type_zval_list = re_type_inp_2.split(',')
    
                    z_val_list = re_type_zval_list
    
                if len(z_val_list) < len(element):
                    print('\nYour type-in number < {} element(s)!'.format(len(element)))
    
                    re_type_inp_2 = input('\nPlease re-type, e.g. 1,2,3:\n')
                    re_type_zval_list = re_type_inp_2.split(',')
    
                    z_val_list = re_type_zval_list

            for x_i in need_qX_replace_list:
                basis_set_admm_list[x_i] = f'{basis_set_admm_list[x_i][0:-1]}{int(z_val_list[x_i])}'

            return basis_set_admm_list   #stores admm basis set name for each element KIND 

        elif len(need_qX_replace_list) == 0:
            return basis_set_admm_list   #stores admm basis set name for each element KIND


    #here is the potential dictionary
    potential_dict = {-2:'GTH-PBE-qX',
                      -1:'GTH-BLYP-qX',
                       0:'GTH-BP-qX',
                       1:'GTH-PADE-qX',
                       2:'GTH-PBESol-q3',   #only for B
                       3:'GTH-OLYP-qX',
                       4:'GTH-HF-qX',
                       5:'GTH-NLCC-PBE-qX',
                       6:'GTH-SCAN-qX',
                       7:'GTH-PBE0-qX',
                      10:'ALL',
                }
    def potential() -> List[str]:
        print('\nAvailable potentials:\n')
        print(yaml.dump(potential_dict, sort_keys = False, default_flow_style = False))
        
        print('\nFind elements from structure:')
        print(element)
        potential_indexes_inp = input('\nChoose {} index(es) of potential for each element, e.g. 1,2,3:\n'.format(len(element), len(element)))
        potential_indexes_list = potential_indexes_inp.strip().split(',')

        while len(potential_indexes_list) != len(element):   #to avoid the crash of user's wrong type number!
            if len(potential_indexes_list) > len(element):
                print('\nYour type-in number > {} element(s)!'.format(len(element)))

                re_type_inp = input('\nPlease re-type, e.g. 1,2,3:\n')
                re_type_potential_indexes_list = re_type_inp.split(',')

                potential_indexes_list = re_type_potential_indexes_list

            if len(potential_indexes_list) < len(element):
                print('\nYour type-in number < {} element(s)!'.format(len(element)))

                re_type_inp = input('\nPlease re-type, e.g. 1,2,3:\n')
                re_type_potential_indexes_list = re_type_inp.split(',')

                potential_indexes_list = re_type_potential_indexes_list
        
        potential_list = []
        for x_i in potential_indexes_list:
            potential_list.append(potential_dict[int(x_i)])


        #new function: to replace the 'X' in qX within GTH PPs
        #type in the valence electron number
        need_qX_replace_list = []
        for x_i, p_i in enumerate(potential_list):
            if p_i[-2:] == 'qX':         #only replace the GTH PPs
                need_qX_replace_list.append(x_i)

        if len(need_qX_replace_list) > 0:
            print('\nFind elements from structure:')
            print(element)
            z_val_inp = input('\nPlease type in {} valence electron number(s) for each element within potential, e.g., 10,12,14:\n'.format(len(element)))
            z_val_list = z_val_inp.strip().split(',')
    
            while len(z_val_list) != len(element):   #to avoid the crash of user's wrong type number!
                if len(z_val_list) > len(element):
                    print('\nYour type-in number > {} element(s)!'.format(len(element)))
    
                    re_type_inp_2 = input('\nPlease re-type, e.g. 1,2,3:\n')
                    re_type_zval_list = re_type_inp_2.split(',')
    
                    z_val_list = re_type_zval_list
    
                if len(z_val_list) < len(element):
                    print('\nYour type-in number < {} element(s)!'.format(len(element)))
    
                    re_type_inp_2 = input('\nPlease re-type, e.g. 1,2,3:\n')
                    re_type_zval_list = re_type_inp_2.split(',')
    
                    z_val_list = re_type_zval_list

            for x_i in need_qX_replace_list:
                potential_list[x_i] = f'{potential_list[x_i][0:-1]}{int(z_val_list[x_i])}'

            return potential_list   #stores admm basis set name for each element KIND 
            
        elif len(need_qX_replace_list) == 0:
            return potential_list   #stores admm basis set name for each element KIND 


    #here is the basis set filename dictionary
    basis_set_filename_dict = {-2:'BASIS_SET',
                               -1:'BASIS_pob',
                                0:'BASIS_MOLOPT_UZH',
                                1:'BASIS_MOLOPT_UCL',
                                2:'BASIS_MOLOPT_LnPP2',
                                3:'BASIS_MOLOPT_LnPP1',
                                4:'BASIS_MOLOPT_AcPP1',
                                5:'BASIS_MOLOPT',
                               10:'BASIS_ccGRB_UZH',
                               20:'pcseg',
                               25:'BASIS_RI_cc-TZ',
                               26:'BASIS_RI_MOLOPT',
                              }
    def basis_set_filename() -> List[str]:
        print('\nAvailable basis set filename:\n')
        print(yaml.dump(basis_set_filename_dict, sort_keys = False, default_flow_style = False))

        bs_filename_list = []
        bs_filename_inp = input('\nChoose the index(es) for your basis set filename(s), e.g. 1,5:\n')
        bs_filename_indexes = bs_filename_inp.strip().split(',')
        
        for x_i in bs_filename_indexes:
            bs_filename_list.append(basis_set_filename_dict[int(x_i)])
            
        return bs_filename_list


    basis_set_admm_filename_dict = {-2:'BASIS_ADMM_UZH',
                                    -1:'BASIS_ADMM_MOLOPT',
                                     0:'BASIS_ADMM_ae',
                                     1:'BASIS_ADMM',
                                    10:'pcseg-admm',
                                   }
    def basis_set_admm_filename() -> List[str]:
        print('\nAvailable basis set admm filename:\n')
        print(yaml.dump(basis_set_admm_filename_dict, sort_keys = False, default_flow_style = False))

        bs_admm_filename_list = []
        bs_admm_filename_inp = input('\nChoose the index(es) for your admm basis set filename(s), e.g. 1,5:\n')
        bs_admm_filename_indexes = bs_admm_filename_inp.strip().split(',')
        
        for x_i in bs_admm_filename_indexes:
            bs_admm_filename_list.append(basis_set_admm_filename_dict[int(x_i)])
            
        return bs_admm_filename_list
        
    potential_filename_dict = {-2:'POTENTIAL_UZH',
                               -1:'POTENTIAL',
                                0:'LnPP1_POTENTIALS',
                                1:'LnPP2_POTENTIALS',
                                2:'HF_POTENTIALS',
                                3:'GTH_POTENTIALS',
                                4:'AcPP1_POTENTIALS',
                                100:'Your definition',
                              }
    def potential_filename() -> str:
        print('\nAvailable potential filename:\n')
        print(yaml.dump(potential_filename_dict, sort_keys = False, default_flow_style = False))
        pot_index = input('\nPlease choose the index for your potential filename, e.g. -1:\n')

        if int(pot_index) == 100:   #choose your definition for potential filename
            pot_filename_self = input('\nPlease type in your definied potential filename or with a path:\n')
            return pot_filename_self
            
        return potential_filename_dict[int(pot_index.strip())]
    '''
    End the basis set and potential
    '''

    ############################################################################################

    '''
    Begin the functionals definition in cp2k
    '''
    pure_functional_dict = {
                           -10:'OLYP',
                            -9:'OLYP-D3(BJ)',
                            -5:'PBEsol',
                            -4:'revPBE',
                            -3:'PBE',
                            -2:'RPBE',
                            -1:'PADE',
                             0:'BEEFVDW-LMKLL',
                             1:'B97_D-D3(0)',
                             6:'SCAN',
                             7:'RSCAN',
                             8:'R2SCAN',
                             9:'SCAN-D3(BJ)',
                            10:'SCAN-RVV10',
                            20:'revTPSS',
                            21:'revTPSS-D3(BJ)',
                            25:'MN15L-D3(0)',
                            26:'MN15L',
                            27:'MN12L',
                            28:'MN12L-D3(BJ)',
                            25:'HLE17',
                            50:'PBE-D3(BJ)',
                            51:'PBE-RVV10',
                            52:'RPBE-D3(BJ)',
                            60:'optB88_vdW-DRSLL',
                            61:'optPBE_vdW-DRSLL',
                            62:'optB86R_vdW-LMKLL',
                            64:'B97M_rV-RVV10',
                         }

    hybrid_functional_dict = {-50:'PBE0',
                              -40:'PBE0-D3(BJ)',
                              -30:'B3LYP',
                              -29:'B3LYP-D3(BJ)',                       
                               20:'M062X',
                               21:'M062X-D3(0)',
                               29:'HSE03',
                               30:'HSE06',
                               40:'WB97X_D-D2',
                               41:'WB97X_D',
                               50:'WB97X',
                               60:'WB97M_V',
                               70:'WB97X_V',
                               80:'CAM_B3LYP',
                               100:'BHANDHLYP',    
                               120:'TPSS0',
                               130:'TPSSh',
                               131:'revTPSSh',
                               132:'revTPSSh-D3(BJ)',
                               141:'TPSSHH',
                               142:'TPSSh-D3(BJ)',
                               143:'TPSS0-D3(BJ)',
                               144:'TPSSh-D3(0)',
                               145:'TPSS0-D3(0)',
                             }


    def parse_xc_functionals_type(type_val:int) -> str:   
        '''
        Classifies the functionals into pure and hybrid types
        type_val = 0: load pure functional dict
        type_val = 1: load hybrid functional dict
        type_val = 2: for function 30:other things, to change functional easily
        '''

        if int(type_val) == 0: 
            print('\nAvailable pure functionals:\n')
            print(yaml.dump(pure_functional_dict, sort_keys = False, default_flow_style = False))

            pure_funct_index = input('\nPlease choose the pure functional, e.g. 50:\n')
            return pure_functional_dict[int(pure_funct_index.strip())]   #this returns the name of functional
            
        if int(type_val) == 1: 
            print('\nAvailable hybrid functionals:\n')
            print(yaml.dump(hybrid_functional_dict, sort_keys = False, default_flow_style = False))

            hybrid_funct_index = input('\nPlease choose the hybrid functional, e.g. 50:\n')
            return hybrid_functional_dict[int(hybrid_funct_index.strip())]   #this returns the name of functional
            
        if int(type_val) == 2:  
            xc_funct_type = {1:'pure functional',
                             2:'hybrid functional',
                            }        
            print('\nAvailable xc functional types:\n')
            print(yaml.dump(xc_funct_type, sort_keys = False, default_flow_style = False))
    
            xc_funct = input('\nPlease choose the type of xc functional, e.g. 1:\n')
    
            if int(xc_funct.strip()) == 1:  #use pure functionals
                print('\nUse pure functionals!\n')
                print('Available pure functionals:\n')
                print(yaml.dump(pure_functional_dict, sort_keys = False, default_flow_style = False))
    
                pure_funct_index = input('\nPlease choose the pure functional, e.g. 50:\n')
                return pure_functional_dict[int(pure_funct_index.strip())]   #this returns the name of functional 
    
            if int(xc_funct.strip()) == 2:  #use hybrid functionals
                print('\nUse hybrid functionals!\n')
                print('Available hybrid functionals:\n')
                print(yaml.dump(hybrid_functional_dict, sort_keys = False, default_flow_style = False))
    
                hybrid_funct_index = input('\nPlease choose the hybrid functional, e.g. 50:\n')
                return hybrid_functional_dict[int(hybrid_funct_index.strip())]   #this returns the name of functional

    
    def xc_functional_pure(functional_name:str) -> cp2k_section:    #this returns &XC to be added in &DFT
        '''
        how to use: xc_functional_pure(functional_name = parse_xc_functionals_type(type_val))
        where type_val = 0;1;2
        '''
        def pure_funct_params(functional_part_name:str) -> cp2k_section:
            if functional_part_name == 'OLYP':
                xc_functional = Section(name = 'XC_FUNCTIONAL', section_parameters = ['OLYP'])
                return xc_functional                
            
            elif functional_part_name == 'PBE':
                pbe_keywords = {'diff_type':Keyword('PARAMETRIZATION','ORIG',
                                                    '\t #REVPBE for revised PBE, PBESOL for solids and surfaces')}
                xc_functional = Section(name = 'XC_FUNCTIONAL', 
                                        subsections = {'xc_name':Section(name = 'PBE',keywords = pbe_keywords)})
                return xc_functional                

            elif functional_part_name == 'revPBE':
                pbe_keywords = {'diff_type':Keyword('PARAMETRIZATION','REVPBE',
                                                    '\t #PBE for original PBE, PBESOL for solids and surfaces')}
                xc_functional = Section(name = 'XC_FUNCTIONAL', 
                                        subsections = {'xc_name':Section(name = 'PBE',keywords = pbe_keywords)})
                return xc_functional

            elif functional_part_name == 'PBEsol':
                pbe_keywords = {'diff_type':Keyword('PARAMETRIZATION','PBESOL',
                                                    '\t #PBE for original PBE, revPBE for revised PBE')}
                xc_functional = Section(name = 'XC_FUNCTIONAL', 
                                        subsections = {'xc_name':Section(name = 'PBE',keywords = pbe_keywords)})
                return xc_functional            
            
            elif functional_part_name == 'RPBE':   #use Hammer and Norskov's RPBE
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'x_name':Section(name = 'GGA_X_RPBE'),
                                                       'c_name':Section(name = 'GGA_C_PBE')})
                return xc_functional
        
            elif functional_part_name == 'SCAN':
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'x_name':Section(name = 'MGGA_X_SCAN'),
                                                       'c_name':Section(name = 'MGGA_C_SCAN')})
                return xc_functional
        
            elif functional_part_name == 'RSCAN':
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'x_name':Section(name = 'MGGA_X_RSCAN'),
                                                       'c_name':Section(name = 'MGGA_C_RSCAN')})
                return xc_functional
        
            elif functional_part_name == 'R2SCAN':
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'x_name':Section(name = 'MGGA_X_R2SCAN'),
                                                       'c_name':Section(name = 'MGGA_C_R2SCAN')})
                return xc_functional
                
            elif functional_part_name == 'revTPSS':
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'x_name':Section(name = 'MGGA_X_REVTPSS'),
                                                       'c_name':Section(name = 'MGGA_C_REVTPSS')})
                return xc_functional
    
            elif functional_part_name == 'MN15L':  #use DFT-D3(0) for vdw correction
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'x_name':Section(name = 'MGGA_X_MN15_L'),
                                                       'c_name':Section(name = 'MGGA_C_MN15_L')})
                return xc_functional
    
            elif functional_part_name == 'MN12L':  #use DFT-D3(BJ) for vdw correction
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'x_name':Section(name = 'MGGA_X_MN12_L'),
                                                       'c_name':Section(name = 'MGGA_C_MN12_L')})
                return xc_functional        

            elif functional_part_name == 'BEEFVDW':  #use DFT-D3(BJ) for vdw correction
                print('\nBEEFVDW chooses LMKLL non-local vdw!\n')
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'xc_name':Section(name = 'GGA_XC_BEEFVDW',
                                                                        section_parameters = ['#BEEFVDW   #if not use libxc, uncomment this tag'])})
                return xc_functional            
                
            elif functional_part_name == 'B97M_rV': #use RVV10, but not the default of RVV10 parameters
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'xc_name':Section(name = 'MGGA_XC_B97M_V')})
                return xc_functional  

            elif functional_part_name == 'HLE17': #use RVV10, but not the default of RVV10 parameters
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'xc_name':Section(name = 'MGGA_XC_HLE17')})
                return xc_functional            
            
            elif functional_part_name == 'optB88_vdW':  #use DRSLL for vdw correction
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'x_name':Section(name = 'GGA_X_OPTB88_VDW'),
                                                       'c_name':Section(name = 'PW92')})
                return xc_functional            
    
            elif functional_part_name == 'optPBE_vdW':  #use DRSLL for vdw correction
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'x_name':Section(name = 'GGA_X_OPTPBE_VDW'),
                                                       'c_name':Section(name = 'PW92')})
                return xc_functional
    
            elif functional_part_name == 'optB86R_vdW':  #use LMKLL for vdw correction
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'x_name':Section(name = 'GGA_X_B86_R'),
                                                       'c_name':Section(name = 'PW92')})
                return xc_functional

            elif functional_part_name == 'B97_D':  #use LMKLL for vdw correction
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'xc_name':Section(name = 'GGA_XC_B97_D')})
                return xc_functional        

        #parse the functional_name
        if '-' in functional_name:
            functional_part_name = functional_name.split('-')[0]
            vdw_part_name = functional_name.split('-')[1]

            if vdw_part_name == 'D2':   #use D2
                xc_subs = {}
                xc_subs['xc_functional'] = pure_funct_params(functional_part_name)
                xc_subs['vdw_potential'] = vdw_pair_potential('D2',functional_part_name)
                XC = Section(name = 'XC', subsections = xc_subs)
                
                return XC                
            elif vdw_part_name == 'D3(BJ)': #use BJ damping
                xc_subs = {}
                xc_subs['xc_functional'] = pure_funct_params(functional_part_name)
                xc_subs['vdw_potential'] = vdw_pair_potential('D3(BJ)',functional_part_name)
                XC = Section(name = 'XC', subsections = xc_subs)
                
                return XC

            elif vdw_part_name == 'D3(0)': #use zero damping
                xc_subs = {}
                xc_subs['xc_functional'] = pure_funct_params(functional_part_name)
                xc_subs['vdw_potential'] = vdw_pair_potential('D3(0)',functional_part_name)
                XC = Section(name = 'XC', subsections = xc_subs)
                
                return XC                

            elif vdw_part_name == 'RVV10': #use non_local
                xc_subs = {}
                xc_subs['xc_functional'] = pure_funct_params(functional_part_name)
                xc_subs['vdw_potential'] = vdw_non_local('RVV10')
                XC = Section(name = 'XC', subsections = xc_subs)
                
                return XC                
                

            elif vdw_part_name == 'LMKLL': #use non_local
                xc_subs = {}
                xc_subs['xc_functional'] = pure_funct_params(functional_part_name)
                xc_subs['vdw_potential'] = vdw_non_local('LMKLL')
                XC = Section(name = 'XC', subsections = xc_subs) 

                return XC

            elif vdw_part_name == 'DRSLL': #use non_local
                xc_subs = {}
                xc_subs['xc_functional'] = pure_funct_params(functional_part_name)
                xc_subs['vdw_potential'] = vdw_non_local('DRSLL')
                XC = Section(name = 'XC', subsections = xc_subs) 

                return XC
                   
        else:
            functional_part_name = functional_name
            xc_subs = {}
            xc_subs['xc_functional'] = pure_funct_params(functional_part_name)
            XC = Section(name = 'XC', subsections = xc_subs)    
            
            return XC

    def xc_functional_hybrid(functional_name:str,use_RI:str) -> cp2k_section:    #this returns &XC to be added in &DFT
        '''
        how to use: xc_functional_hybrid(functional_name = parse_xc_functionals_type(type_val), use_RI)
        where type_val = 0;1;2
        use_RI = 'y' or 'n'
        '''
        #use_RI = use_RI
        def hybrid_funct_params(functional_part_name):
            if functional_part_name == 'PBE0':
                pbe_keywords = {'scale_x':Keyword('SCALE_X',0.75), 
                                'scale_c':Keyword('SCALE_C',1.0)}
                xc_functional = Section(name = 'XC_FUNCTIONAL', 
                                        subsections = {'xc_name':Section(name = 'PBE',keywords = pbe_keywords)})
                return xc_functional

            if functional_part_name == 'M062X':
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'x_name':Section(name = 'HYB_MGGA_X_M06-2X'),
                                                       'c_name':Section(name = 'MGGA_C_M06_2X')})
                return xc_functional

            if functional_part_name == 'B3LYP':
                xc_funct_subs = {}
                xc_funct_subs['becke88'] = Section(name = 'BECKE88', 
                                                   keywords = {'scale_x':Keyword('SCALE_X',0.72)})
                xc_funct_subs['lyp'] = Section(name = 'LYP', 
                                               keywords = {'scale_c':Keyword('SCALE_C',0.81)})
                xc_funct_subs['vwn'] = Section(name = 'VWN', 
                                               keywords = {'scale_c':Keyword('SCALE_C',0.19), 
                                                           'type':Keyword('FUNCTIONAL_TYPE','VWN3')})
                xc_funct_subs['xalpha'] = Section(name = 'XALPHA', 
                                                  keywords = {'scale_x':Keyword('SCALE_X',0.08)})
                xc_functional = Section(name = 'XC_FUNCTIONAL',subsections = xc_funct_subs)
                return xc_functional

            if functional_part_name == 'HSE03':
                xc_funct_subs = {}
                xc_funct_subs['pbe'] = Section(name = 'PBE', 
                                                   keywords = {'scale_c':Keyword('SCALE_C',1.0),
                                                               'scale_x':Keyword('SCALE_X',0.0)
                                                              })
                xc_funct_subs['xwpbe'] = Section(name = 'XWPBE', 
                                               keywords = {'scale_x':Keyword('SCALE_X',-0.25),
                                                           'scale_x0':Keyword('SCALE_X0',1.0),
                                                           'omega':Keyword('OMEGA',0.189,'\t #value is 0.15*2^(1/3)')
                                                          })
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        keywords = {'begin':Keyword('#&HYB_GGA_XC_HSE03'),
                                                    'end':Keyword('#&END HYB_GGA_XC_HSE03')
                                                   },
                                        subsections = xc_funct_subs)
                return xc_functional      

            if functional_part_name == 'HSE06':
                xc_funct_subs = {}
                xc_funct_subs['pbe'] = Section(name = 'PBE', 
                                                   keywords = {'scale_c':Keyword('SCALE_C',1.0),
                                                               'scale_x':Keyword('SCALE_X',0.0)
                                                              })
                xc_funct_subs['xwpbe'] = Section(name = 'XWPBE', 
                                               keywords = {'scale_x':Keyword('SCALE_X',-0.25),
                                                           'scale_x0':Keyword('SCALE_X0',1.0),
                                                           'omega':Keyword('OMEGA',0.11)
                                                          })
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        keywords = {'begin':Keyword('#&HYB_GGA_XC_HSE06'),
                                                    'end':Keyword('#&END HYB_GGA_XC_HSE06')
                                                   },
                                        subsections = xc_funct_subs)
                return xc_functional 

            if functional_part_name == 'TPSS0':
                xc_funct_subs = {}
                xc_funct_subs['mgga_x_tpss0'] = Section(name = 'MGGA_X_TPSS', keywords = {'scale_x':Keyword('SCALE',0.75)})
                xc_funct_subs['mgga_c_tpss0'] = Section(name = 'MGGA_C_TPSS', keywords = {'scale_c':Keyword('SCALE',1.0)})
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = xc_funct_subs,
                                        keywords = {'begin':Keyword('&HYB_MGGA_XC_TPSS0'),
                                                    'end':Keyword('&END HYB_MGGA_XC_TPSS0')
                                                   },
                                       )
                return xc_functional

            if functional_part_name == 'TPSSh':
                xc_funct_subs = {}
                xc_funct_subs['mgga_x_tpssh'] = Section(name = 'MGGA_X_TPSS', keywords = {'scale_x':Keyword('SCALE',0.9)})
                xc_funct_subs['mgga_c_tpssh'] = Section(name = 'MGGA_C_TPSS', keywords = {'scale_c':Keyword('SCALE',1.0)})
                
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = xc_funct_subs,
                                        keywords = {'begin':Keyword('#&HYB_MGGA_XC_TPSSH'),
                                                    'end':Keyword('#&END HYB_MGGA_XC_TPSSH')
                                                   },
                                       )
                return xc_functional

            if functional_part_name == 'revTPSSh':
                xc_funct_subs = {}
                xc_funct_subs['mgga_x_revtpssh'] = Section(name = 'MGGA_X_REVTPSS', keywords = {'scale_x':Keyword('SCALE',0.9)})
                xc_funct_subs['mgga_c_revtpssh'] = Section(name = 'MGGA_C_REVTPSS', keywords = {'scale_c':Keyword('SCALE',1.0)})
                
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = xc_funct_subs,
                                        keywords = {'begin':Keyword('#&HYB_MGGA_XC_REVTPSSH'),
                                                    'end':Keyword('#&END HYB_MGGA_XC_REVTPSSH')
                                                   },
                                       )

                return xc_functional

            
            if functional_part_name == 'TPSSHH':
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'x_name':Section(name = 'MGGA_X_TPSS', 
                                                                        keywords = {'SCALE':Keywords('SCALE',0.5)}
                                                                       ),
                                                       'c_name':Section(name = 'MGGA_C_TPSS', 
                                                                        keywords = {'SCALE':Keyword('SCALE',1.0)}
                                                                       )
                                                      }
                                       )
                return xc_functional        

            if functional_part_name == 'CAM_B3LYP':  
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'xc_name':Section(name = 'HYB_GGA_XC_CAM_B3LYP')}
                                       )
                return xc_functional    
                
            if functional_part_name == 'WB97X_D':  
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'xc_name':Section(name = 'HYB_GGA_XC_WB97X_D')}
                                       )
                return xc_functional
                
            if functional_part_name == 'WB97X':  
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'xc_name':Section(name = 'HYB_GGA_XC_WB97X')}
                                       )
                return xc_functional

            if functional_part_name == 'WB97M_V':  
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'xc_name':Section(name = 'HYB_MGGA_XC_WB97M_V')}
                                       )
                return xc_functional

            if functional_part_name == 'WB97X_V':  
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'xc_name':Section(name = 'HYB_GGA_XC_WB97X_V')}
                                       )
                return xc_functional        

            elif functional_part_name == 'BHANDHLYP':
                xc_functional = Section(name = 'XC_FUNCTIONAL',
                                        subsections = {'xc_name':Section(name = 'HYB_GGA_XC_BHANDHLYP')}
                                       )
                return xc_functional

        
        def hybrid_hf_params(functional_part_name:str,use_RI:str) -> cp2k_section:
            if functional_part_name == 'PBE0':
                frac_val = 0.25
                potential_type = 'TRUNCATED'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING', 
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'), 
                                                           'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL', 
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE',potential_type), 
                                                           'cutoff_radius':Keyword('CUTOFF_RADIUS',6.0)})
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY',3000), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING',0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf                
                
            if functional_part_name == 'M062X':
                frac_val = 0.54
                potential_type = 'TRUNCATED'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING', 
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'), 
                                                           'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL', 
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE',potential_type), 
                                                           'cutoff_radius':Keyword('CUTOFF_RADIUS',6.0)})
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY',3000), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING',0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf

            if functional_part_name == 'B3LYP':
                frac_val = 0.2
                potential_type = 'TRUNCATED'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING', 
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'), 
                                                           'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL', 
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE',potential_type), 
                                                           'cutoff_radius':Keyword('CUTOFF_RADIUS',6.0)})
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY',3000), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING',0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf

            if functional_part_name == 'HSE03':
                frac_val = 0.25
                omega = 0.106
                potential_type = 'SHORTRANGE'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING',
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'),
                                                          'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL',
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE',potential_type),
                                                                              'omega':Keyword('OMEGA',omega, '\t #value is 0.15/sqrt(2)')})
        
                
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY',6000,'\t# memory MB per MPI process'), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING',0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf        

            if functional_part_name == 'HSE06':
                frac_val = 0.25
                omega = 0.11
                potential_type = 'SHORTRANGE'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING',
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'),
                                                          'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL',
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE',potential_type),
                                                                              'omega':Keyword('OMEGA',omega)})
        
                
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY',6000,'\t# memory MB per MPI process'), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING',0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf

            if functional_part_name == 'TPSS0':
                frac_val = 0.25
                potential_type = 'TRUNCATED'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING', 
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'), 
                                                           'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL', 
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE', potential_type), 
                                                           'cutoff_radius':Keyword('CUTOFF_RADIUS',6.0)})
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY',3000), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING',0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf

            if functional_part_name == 'TPSSh':        
                frac_val = 0.1
                potential_type = 'TRUNCATED'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING', 
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'), 
                                                           'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL', 
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE', potential_type), 
                                                           'cutoff_radius':Keyword('CUTOFF_RADIUS', 6.0)})
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY', 3000), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING', 0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf

            if functional_part_name == 'revTPSSh':        
                frac_val = 0.1
                potential_type = 'TRUNCATED'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING', 
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'), 
                                                           'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL', 
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE', potential_type), 
                                                           'cutoff_radius':Keyword('CUTOFF_RADIUS', 6.0)})
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY', 3000), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING', 0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
            
            if functional_part_name == 'TPSSHH': 
                frac_val = 0.5
                potential_type = 'TRUNCATED'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING', 
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'), 
                                                           'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL', 
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE', potential_type), 
                                                           'cutoff_radius':Keyword('CUTOFF_RADIUS', 6.0)})
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY', 3000), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING', 0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf

            if functional_part_name == 'CAM_B3LYP':
                frac_val = 1.0
                omega = 0.33
                potential_type = 'MIX_CL_TRUNC'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING', 
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'), 
                                                           'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL',
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE',potential_type), 
                                                           'SCALE_COULOMB':Keyword('SCALE_COULOMB',0.46), 
                                                           'SCALE_LONGRANGE':Keyword('SCALE_LONGRANGE',0.19), 
                                                           'omega':Keyword('OMEGA',omega), 
                                                           'cutoff_radius':Keyword('CUTOFF_RADIUS',6.0)})
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY',6000,'\t #memory MB per MPI process'), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING',0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf

            if functional_part_name == 'WB97X':        
                frac_val = 1.0
                omega = 0.3
                potential_type = 'MIX_CL_TRUNC'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING', 
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'), 
                                                           'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL', 
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE',potential_type), 
                                                           'SCALE_COULOMB':Keyword('SCALE_COULOMB',0.157706), 
                                                           'SCALE_LONGRANGE':Keyword('SCALE_LONGRANGE',0.842294), 
                                                           'omega':Keyword('OMEGA',omega), 
                                                           'cutoff_radius':Keyword('CUTOFF_RADIUS',6.0)})
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY',6000,'\t# memory MB per MPI process'), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING',0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf

            if functional_part_name == 'WB97X_D':
                frac_val = 1.0
                omega = 0.2
                potential_type = 'MIX_CL_TRUNC'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING',
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'), 
                                                           'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL',
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE',potential_type), 
                                                           'SCALE_COULOMB':Keyword('SCALE_COULOMB',0.222036), 
                                                           'SCALE_LONGRANGE':Keyword('SCALE_LONGRANGE',0.777964), 
                                                           'omega':Keyword('OMEGA',omega), 
                                                           'cutoff_radius':Keyword('CUTOFF_RADIUS',6.0)})
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY',6000,'\t #memory MB per MPI process'), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING',0.1)})                
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf    

            if functional_part_name == 'WB97M_V':
                frac_val = 1.0
                omega = 0.3
                potential_type = 'MIX_CL_TRUNC'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING', 
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'), 
                                                           'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL',
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE',potential_type), 
                                                           'SCALE_COULOMB':Keyword('SCALE_COULOMB',0.15), 
                                                           'SCALE_LONGRANGE':Keyword('SCALE_LONGRANGE',0.85), 
                                                           'omega':Keyword('OMEGA',omega), 
                                                           'cutoff_radius':Keyword('CUTOFF_RADIUS',6.0)})
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY',6000,'\t #memory MB per MPI process'), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING',0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf 

            if functional_part_name == 'WB97X_V':
                frac_val = 1.0
                omega = 0.3
                potential_type = 'MIX_CL_TRUNC'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING', 
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'), 
                                                           'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL',
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE',potential_type), 
                                                           'SCALE_COULOMB':Keyword('SCALE_COULOMB',0.167), 
                                                           'SCALE_LONGRANGE':Keyword('SCALE_LONGRANGE',0.833), 
                                                           'omega':Keyword('OMEGA',omega), 
                                                           'cutoff_radius':Keyword('CUTOFF_RADIUS',6.0)})
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY',6000,'\t #memory MB per MPI process'), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING',0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf    

            if functional_part_name == 'BHANDHLYP':   #is BHANDLYP
                frac_val = 0.5
                potential_type = 'TRUNCATED'
                hf_subs = {}
                hf_subs['screening'] = Section(name = 'SCREENING', 
                                               keywords = {'schwarz':Keyword('EPS_SCHWARZ','1E-06'), 
                                                           'screen_on_ini_p':Keyword('SCREEN_ON_INITIAL_P','T')})
                hf_subs['inter_pot'] = Section(name = 'INTERACTION_POTENTIAL', 
                                               keywords = {'pot_type':Keyword('POTENTIAL_TYPE',potential_type), 
                                                           'cutoff_radius':Keyword('CUTOFF_RADIUS',6.0)})
                hf_subs['memory'] = Section(name = 'MEMORY', 
                                            keywords = {'max_memo':Keyword('MAX_MEMORY',3000), 
                                                        'eps_storage_scale':Keyword('EPS_STORAGE_SCALING',0.1)})
                if use_RI == 'y':
                    hf_subs['RI'] = hf_RI()
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
    
                if use_RI == 'n':
                    xc_hf = Section(name = 'HF',keywords = {'hf_fraction':Keyword('FRACTION',frac_val)},subsections = hf_subs)
                    return xc_hf
                    
        
        def hf_RI() -> cp2k_section:
            hf_RI = Section(name = 'RI', 
                            section_parameters = ['T'], 
                            keywords = {'kp_nroups':Keyword('KP_NGROUPS',12,'\t# acoording to your parallel number, need correction'), 
                                        'RI_METRIX':Keyword('RI_METRIX','HFX','\t# HFX-default-same with INTERACTION_POTENTIAL'), 
                                        'cutoff_radius':Keyword('#CUTOFF_RADIUS','6.0','\t# when using TRUNCATED, can be different with in INTERACTION_POTENTIAL'), 
                                        'kp_use_delta_P':Keyword('KP_USE_DELTA_P','T','\t#default, set F for difficult convergence in SCF'),
                                        'eps_pgf_orb':Keyword('EPS_PGF_ORB','1E-5','\t #precision of the integral tensors, better match with that in &QS'),
                                        })
            return hf_RI

                
        if '-' in functional_name:
            functional_part_name = functional_name.split('-')[0]
            vdw_part_name = functional_name.split('-')[1]
            
            if vdw_part_name == 'D2': #use D2 method
                xc_subs = {}
                xc_subs['xc_functional'] = hybrid_funct_params(functional_part_name)
                xc_subs['hf'] = hybrid_hf_params(functional_part_name,use_RI)
                xc_subs['vdw_potential'] = vdw_pair_potential('D2',functional_part_name)
                XC = Section(name = 'XC', subsections = xc_subs)
                
                return XC
            
            elif vdw_part_name == 'D3(BJ)': #use BJ damping
                xc_subs = {}
                xc_subs['xc_functional'] = hybrid_funct_params(functional_part_name)
                xc_subs['hf'] = hybrid_hf_params(functional_part_name,use_RI)
                xc_subs['vdw_potential'] = vdw_pair_potential('D3(BJ)',functional_part_name)
                XC = Section(name = 'XC', subsections = xc_subs)
                
                return XC

            elif vdw_part_name == 'D3(0)': #use zero damping
                xc_subs = {}
                xc_subs['xc_functional'] = hybrid_funct_params(functional_part_name)
                xc_subs['hf'] = hybrid_hf_params(functional_part_name,use_RI)
                xc_subs['vdw_potential'] = vdw_pair_potential('D3(0)',functional_part_name)
                XC = Section(name = 'XC', subsections = xc_subs)
                
                return XC                

            elif vdw_part_name == 'RVV10': #use non_local
                xc_subs = {}
                xc_subs['xc_functional'] = hybrid_funct_params(functional_part_name)
                xc_subs['hf'] = hybrid_hf_params(functional_part_name,use_RI)                
                xc_subs['vdw_potential'] = vdw_non_local('RVV10')
                XC = Section(name = 'XC', subsections = xc_subs)
                
                return XC                
                

            elif vdw_part_name == 'LMKLL': #use non_local
                xc_subs = {}
                xc_subs['xc_functional'] = hybrid_funct_params(functional_part_name)
                xc_subs['hf'] = hybrid_hf_params(functional_part_name,use_RI)                
                xc_subs['vdw_potential'] = vdw_non_local('LMKLL')
                XC = Section(name = 'XC', subsections = xc_subs) 

                return XC

            elif vdw_part_name == 'DRSLL': #use non_local
                xc_subs = {}
                xc_subs['xc_functional'] = hybrid_funct_params(functional_part_name)
                xc_subs['hf'] = hybrid_hf_params(functional_part_name,use_RI)                
                xc_subs['vdw_potential'] = vdw_non_local('DRSLL')
                XC = Section(name = 'XC', subsections = xc_subs) 

                return XC
                   
        else: #no vdw correction
            functional_part_name = functional_name
            xc_subs = {}
            xc_subs['xc_functional'] = hybrid_funct_params(functional_part_name)
            xc_subs['hf'] = hybrid_hf_params(functional_part_name,use_RI)            
            XC = Section(name = 'XC', subsections = xc_subs)    
            
            return XC
            
    
    '''
    End the functionals definition in cp2k
    '''
    
    ############################################################################################
    
    '''
    Begin the vdw definition
    '''
    def vdw_pair_potential(pot_type:str,funct_name:str) -> cp2k_section:
        if str(pot_type) == 'D2':
            pair_potential = {}
            pair_potential['pair_pot'] = Section(name = 'PAIR_POTENTIAL',
                             keywords = {'reference_functional':Keyword('REFERENCE_FUNCTIONAL',funct_name),
                                         'type':Keyword('TYPE','DFTD2','\t #DFTD3(BJ) with BJ damping, others:DFTD2-Grimme, DFTD3-Grimme-zero-damping'),
                                        }
                                                )
            vdw_potential = Section(name = 'VDW_POTENTIAL',
                                    keywords = {'potential type':Keyword('POTENTIAL_TYPE','PAIR_POTENTIAL')},
                                    subsections = pair_potential  #pair potential or non local
                                   )
            return vdw_potential
        
        elif str(pot_type) == 'D3(BJ)':
            pair_potential = {}
            pair_potential['pair_pot'] = Section(name = 'PAIR_POTENTIAL',
                             keywords = {'param_file_name':Keyword('PARAMETER_FILE_NAME','dftd3.dat'),
                                         'type':Keyword('TYPE','DFTD3(BJ)','\t #DFTD3(BJ) with BJ damping, others:DFTD2-Grimme, DFTD3-Grimme-zero-damping'),
                                         'd3bj_scaling':Keyword('#D3BJ_SCALING',1.0,1.0,1.0,1.0,'\t s6,a1,s8,a2 for D3(BJ),if zero, guess from reference functional'),
                                         'reference_functional':Keyword('REFERENCE_FUNCTIONAL',funct_name,'\t #not set for XTB'),
                                         'calculate C9 term':Keyword('CALCULATE_C9_TERM','F')
                                        }
                                                )
            vdw_potential = Section(name = 'VDW_POTENTIAL',
                                    keywords = {'potential type':Keyword('POTENTIAL_TYPE','PAIR_POTENTIAL')},
                                    subsections = pair_potential  #pair potential or non local
                                   )
            return vdw_potential
    
        elif str(pot_type) == 'D3(0)':
            pair_potential = {}
            pair_potential['pair_pot'] = Section(name = 'PAIR_POTENTIAL',
                             keywords = {'param_file_name':Keyword('PARAMETER_FILE_NAME','dftd3.dat'),
                                         'type':Keyword('TYPE','DFTD3','\t #DFTD3(BJ) with BJ damping, others:DFTD2-Grimme, DFTD3-Grimme-zero-damping'),
                                         'd3_scaling':Keyword('#D3_SCALING',1.0,1.0,1.0,'\t #s6,sr6,s8 for D3(0),if zero, guess from reference functional'),
                                         'reference_functional':Keyword('REFERENCE_FUNCTIONAL',funct_name,'\t #not set for XTB'),
                                         'calculate C9 term':Keyword('CALCULATE_C9_TERM','F')
                                        }
                                                )
            vdw_potential = Section(name = 'VDW_POTENTIAL',
                                    keywords = {'potential type':Keyword('POTENTIAL_TYPE','PAIR_POTENTIAL')},
                                    subsections = pair_potential  #pair potential or non local
                                   )
            return vdw_potential        

    def vdw_non_local(non_local_type:str) -> cp2k_section:
        if non_local_type == 'RVV10':
            kernel_filename = 'rVV10_kernel_table.dat'
            
            print('\nPlease choose the functional for loading b and C paramaters within RVV10:\n')

            functional_rvv10_dict = {-1:'default values of b and C',    #6.3, 0.0093-the defined params for RVV10
                                      2:'B97M_rV',   #6.0, 0.01
                                      3:'WB97M_V',   #6.0, 0.01
                                      4:'WB97X_V',   #6.0, 0.01
                                    }

            print('Available functionals with RVV10:\n')
            print(yaml.dump(functional_rvv10_dict, sort_keys = False, default_flow_style = False))

            type_idx = input('\nPlease choose the functional type for RVV10:\n')
            if int(type_idx.strip()) == -1: #default RVV10
                b_val = 6.3
                C_val = 0.0093                
                
            elif int(type_idx.strip()) == 2:  #B97M_rV
                b_val = 6.0
                C_val = 0.01 
            
            elif int(type_idx.strip()) == 3:  #WB97M_V
                b_val = 6.0
                C_val = 0.01

            elif int(type_idx.strip()) == 4:  #WB97X_V
                b_val = 6.0
                C_val = 0.01
            
            non_local = Section(name = 'NON_LOCAL',
                                keywords = {'type':Keyword('TYPE',str(non_local_type),'\t #LMKLL, DRSLL, RVV10'),
                                            'kernel_filename':Keyword('KERNEL_FILE_NAME',kernel_filename),
                                            'parameters':Keyword('PARAMETERS',b_val,C_val,'\t #b and C parameters for RVV10, NEED to change for specific functionals')
                                           }
                               )
            vdw_potential_subs = {}
            vdw_potential_subs['non_local'] = non_local
            vdw_potential = Section(name = 'VDW_POTENTIAL',
                                    keywords = {'potential type':Keyword('POTENTIAL_TYPE','NON_LOCAL')},
                                    subsections = vdw_potential_subs  #pair potential or non local
                                    )
            return vdw_potential
            
        if non_local_type == 'LMKLL': 
            kernel_filename = 'vdW_kernel_table.dat'
            non_local = Section(name = 'NON_LOCAL',
                                keywords = {'type':Keyword('TYPE',str(non_local_type),'\t #LMKLL, DRSLL, RVV10'),
                                            'kernel_filename':Keyword('KERNEL_FILE_NAME',kernel_filename)
                                           }
                               )
            vdw_potential_subs = {}
            vdw_potential_subs['non_local'] = non_local
            vdw_potential = Section(name = 'VDW_POTENTIAL',
                                    keywords = {'potential type':Keyword('POTENTIAL_TYPE','NON_LOCAL')},
                                    subsections = vdw_potential_subs  #pair potential or non local
                                    )
            return vdw_potential

        
        if non_local_type == 'DRSLL': 
            kernel_filename = 'vdW_kernel_table.dat'
            non_local = Section(name = 'NON_LOCAL',
                                keywords = {'type':Keyword('TYPE',str(non_local_type),'\t #LMKLL, DRSLL, RVV10'),
                                            'kernel_filename':Keyword('KERNEL_FILE_NAME',kernel_filename)
                                           }
                               )
            vdw_potential_subs = {}
            vdw_potential_subs['non_local'] = non_local
            vdw_potential = Section(name = 'VDW_POTENTIAL',
                                    keywords = {'potential type':Keyword('POTENTIAL_TYPE','NON_LOCAL')},
                                    subsections = vdw_potential_subs  #pair potential or non local
                                    )
            return vdw_potential
            
    '''
    End the vdw definition
    '''
    
    #########################################################################################################

    '''
    Begin the definition for &MOTION
    '''
    def motion_cell_opt(algo:str, opt_type:str) -> Dict[str,cp2k_section]:
        if algo == 'BFGS':
            cell_opt_subs = {}
            cell_opt_subs['BGFS'] = Section(name = 'BFGS',
                                           keywords = {'trust_radius':Keyword('#TRUST_RADIUS',0.2,'\t #previous set to 0.1, large value-instabilities'),
                                                       'restart_hessian':Keyword('#RESTART_HESSIAN','T','\t #if use initial Hessian, uncomment this line'),
                                                       'restart_file_name':Keyword('#RESTART_FILE_NAME','to_be_specified', '\t #if use initial Hessian, uncomment this line')
                                                      }
                                           )
        
        elif algo == 'LBFGS':
            cell_opt_subs = {}
            cell_opt_subs['LBGFS'] = Section(name = 'LBFGS',
                                           keywords = { 
                                                       'max_f_per_iter': Keyword('#MAX_F_PER_ITER',20,'\t #default'), 
                                                       'max_h_rank': Keyword('#MAX_H_RANK',8, '\t #default-5, larger value for fast converg, but larger memory'),
                                                       'remind':Keyword('#if LBFGS not ideal for convergence, try BFGS or change the following two tags'),
                                                       'wanted_proj_gradient': Keyword('#WANTED_PROJ_GRADIENT','1E-18','\t #default is 1E-16'),
                                                       'wanted_rel_F_error':Keyword('#WANTED_REL_F_ERROR','1E-18','#default is 1E-16')
                                                      }
                                           )
        elif algo == 'CG':
            cell_opt_subs = {}
            cell_opt_subs['CG'] = Section(name = 'CG', 
                                         subsections = {'line_search': Section(name = 'LINE_SEARCH', 
                                                                               keywords = {'type': Keyword('TYPE','2PNT')})})


        #now choose the accuracy for cell opt
        converg_levels_dict = {1:'very loose',
                               2:'loose',
                               3:'medium',
                               4:'default',
                               5:'tight',
                               6:'very tight',
                               7:'reg_test',
                              }

        
        print('\nAvailable different convergence levels for CELL_OPT:\n')
        print(yaml.dump(converg_levels_dict, sort_keys = False, default_flow_style = False))
        convg_index = input('\nPlease choose the convergence level for CELL_OPT:\n')
        if int(convg_index.strip()) == 1:     #very loose
            print('\nYour choice convergence level for GEO_OPT: very loose!\n')
            max_dr_val = '1E-1'    #unit: Bohr
            rms_dr_val = '5E-2'  #unit: Bohr
            max_force_val = '4.5E-2' #unit: Ha/Bohr
            rms_force_val = '1.5E-2'  #unit: Ha/Bohr

        elif int(convg_index.strip()) == 2:
            print('\nYour choice convergence level for GEO_OPT: loose!\n')
            max_dr_val = '1E-2'         #unit: Bohr
            rms_dr_val = '5E-3'       #unit: Bohr
            max_force_val = '4.5E-2'    #unit: Ha/Bohr
            rms_force_val = '1.5E-3'    #unit: Ha/Bohr

        elif int(convg_index.strip()) == 3:
            print('\nYour choice convergence level for GEO_OPT: medium!\n')
            max_dr_val = '3E-2'         #unit: Bohr
            rms_dr_val = '1.5E-3'       #unit: Bohr
            max_force_val = '6E-4'    #unit: Ha/Bohr
            rms_force_val = '3E-4'    #unit: Ha/Bohr

        elif int(convg_index.strip()) == 4:
            print('\nYour choice convergence level for GEO_OPT: default!\n')
            max_dr_val = '3E-3'         #unit: Bohr
            rms_dr_val = '1.5E-3'       #unit: Bohr
            max_force_val = '4.5E-4'    #unit: Ha/Bohr
            rms_force_val = '3E-4'    #unit: Ha/Bohr

        elif int(convg_index.strip()) == 5:
            print('\nYour choice convergence level for GEO_OPT: tight!\n')
            max_dr_val = '6E-5'         #unit: Bohr
            rms_dr_val = '3E-5'       #unit: Bohr
            max_force_val = '1.5E-5'    #unit: Ha/Bohr
            rms_force_val = '5E-6'    #unit: Ha/Bohr

        elif int(convg_index.strip()) == 6:
            print('\nYour choice convergence level for GEO_OPT: very tight!\n')
            max_dr_val = '6E-6'         #unit: Bohr
            rms_dr_val = '3E-6'       #unit: Bohr
            max_force_val = '1.5E-6'    #unit: Ha/Bohr
            rms_force_val = '5E-7'    #unit: Ha/Bohr

        elif int(convg_index.strip()) == 7:
            print('\nYour choice convergence level for GEO_OPT: reg_test!\n')
            max_dr_val = '1E-3'         #unit: Bohr
            rms_dr_val = '1E-3'       #unit: Bohr
            max_force_val = '1E-3'    #unit: Ha/Bohr
            rms_force_val = '1E-3'    #unit: Ha/Bohr


        
        CELL_OPT = Section(name = 'CELL_OPT',
                          keywords = {'max_iter':Keyword('MAX_ITER',150),
                                      'max_dr':Keyword('MAX_DR',max_dr_val),
                                      'rms_dr':Keyword('RMS_DR',rms_dr_val),
                                      'max_force':Keyword('MAX_FORCE',max_force_val,'\t #<1E-04, 1E-05 for vibration'),
                                      'rms_force':Keyword('RMS_FORCE',rms_force_val),
                                      'external_pressure':Keyword('EXTERNAL_PRESSURE','1.01325','\t #unit: bar'),
                                      'constraint':Keyword('CONSTRAINT','NONE','\t #fix cell directions'),
                                      'keep_angles':Keyword('KEEP_ANGLES','F'),
                                      'keep_symmetry':Keyword('KEEP_SYMMETRY','F'),
                                      'keep_space_group':Keyword('KEEP_SPACE_GROUP','F'),
                                      'type':Keyword('TYPE',opt_type,'\t #default-DIRECT_CELL_OPT, both cell and structure opted at the same time'),
                                      'remember': Keyword('#when using TYPE GEO_OPT, CELL_OPT, BAROSTAT(MD), switch on STRESS_TENSOR ANALYTIC'),
                                      'pressure_tolerance':Keyword('PRESSURE_TOLERANCE',100,'\t #default, bar'),
                                      'optimizer':Keyword('OPTIMIZER',algo,'\t #also LBFGS, CG'),
     
                                     },
                          subsections = cell_opt_subs
                          )
        return CELL_OPT
    
    def motion_geo_opt(algo:str) -> Dict[str,cp2k_section]:
        if algo == 'BFGS':
            geo_opt_subs = {}
            geo_opt_subs['BGFS'] = Section(name = 'BFGS',
                                           keywords = {'trust_radius':Keyword('#TRUST_RADIUS',0.2,'\t #previous set 0.1, large values-instabilities'),
                                                       'restart_hessian':Keyword('#RESTART_HESSIAN','T'),
                                                       'restart_file_name':Keyword('#RESTART_FILE_NAME','to_be_specified')
                                                      }
                                           )
        elif algo == 'LBFGS':
            geo_opt_subs = {}
            geo_opt_subs['LBGFS'] = Section(name = 'LBFGS',
                                           keywords = {
                                                       'trust_radius':Keyword('#TRUST_RADIUS',-0.5,'\t #not completly tested, negative value means no trust radius'), 
                                                       'max_f_per_iter': Keyword('#MAX_F_PER_ITER',20,'\t #default'), 
                                                       'max_h_rank': Keyword('#MAX_H_RANK',5, '\t #default-5, larger value for fast converg, but larger memory'),
                                                       'remind':Keyword('#if LBFGS not ideal for convergence, try BFGS or change the following two tags'),
                                                       'wanted_proj_gradient': Keyword('#WANTED_PROJ_GRADIENT','1E-18','\t #default is 1E-16'),
                                                       'wanted_rel_F_error':Keyword('#WANTED_REL_F_ERROR','1E-18','#default is 1E-16'),
                                                      }
                                           )
        elif algo == 'CG':
            geo_opt_subs = {}
            geo_opt_subs['CG'] = Section(name = 'CG', 
                                         subsections = {'line_search': Section(name = 'LINE_SEARCH', 
                                                                               keywords = {'type': Keyword('TYPE','2PNT')})})

        #choose different level of convergence
        converg_levels_dict = {1:'very loose',
                               2:'loose',
                               3:'medium',
                               4:'default',
                               5:'tight',
                               6:'very tight',
                               7:'reg_test',
                              }

        
        print('\nAvailable different convergence levels for GEO_OPT:\n')
        print(yaml.dump(converg_levels_dict, sort_keys = False, default_flow_style = False))

        convg_index = input('\nPlease choose the convergence level for GEO_OPT:\n')
        if int(convg_index.strip()) == 1:     #very loose
            print('\nYour choice convergence level for GEO_OPT: very loose!\n')
            max_dr_val = '1E-1'    #unit: Bohr
            rms_dr_val = '5E-2'  #unit: Bohr
            max_force_val = '4.5E-2' #unit: Ha/Bohr
            rms_force_val = '1.5E-2'  #unit: Ha/Bohr

        elif int(convg_index.strip()) == 2:
            print('\nYour choice convergence level for GEO_OPT: loose!\n')
            max_dr_val = '1E-2'         #unit: Bohr
            rms_dr_val = '5E-3'       #unit: Bohr
            max_force_val = '4.5E-2'    #unit: Ha/Bohr
            rms_force_val = '1.5E-3'    #unit: Ha/Bohr

        elif int(convg_index.strip()) == 3:
            print('\nYour choice convergence level for GEO_OPT: medium!\n')
            max_dr_val = '3E-2'         #unit: Bohr
            rms_dr_val = '1.5E-3'       #unit: Bohr
            max_force_val = '6E-4'    #unit: Ha/Bohr
            rms_force_val = '3E-4'    #unit: Ha/Bohr

        elif int(convg_index.strip()) == 4:
            print('\nYour choice convergence level for GEO_OPT: default!\n')
            max_dr_val = '3E-3'         #unit: Bohr
            rms_dr_val = '1.5E-3'       #unit: Bohr
            max_force_val = '4.5E-4'    #unit: Ha/Bohr
            rms_force_val = '3E-4'    #unit: Ha/Bohr

        elif int(convg_index.strip()) == 5:
            print('\nYour choice convergence level for GEO_OPT: tight!\n')
            max_dr_val = '6E-5'         #unit: Bohr
            rms_dr_val = '3E-5'       #unit: Bohr
            max_force_val = '1.5E-5'    #unit: Ha/Bohr
            rms_force_val = '5E-6'    #unit: Ha/Bohr

        elif int(convg_index.strip()) == 6:
            print('\nYour choice convergence level for GEO_OPT: very tight!\n')
            max_dr_val = '6E-6'         #unit: Bohr
            rms_dr_val = '3E-6'       #unit: Bohr
            max_force_val = '1.5E-6'    #unit: Ha/Bohr
            rms_force_val = '5E-7'    #unit: Ha/Bohr

        elif int(convg_index.strip()) == 7:
            print('\nYour choice convergence level for GEO_OPT: reg_test!\n')
            max_dr_val = '1E-3'         #unit: Bohr
            rms_dr_val = '1E-3'       #unit: Bohr
            max_force_val = '1E-3'    #unit: Ha/Bohr
            rms_force_val = '1E-3'    #unit: Ha/Bohr

        
        GEO_OPT = Section(name = 'GEO_OPT', 
                          keywords = {'type': Keyword('TYPE','MINIMIZATION','\t #search for minimum'), 
                                      'max_iter': Keyword('MAX_ITER',500), 
                                      'max_dr': Keyword('MAX_DR',max_dr_val), 
                                      'rms_dr' : Keyword('RMS_DR',rms_dr_val), 
                                      'max_force' : Keyword('MAX_FORCE',max_force_val,'\t #<1E-04, 1E-05 for vibration'), 
                                      'rms_force': Keyword('RMS_FORCE',rms_force_val), 
                                      'optimizer': Keyword('OPTIMIZER',algo)}, 
                         subsections = geo_opt_subs)
        return GEO_OPT  #this returns a section

    ##    for transition state    ############
    def motion_band() -> Dict[str,cp2k_section]:
        band_subs = {}
        band_subs['CI_NEB'] = Section(name = 'CI_NEB',
                                      keywords = {'nsteps_IT':Keyword('NSTEPS_IT',5,'\t #IT-NEB steps before CI-NEB')})
        band_subs['replica_ini'] = Section(name = 'REPLICA',
                                           keywords = {'coord_filename':Keyword('#COORD_FILE_NAME','initial_structure.xyz')})
        band_subs['replica_fin'] = Section(name = 'REPLICA',
                                           keywords = {'coord_filename':Keyword('#COORD_FILE_NAME','final_structure.xyz',)})
        band_subs['program_run_info'] = Section(name = 'PROGRAM_RUN_INFO', 
                                                keywords = {'ini_config_info':Keyword('INITIAL_CONFIGURATION_INFO','T')})
        band_subs['convergence_info'] = Section(name = 'CONVERGENCE_INFO')
        band_subs['optimize'] = Section(name = 'OPTIMIZE_BAND',
                                        keywords = {'opt_end_points':Keyword('OPTIMIZE_END_POINTS','F','\t #default, if your initial and final structures not optimized, T'), 
                                                    'opt_type':Keyword('OPT_TYPE','DIIS','\t #default is DIIS, other-MD')})
        
        BAND = Section(name = 'BAND', 
                       keywords = {'band_type': Keyword('BAND_TYPE','CI-NEB','\t #others:IT-NEB'), 
                                   'align_frames':Keyword('ALIGN_FRAMES','F','\t # if surface ads., F, molecules or clusters-T'), 
                                   'rotate_frames':Keyword('ROTATE_FRAMES','F','\t # if surface ads., F, molecules or clusters-T'),
                                   'k_spring':Keyword('K_SPRING',0.05,'\t #default-0.02, large values but less accuracy'), 
                                   'nproc':Keyword('NPROC_REP',1,'\t #default,recommend cp2k.psmp for calculation'), 
                                   'num_replica':Keyword('NUMBER_OF_REPLICA',8,'\t #NEB total points, recommended same with mpi numbers in cp2k.psmp'),
                                   }, 
                       subsections = band_subs)
        return BAND
    
    def motion_print() -> Dict[str,cp2k_section]:    #for other calculation other than MD
        motion_print_subs = {}
        motion_print_subs['traj'] = Section(name = 'TRAJECTORY',
                                            keywords = {'format':Keyword('FORMAT','XYZ','\t #also PDB'),
                                                        'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                       },
                                            subsections = {'each':Section(name = 'EACH', 
                                                                          keywords = {'qs_scf':Keyword('QS_SCF',0),
                                                                                      'geo_opt':Keyword('#GEO_OPT',0),
                                                                                      'cell_opt':Keyword('#CELL_OPT',0),
                                                                                      'md':Keyword('#MD',10),
                                                                                     }
                                                                         )
                                                          }
                                           )
    
        motion_print_subs['restart'] = Section(name = 'RESTART',
                                            keywords = {'back_up_copies':Keyword('BACKUP_COPIES',0), 
                                                        'filename':Keyword('FILENAME','motion_restart'), 
                                                        'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                        'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1,'\t #output PROJECT_NAME-motion_restart-1.restart'),
                                                       }, 
                                              subsections = {'each':Section(name = 'EACH',
                                                                            keywords = {'qs_scf':Keyword('QS_SCF',0), 
                                                                                        'geo_opt':Keyword('#GEO_OPT',0), 
                                                                                        'cell_opt':Keyword('#CELL_OPT',0),
                                                                                        'md':Keyword('#MD',10),
                                                                                       }
                                                                           )
                                                            }
                                              )
        motion_print_subs['forces'] = Section(name = 'FORCES',
                                              keywords = {'filename':Keyword('FILENAME','motion_forces'),
                                                          'format':Keyword('FORMAT','XYZ'),
                                                          'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                          'print_atom_kind':Keyword('PRINT_ATOM_KIND','T')}, 
                                              subsections = {'each':Section(name = 'EACH', 
                                                                            keywords = {'qs_scf':Keyword('QS_SCF',0),
                                                                                        'geo_opt':Keyword('#GEO_OPT',0),
                                                                                        'cell_opt':Keyword('#CELL_OPT',0),
                                                                                        'md':Keyword('#MD',10),
                                                                                       }
                                                                           )
                                                            }
                                             )
        motion_print_subs['restart_history'] = Section(name = 'RESTART_HISTORY', section_parameters = ['OFF'])
    
        MOTION_PRINT = Section(name = 'PRINT', subsections = motion_print_subs)
        return  MOTION_PRINT
    
    
    #For MD, very important in CP2K
    def motion_md(use_velocity_soft) -> Dict[str,cp2k_section]:

        print('\nCSVR thermostat is more recommended!\n')
    
        thermostats_dict = {1:'CSVR', 2:'Nose_Hoover'}
        print('\nAvailable thermostates in AIMD cp2k:\n')
        print(yaml.dump(thermostats_dict, sort_keys = False, default_flow_style = False))
        
        thermostats_index = input('\nPlease choose the thermostat for AIMD, e.g. 1:\n')
        
        if int(thermostats_index.strip()) == 1:  ##choose the CSVR thermostat
            md_thermostat_subs = {}
            md_thermostat_subs['CSVR'] = Section(name = 'CSVR',
                                                 keywords = {'timecon':Keyword('TIMECON',100,'\t #time constant,[fs],smaller for stronger thermostatting')})
            md_subs = {}
            md_subs['thermostat'] = Section (name = 'THERMOSTAT',
                                             keywords = {'type':Keyword('TYPE','CSVR'), 
                                                         'region':Keyword('REGION','GLOBAL',
                                                                          '\t #default,others:DEFINED-independent region control temperature, NONE-not control temperature')
                                                        }, 
                                             subsections = md_thermostat_subs
                                            )
    
        
        elif int(thermostats_index.strip()) == 2:  ##choose the Nose_Hover thermostat
            md_thermostat_subs = {}
            md_thermostat_subs['NOSE'] = Section(name = 'NOSE',
                                                 keywords = {'length':Keyword('LENGTH',3,'\t #length of the Nose-Hoover chain'), 
                                                             'mts':Keyword('MTS',2,'\t #number of multiple timesteps for Nose-Hoover chain'), 
                                                             'timecon':Keyword('TIMECON',1000,'\t #timeconstant of the thermostat chain, [fs], smaller for stronger'),
                                                             'yoshida':Keyword('YOSHIDA',3,'\t #order of the yoshida integrator for thermostat')
                                                            }
                                                )
            md_subs = {}
            md_subs['thermostat'] = Section (name = 'THERMOSTAT',
                                             keywords = {'type':Keyword('TYPE','NOSE'), 
                                                         'region':Keyword('REGION','GLOBAL','\t #default, others:DEFINED-independent region control temperature, NONE-not control temperature')
                                                        }, 
                                             subsections = md_thermostat_subs
                                            )
        barostat_y_n = input('\nIf use the BAROSTAT? [y/n]:\n')
        if barostat_y_n.strip() == 'y':
            md_subs['barostat'] = Section(name = 'BAROSTAT', 
                                          keywords = {'pressure':Keyword('PRESSURE',1.01325,'\t #initial and maintained pressure [bar]'), 
                                                      'temperature':Keyword('#TEMPERATURE','\t #barostat initial temperature, if not set, ensemble temperature is used'),
                                                      'timecon':Keyword('TIMECON',1000,'\t #barostat time constant, [fs], smaller for stronger barostating'),
                                                      'virial':Keyword('#VIRIAL','XYZ','\t #for NPT_F(flexible) only, allow the change of lattice')
                                                     }
                                         )
        elif barostat_y_n.strip() == 'n':
            pass
        
        md_subs['print'] = Section(name = 'PRINT', 
                                   subsections = {'program_run_info':Section(name = 'PROGRAM_RUN_INFO', 
                                                                             subsections = {'each':Section(name = 'EACH', 
                                                                                                           keywords = {'md':Keyword('MD',10,'\t #0 means never')})}),
                                                  'energy':Section(name = 'ENERGY', 
                                                                   keywords = {'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'), 
                                                                               'filename':Keyword('FILENAME','md_energy'),
                                                                               'common_iter_level':Keyword('COMMON_ITERATION_LEVELS',1,'\t #default, output the project_name-[md_energy]-1.ener file'),
                                                                              },
                                                                   subsections = {'each':Section(name = 'EACH',
                                                                                                 keywords = {'md':Keyword('MD',1,'\t #each md step')}
                                                                                                )
                                                                                 }
                                                                   )
                                                 }
                                  )

        if use_velocity_soft == 'y':
            md_subs['velocity_soft'] = Section(name = 'VELOCITY_SOFTENING',
                                               keywords = {'alpha':Keyword('ALPHA',1.0,'\t #mixing factor for updating velocities'),
                                                           'delta':Keyword('DELTA',0.01,'\t #displacement used to obtain y'),
                                                           'steps':Keyword('STEPS',20,'\t #number of softening iterations performed, typical value around 40'),
                                                          }
                                              )
        elif use_velocity_soft == 'n':
            pass

        
        temperature_inp = input('\nPlease type in the temperature [K], e.g. 300:\n')
        
        MOTION_MD = Section(name = 'MD',           
                            keywords = {'ensemble':Keyword('ENSEMBLE','NVT','\t #canonical ensemble, NVE-micro, NPT_I, NPT_IA, NPT_F, NPE_F, NPE_I,LANGEVIN, REFTRAJ'), 
                                        'steps':Keyword('STEPS',2000,'\t #number of MD steps to perform, counting from STEP_START_VAL'), 
                                        'max_steps':Keyword('MAX_STEPS',10000,'\t #default-1E+9, number of MD steps to perform, counting from step 1'),
                                        'step_start_val':Keyword('STEP_START_VAL',0,'\t #default-0, starting step value for MD'),
                                        'timestep':Keyword('TIMESTEP',2.0, '\t #default-0.5 (for bond cleavage), step size [fs], decrease this value for high temperature condition'), 
                                        'time_start_val':Keyword('TIME_START_VAL',0,'\t #default-0 [fs],value = STEP_START_VAL*TIMESTEP,starting timer value for the MD'),
                                        'temperature':Keyword('TEMPERATURE',temperature_inp,'\t #initial and maintain T [K] in NVT/NPT'), 
                                        'comvel_tol':Keyword('#COMVEL_TOL',0,'\t #maximum velocity of center of mass,0-remove transition of center-of-mass each step'), 
                                        'angel_tol':Keyword('#ANGEL_TOL',0,'\t #only for isolated system-avoid the whole rotation,ignored for periodic systems, [au_t^-1*bohr]'), 
                                        'angel_zero':Keyword('#ANGEL_ZERO','T','\t #set initial angular velocity to zero-avoid the whole rotation, only for isolated systems, ignored for periodic systems')
                                       }, 
                            subsections = md_subs)
        return MOTION_MD
    
    
    def motion_print_for_md() -> cp2k_section:                 #specified for MD calculation
        motion_print_subs = {}
        motion_print_subs['traj'] = Section(name = 'TRAJECTORY',
                                            keywords = {'format':Keyword('FORMAT','XYZ','\t #also PDB, DCD_ALIGNED_CELL'), 
                                                        'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                        'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                        'filename':Keyword('FILENAME','motion_md_traj')}, 
                                            subsections = {'each':Section(name = 'EACH', 
                                                                          keywords = {'md':Keyword('MD',1,'\t #output frequency of coordinate')})
                                                          })
        
        motion_print_subs['velocity'] = Section(name = 'VELOCITIES', 
                                                keywords = {'format':Keyword('FORMAT','XYZ'), 
                                                            'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                            'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                            'filename':Keyword('FILENAME','motion_md_velocity')
                                                           }, 
                                                subsections = {'each':Section(name = 'EACH', 
                                                                              keywords = {'md':Keyword('MD',10)})
                                                              })
        
        motion_print_subs['restart'] = Section(name = 'RESTART',
                                               keywords = {'back_up_copies':Keyword('BACKUP_COPIES',0,'\t #0 means never'),
                                                           'filename':Keyword('FILENAME','motion_md_restart'),
                                                           'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                           'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                          }, 
                                               subsections = {'each':Section(name = 'EACH', keywords = {'md':Keyword('MD',1,'\t #make sure accurate restart')})
                                                             }
                                              )
        
        motion_print_subs['restart_history'] = Section(name = 'RESTART_HISTORY', section_parameters = ['OFF'])
    
        MOTION_PRINT = Section(name = 'PRINT', subsections = motion_print_subs)
        return  MOTION_PRINT     #this returns the section

    
    def motion_section(motion_subs:Dict[str,cp2k_section]) -> Dict[str,cp2k_section]:
        MOTION = Section(name = 'MOTION',
                        subsections = motion_subs)
        return MOTION    
    '''
    End the definition for &MOTION
    '''
    
    #########################################################################################################

    '''
    Begin the definition for &VIBRATIONAL_ANALYSIS
    '''
    def vibration_print() -> Dict[str,cp2k_section]:
        vib_print_subs = {}
        vib_print_subs['molden_vib'] = Section(name = 'MOLDEN_VIB', 
                                               section_parameters = ['#output project_name-VIBRATIONS-1.mol and .eig'],
                                               keywords = {'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                          }
                                              )   #this output .mol (Molden) file for visualization
        vib_print_subs['hessian'] = Section(name = 'HESSIAN', 
                                            section_parameters = ['#output project_name-Hessian-1.hess'],
                                            keywords = {'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                       }
                                           )
        VIBRATIONAL_ANALYSIS_PRINT = Section(name = 'PRINT', subsections = vib_print_subs)
        return VIBRATIONAL_ANALYSIS_PRINT
    
    
    def vibration_section(vibration_subs:Dict[str,cp2k_section]) -> Dict[str,cp2k_section]:
        VIBRATIONAL_ANALYSIS = Section(name = 'VIBRATIONAL_ANALYSIS', 
                                       keywords = {'dx':Keyword('DX',0.01,'\t #unit:bohr,default-0.01'), 
                                                   'fully_periodic':Keyword('FULLY_PERIODIC','T','\t #F for 3N-6 freqs, T for 3N-3 freqs'), 
                                                   'nproc':Keyword('NPROC_REP',1,'\t #default, suggest cp2k.psmp, number_of_replica = MPI/NPROC_REP'), 
                                                   'thermochem':Keyword('#THERMOCHEMISTRY','T','\t #valid for gas molecules'), 
                                                   'pressure':Keyword('TC_PRESSURE','1.01325E+05','\t #[Pa]'), 
                                                   'temperature':Keyword('TC_TEMPERATURE','273.15','\t #[K]')}, 
                                       subsections = vibration_subs)
        return VIBRATIONAL_ANALYSIS
    '''
    End the definition for &VIBRATIONAL_ANALYSIS
    '''

    ################################################################################################################

    '''
    Here, defines the standard FORCE_EVAL for OPT, SP, VIB, TS, using GPW, GAPW, Semi_emperical methods
    '''
    cp2k_calculation_methods_guideline = {1:'GPW + OT', 
                                          2:'GPW + DIAG',
                                          3:'GAPW + OT', 
                                          4:'GAPW + DIAG',
                                          5:'GPW + ADMM + OT',
                                          7:'GAPW + ADMM + OT',
                                          9:'GPW + ADMM + RI-HFX + DIAG',
                                         10:'GAPW + ADMM + RI-HFX + DIAG',
                                         11:'XTB + OT',
                                         12:'XTB + DIAG',
                                         13:'SCC_DFTB + OT',
                                         14:'SCC_DFTB + DIAG',
                                         15:'PM6 + OT',
                                         16:'PM6 + DIAG',
                                         17:'Molecular mechanics (MM) method',
                                         }
    
    def cp2k_thre_calculation(cp2k_calculation_methods_guideline:Dict[int,str]) -> None:
        print('\nCalculation methods in cp2k:\n')
        print(yaml.dump(cp2k_calculation_methods_guideline, sort_keys = False, default_flow_style = False))


    def FORCE_EVAL_std_sections(project_name:str,run_type:str) -> Dict[str,cp2k_section]:
        project_name = project_name
        run_type = run_type
        
        cp2k_thre_calculation(cp2k_calculation_methods_guideline)   #call function  

        x_1 = input('\nPlease choose the calculation method in cp2k, e.g. 2:\n')
        
        if int(x_1.strip()) == 1:   #GPW + OT
            dft_scf_subs = {'SCF_OT':scf_ot(),
                            'SCF_OUTER_SCF':scf_outer_scf(),
                            'SCF_PRINT':scf_print(),
                           }
            
            force_eval_dft_subs = {
                                    'QS':qs(method_index = -2, qs_subs = {}),
                                    'XC':xc_functional_pure(parse_xc_functionals_type(type_val = 0)),
                                    'POISSON':poisson(),
                                    'MGRID':mgrid(400,55),
                                    'SCF':scf(dft_scf_subs, use_ot = 'y'),
                                    'dft_print':dft_print(),
                                  }
            force_eval_subs = {'SUBSYS':subsys_section(cell_coord_kind_normal(coord_sec,basis_set(),potential())),
                               'DFT':dft_normal(project_name,force_eval_dft_subs, basis_set_filename(), potential_filename()), 
                               'FORCE_EVAL_PRINT':force_eval_print(run_type)
                              }
        
            FORCE_EVAL = force_eval_section('QUICKSTEP',force_eval_subs)
            
            return FORCE_EVAL         #this return a section

        
        elif int(x_1.strip()) == 2:    #GPW + DIAG                   
            dft_scf_subs = {'SCF_SMEAR':scf_smear(),
                            'SCF_DIAG':scf_diag(),
                            'SCF_MIXING':scf_mixing(),
                            'SCF_PRINT':scf_print()
                           }
            
            force_eval_dft_subs = {'KPOINTS':kpoints(),
                                   'QS':qs(method_index = -2, qs_subs = {}),
                                   'XC':xc_functional_pure(parse_xc_functionals_type(type_val = 0)),
                                   'POISSON':poisson(),
                                   'MGRID':mgrid(400,55),
                                   'SCF':scf(dft_scf_subs, use_ot = 'n'),
                                   'dft_print':dft_print(),
                                  }
            
            force_eval_subs = {'SUBSYS':subsys_section(cell_coord_kind_normal(coord_sec,basis_set(),potential())),
                               'DFT':dft_normal(project_name,force_eval_dft_subs, basis_set_filename(), potential_filename()), 
                               'FORCE_EVAL_PRINT':force_eval_print(run_type)
                              }
            
            FORCE_EVAL = force_eval_section('QUICKSTEP',force_eval_subs)
            
            return FORCE_EVAL         #this return a section


        elif int(x_1.strip()) == 3:    #GAPW + OT
            dft_scf_subs = {'SCF_OT':scf_ot(),
                            'SCF_OUTER_SCF':scf_outer_scf(),
                            'SCF_PRINT':scf_print()
                           }
            force_eval_dft_subs = {
                                   'QS':qs(method_index = -1, qs_subs = {}),
                                   'XC':xc_functional_pure(parse_xc_functionals_type(type_val = 0)),
                                   'POISSON':poisson(),
                                   'MGRID':mgrid(400,55),
                                   'SCF':scf(dft_scf_subs, use_ot = 'y'),
                                   'dft_print':dft_print(),
                                  }
            
            force_eval_subs = {'SUBSYS':subsys_section(cell_coord_kind_normal(coord_sec,basis_set(),potential())),
                               'DFT':dft_normal(project_name,force_eval_dft_subs, basis_set_filename(), potential_filename()), 
                               'FORCE_EVAL_PRINT':force_eval_print(run_type)}
            
            FORCE_EVAL = force_eval_section('QUICKSTEP',force_eval_subs)
            
            return FORCE_EVAL         #this return a section  

        
        elif int(x_1.strip()) == 4:    #GAPW  + DIAG
            dft_scf_subs = {'SCF_SMEAR':scf_smear(),
                            'SCF_DIAG':scf_diag(),
                            'SCF_MIXING':scf_mixing(),
                            'SCF_PRINT':scf_print()
                           }
            
            force_eval_dft_subs = {'KPOINTS':kpoints(),
                                   'QS':qs(method_index = -1, qs_subs = {}),
                                   'XC':xc_functional_pure(parse_xc_functionals_type(type_val = 0)),
                                   'POISSON':poisson(),
                                   'MGRID':mgrid(400,55),
                                   'SCF':scf(dft_scf_subs, use_ot = 'n'),
                                   'dft_print':dft_print(),
                                  }
            force_eval_subs = {'SUBSYS':subsys_section(cell_coord_kind_normal(coord_sec,basis_set(),potential())),
                               'DFT':dft_normal(project_name,force_eval_dft_subs, basis_set_filename(), potential_filename()), 
                               'FORCE_EVAL_PRINT':force_eval_print(run_type)}
            
            FORCE_EVAL = force_eval_section('QUICKSTEP',force_eval_subs)

            return FORCE_EVAL         #this return a section    

        
        elif int(x_1.strip()) == 5:        #GPW, HF_ADMM,using OT, for hybrid functional
            dft_scf_subs = {'SCF_OT':scf_ot(),
                            'SCF_OUTER_SCF':scf_outer_scf(),
                            'SCF_PRINT':scf_print()}
            
            aux_density_matrix_admm(use_ot = 'y')
            
            force_eval_dft_admm_subs = {
                                        'QS':qs(method_index = -2, qs_subs = {}),
                                        'XC':xc_functional_hybrid(functional_name = parse_xc_functionals_type(type_val = 1), use_RI = 'n'),
                                        'aux_den_matr_method':aux_density_matrix_admm(use_ot = 'y'),
                                        'POISSON':poisson(),
                                        'MGRID':mgrid(400,55),
                                        'SCF':scf(dft_scf_subs, use_ot = 'y'),
                                        'dft_print':dft_print(),
                                        }

            force_eval_subs = {'SUBSYS':subsys_section(cell_coord_kind_admm(coord_sec,basis_set(),basis_set_admm(),potential())),
                               'DFT':dft_admm(project_name, force_eval_dft_admm_subs,basis_set_filename(),basis_set_admm_filename(),potential_filename()), 
                               'FORCE_EVAL_PRINT':force_eval_print(run_type)}
            FORCE_EVAL = force_eval_section('QUICKSTEP',force_eval_subs)
            
            return FORCE_EVAL         #this return a section

        
        elif int(x_1.strip()) == 7:        #GAPW, HF_ADMM,using OT, for hybrid functionals
            dft_scf_subs = {'SCF_OT':scf_ot(),
                            'SCF_OUTER_SCF':scf_outer_scf(),
                            'SCF_PRINT':scf_print()}
            
            aux_density_matrix_admm(use_ot = 'y')
            
            force_eval_dft_admm_subs = {
                                        'QS':qs(method_index = -1, qs_subs = {}),
                                        'XC':xc_functional_hybrid(functional_name = parse_xc_functionals_type(type_val = 1), use_RI = 'n'),
                                        'aux_den_matr_method':aux_density_matrix_admm(use_ot = 'y'),
                                        'POISSON':poisson(),
                                        'MGRID':mgrid(400,55),
                                        'SCF':scf(dft_scf_subs, use_ot = 'y'),
                                        'dft_print':dft_print(),
                                        }
    
            force_eval_subs = {'SUBSYS':subsys_section(cell_coord_kind_admm(coord_sec,basis_set(),basis_set_admm(),potential())),
                               'DFT':dft_admm(project_name, force_eval_dft_admm_subs,basis_set_filename(),basis_set_admm_filename(),potential_filename()), 
                               'FORCE_EVAL_PRINT':force_eval_print(run_type)}
            FORCE_EVAL = force_eval_section('QUICKSTEP',force_eval_subs)
            
            return FORCE_EVAL         #this return a section   

    
        elif int(x_1.strip()) == 9:        #GPW, HF_ADMM + RI_HFX,using DIAG, for hybrid functionals, use kpoints, so no OT 
            dft_scf_subs = {'SCF_SMEAR':scf_smear(),
                            'SCF_DIAG':scf_diag(),
                            'SCF_MIXING':scf_mixing(),
                            'SCF_PRINT':scf_print()
                           }
            
            aux_density_matrix_admm(use_ot = 'n')
            
            force_eval_dft_admm_subs = {'KPOINTS':kpoints(),
                                        'QS':qs(method_index = -2, qs_subs = {}),
                                        'XC':xc_functional_hybrid(functional_name = parse_xc_functionals_type(type_val = 1), use_RI = 'y'),
                                        'aux_den_matr_method':aux_density_matrix_admm(use_ot = 'n'),
                                        'POISSON':poisson(),
                                        'MGRID':mgrid(400,55),
                                        'SCF':scf(dft_scf_subs, use_ot = 'n'),
                                        'dft_print':dft_print(),
                                        }
    
            force_eval_subs = {'SUBSYS':subsys_section(cell_coord_kind_admm(coord_sec,basis_set(),basis_set_admm(),potential())),
                               'DFT':dft_admm_RI_HFX(project_name,force_eval_dft_admm_subs,basis_set_filename(),basis_set_admm_filename(),potential_filename()), 
                               'FORCE_EVAL_PRINT':force_eval_print(run_type)}
            
            FORCE_EVAL = force_eval_section('QUICKSTEP',force_eval_subs)

            return FORCE_EVAL         #this return a section    
    
    
        elif int(x_1.strip()) == 10:        #GAPW, HF_ADMM + RI_HFX,using DIAG, for hybrid functionals,  use kpoints, so no OT
            dft_scf_subs = {'SCF_SMEAR':scf_smear(),
                            'SCF_DIAG':scf_diag(),
                            'SCF_MIXING':scf_mixing(),
                            'SCF_PRINT':scf_print()
                           }
            
            aux_density_matrix_admm(use_ot = 'n')
            
            force_eval_dft_admm_subs = {'KPOINTS':kpoints(),
                                        'QS':qs(method_index = -1, qs_subs = {}),
                                        'XC':xc_functional_hybrid(functional_name = parse_xc_functionals_type(type_val = 1), use_RI = 'y'),
                                        'aux_den_matr_method':aux_density_matrix_admm(use_ot = 'n'),
                                        'POISSON':poisson(),
                                        'MGRID':mgrid(400,55),
                                        'SCF':scf(dft_scf_subs, use_ot = 'n'),
                                        'dft_print':dft_print(),
                                        }
    
            force_eval_subs = {'SUBSYS':subsys_section(cell_coord_kind_admm(coord_sec,basis_set(),basis_set_admm(),potential())),
                               'DFT':dft_admm_RI_HFX(project_name,force_eval_dft_admm_subs,basis_set_filename(),basis_set_admm_filename(),potential_filename()), 
                               'FORCE_EVAL_PRINT':force_eval_print(run_type)}
            FORCE_EVAL = force_eval_section('QUICKSTEP',force_eval_subs)
            
            return FORCE_EVAL         #this return a section

            
        elif int(x_1.strip()) == 11:        #XTB + OT
            ###Begin the semi_emperical definitions
            ##XTB
            def dft_for_XTB(project_name, dft_XTB_subs):
                DFT_XTB = Section(name = 'DFT',
                                  keywords = {'WFN_RESTART_FILE_NAME':Keyword('#WFN_RESTART_FILE_NAME','{}-RESTART.kp(.wfn)'.format(project_name)),
                                              'CHARGE':Keyword('CHARGE',0),
                                              'multiplicity':Keyword('MULTIPLICITY',1)
                                             },
                                  subsections = dft_XTB_subs
                                 )
                return DFT_XTB     #this returns a section

        
            def qs_xtb():
                xtb_parameter = {}
                xtb_parameter['param'] = Section(name = 'PARAMETER',
                                                keywords = {'dispersion':Keyword('DISPERSION_PARAMETER_FILE','dftd3.dat'),
                                                            'para_file_name':Keyword('PARAM_FILE_NAME','xTB_parameters')
                                                           }
                                                )
                XTB = Section(name = 'XTB',
                             keywords = {'ewald':Keyword('DO_EWALD','T'),
                                         'check_atom_charge':Keyword('CHECK_ATOMIC_CHARGES','F','\t #T is easy to crash'), 
                                         'halogen_correction':Keyword('USE_HALOGEN_CORRECTION','T')
                                        },
                              subsections =  xtb_parameter
                             )
                return XTB   #this returns a section    

            
            dft_for_XTB_scf_subs = {'scf_ot':scf_ot(),
                                    'scf_outer_scf':scf_outer_scf(),
                                    'scf_print':scf_print()}
    
            dft_for_XTB_subs = {'qs': qs(method_index = 4, qs_subs = {'qs_subs':qs_xtb()}),
                                'poisson':poisson(), 
                                'scf':scf(dft_for_XTB_scf_subs, use_ot = 'y'),
                               }
            force_eval_for_XTB_subs = {'SUBSYS':subsys_section(cell_coord(coord_sec)), 
                                       'DFT':dft_for_XTB(project_name, dft_for_XTB_subs), 
                                       'force_eval_print':force_eval_print(run_type)
                                      }
            
            FORCE_EVAL = force_eval_section('QUICKSTEP', force_eval_for_XTB_subs)
            
            return FORCE_EVAL         #this return a section   


        elif int(x_1.strip()) == 12:        #XTB + DIAG
            ###Begin the semi_emperical definitions
            ##XTB
            def dft_for_XTB(project_name, dft_XTB_subs):
                DFT_XTB = Section(name = 'DFT',
                                  keywords = {'WFN_RESTART_FILE_NAME':Keyword('#WFN_RESTART_FILE_NAME','{}-RESTART.kp(.wfn)'.format(project_name)),
                                              'CHARGE':Keyword('CHARGE',0),
                                              'multiplicity':Keyword('MULTIPLICITY',1)
                                             },
                                  subsections = dft_XTB_subs
                                 )
                return DFT_XTB     #this returns a section
        
                
            def qs_xtb():
                xtb_parameter = {}
                xtb_parameter['param'] = Section(name = 'PARAMETER',
                                                keywords = {'dispersion':Keyword('DISPERSION_PARAMETER_FILE','dftd3.dat'),
                                                            'para_file_name':Keyword('PARAM_FILE_NAME','xTB_parameters')
                                                           }
                                                )
                XTB = Section(name = 'XTB',
                             keywords = {'ewald':Keyword('DO_EWALD','T'),
                                         'check_atom_charge':Keyword('CHECK_ATOMIC_CHARGES','F','\t #T is easy to crash'), 
                                         'halogen_correction':Keyword('USE_HALOGEN_CORRECTION','T')
                                        },
                              subsections =  xtb_parameter
                             )
                return XTB   #this returns a section    

            
            dft_for_XTB_scf_subs = {'SCF_SMEAR':scf_smear(),
                                    'SCF_DIAG':scf_diag(),
                                    'SCF_MIXING':scf_mixing(),
                                    'SCF_PRINT':scf_print()
                                   }
    
            dft_for_XTB_subs = {'qs': qs(method_index = 4, qs_subs = {'qs_subs':qs_xtb()}), 
                                'poisson':poisson(), 
                                'scf':scf(dft_for_XTB_scf_subs, use_ot = 'n'),
                               }
            force_eval_for_XTB_subs = {'SUBSYS':subsys_section(cell_coord(coord_sec)), 
                                       'DFT':dft_for_XTB(project_name, dft_for_XTB_subs), 
                                       'force_eval_print':force_eval_print(run_type)
                                      }
            
            FORCE_EVAL = force_eval_section('QUICKSTEP', force_eval_for_XTB_subs)
            
            return FORCE_EVAL         #this return a section

        elif int(x_1.strip()) == 13:        #SCC_DFTB + OT
            ##SCC_DFTB
            def dft_for_dftb(project_name,dft_dftb_subs):
                DFT_for_DFTB = Section(name = 'DFT',
                                      keywords = {'WFN_RESTART_FILE_NAME':Keyword('#WFN_RESTART_FILE_NAME','{}-RESTART.kp(.wfn)'.format(project_name)),
                                                  'CHARGE':Keyword('CHARGE',0),
                                                  'multiplicity':Keyword('MULTIPLICITY',1)
                                                 },
                                      subsections = dft_dftb_subs
                                     )
                return DFT_for_DFTB
        
        
            def qs_dftb():
                DFTB_subs = {}
                DFTB_subs['parameter'] = Section(name = 'PARAMETER', 
                                                 keywords = {'param_file_path':Keyword('PARAM_FILE_PATH','DFTB/scc'), 
                                                             'param_file_name':Keyword('PARAM_FILE_NAME','scc_parameter'),
                                                             'uff_forcefield':Keyword('UFF_FORCE_FIELD','uff_table') #scc_parameter and uff_table should be in DFTB/scc file 
                                                            }
                                                )
                
                SCC_DFTB = Section(name = 'DFTB', 
                                   keywords = {'self_consistent':Keyword('SELF_CONSISTENT','T','\t #use self-consistent method'), 
                                               'dispersion':Keyword('DISPERSION','T','\t #use dispersion correction'), 
                                               'do_ewald':Keyword('DO_EWALD','T','\t #for coulomb interaction, periodic-T, non_periodic-F'), 
                                              }, 
                                   subsections = DFTB_subs
                                  )
                return SCC_DFTB      #this returns a section
        
            
            def poisson_ewald():
                POISSON_EWALD = Section(name = 'EWALD', 
                                        keywords = {'ewald_type':Keyword('EWALD_TYPE','SPME','\t #recommended-smooth particle mesh using beta-Euler splines'),
                                                    'gmax':Keyword('GMAX', int(2 * np.rint(cell_length_a)), int(2 * np.rint(cell_length_b)), int(2 * np.rint(cell_length_c)),
                                                                   '\t #number of grid points-SPME and EWALD')
                                                   },
                                       )
                POISSON = Section(name = 'POISSON', subsections = {'ewald': POISSON_EWALD})
                return POISSON

            
            dft_for_dftb_scf_subs = {'scf_ot':scf_ot(),
                                     'scf_outer_scf':scf_outer_scf(),
                                     'scf_print':scf_print()}
    
            dft_for_dftb_subs = {'qs':qs(method_index = 3, qs_subs = {'qs_subs':qs_dftb()}), 
                                 'possion':poisson_ewald(),
                                 'scf':scf(dft_for_dftb_scf_subs, use_ot = 'y')}
    
            force_eval_for_dftb_subs = {'subsys':subsys_section(cell_coord(coord_sec)), 
                                        'dft':dft_for_dftb(project_name, dft_for_dftb_subs),
                                        'force_eval_print':force_eval_print(run_type)
                                       }
            
            FORCE_EVAL = force_eval_section('QUICKSTEP',force_eval_for_dftb_subs)
            
            return FORCE_EVAL         #this return a section   


        elif int(x_1.strip()) == 14:        #SCC_DFTB + DIAG
            ##SCC_DFTB
            def dft_for_dftb(project_name,dft_dftb_subs):
                DFT_for_DFTB = Section(name = 'DFT',
                                      keywords = {'WFN_RESTART_FILE_NAME':Keyword('#WFN_RESTART_FILE_NAME','{}-RESTART.kp(.wfn)'.format(project_name)),
                                                  'CHARGE':Keyword('CHARGE',0),
                                                  'multiplicity':Keyword('MULTIPLICITY',1)
                                                 },
                                      subsections = dft_dftb_subs
                                     )
                return DFT_for_DFTB
        
        
            def qs_dftb():
                DFTB_subs = {}
                DFTB_subs['parameter'] = Section(name = 'PARAMETER', 
                                                 keywords = {'param_file_path':Keyword('PARAM_FILE_PATH','DFTB/scc'), 
                                                             'param_file_name':Keyword('PARAM_FILE_NAME','scc_parameter'),
                                                             'uff_forcefield':Keyword('UFF_FORCE_FIELD','uff_table') #scc_parameter and uff_table should be in DFTB/scc file 
                                                            }
                                                )
                
                SCC_DFTB = Section(name = 'DFTB', 
                                   keywords = {'self_consistent':Keyword('SELF_CONSISTENT','T','\t #use self-consistent method'), 
                                               'dispersion':Keyword('DISPERSION','T','\t #use dispersion correction'), 
                                               'do_ewald':Keyword('DO_EWALD','T','\t #for coulomb interaction, periodic-T, non_periodic-F'), 
                                              }, 
                                   subsections = DFTB_subs
                                  )
                return SCC_DFTB      #this returns a section
        
            
            def poisson_ewald():
                POISSON_EWALD = Section(name = 'EWALD', 
                                        keywords = {'ewald_type':Keyword('EWALD_TYPE','SPME','\t #recommended-smooth particle mesh using beta-Euler splines'),
                                                    'gmax':Keyword('GMAX', int(2 * np.rint(cell_length_a)), int(2 * np.rint(cell_length_b)), int(2 * np.rint(cell_length_c)),
                                                                   '\t #number of grid points-SPME and EWALD')
                                                   },
                                       )
                POISSON = Section(name = 'POISSON', subsections = {'ewald': POISSON_EWALD})
                return POISSON

         
            dft_for_dftb_scf_subs = {'SCF_SMEAR':scf_smear(),
                                     'SCF_DIAG':scf_diag(),
                                     'SCF_MIXING':scf_mixing(),
                                     'SCF_PRINT':scf_print()
                                    }
    
            dft_for_dftb_subs = {'qs':qs(method_index = 3, qs_subs = {'qs_subs':qs_dftb()}), 
                                 'possion':poisson_ewald(),
                                 'scf':scf(dft_for_dftb_scf_subs, use_ot = 'n')}
    
            force_eval_for_dftb_subs = {'subsys':subsys_section(cell_coord(coord_sec)),  
                                        'dft':dft_for_dftb(project_name, dft_for_dftb_subs),
                                        'force_eval_print':force_eval_print(run_type)
                                       }
            
            FORCE_EVAL = force_eval_section('QUICKSTEP',force_eval_for_dftb_subs)
            
            return FORCE_EVAL         #this return a section


        elif int(x_1.strip()) == 15:        #PM6 + OT
            ##PM6
            def dft_for_pm6(project_name,dft_pm6_subs):
                DFT_for_PM6 = Section(name = 'DFT',
                                      keywords = {'WFN_RESTART_FILE_NAME':Keyword('#WFN_RESTART_FILE_NAME','{}-RESTART.kp(.wfn)'.format(project_name)),
                                                  'CHARGE':Keyword('CHARGE',0),
                                                  'multiplicity':Keyword('MULTIPLICITY',1)
                                                 },
                                      subsections = dft_pm6_subs
                                     )
                return DFT_for_PM6
            
            
            def qs_pm6():
                QS_PM6 = Section(name = 'SE', 
                                   keywords = {'periodic':Keyword('PERIODIC','EWALD',
                                                                  '\t #default-NONE, others: EWALD_R3, EWALD_GKS, treatment for the electrostatic long-range part in semi-empirical calculations'), 
                                               'integral_screen':Keyword('INTEGRAL_SCREENING','KDSO','\t #others: KDSO-D, SLATER, for the Coulomb interactions'), 
                                              }, 
                                  )
                return QS_PM6      #this returns a section    
            
            
            def poisson_for_pm6():
                POISSON_EWALD = Section(name = 'EWALD', 
                                        keywords = {'ewald_type':Keyword('EWALD_TYPE','EWALD'),
                                                    'gmax':Keyword('GMAX', int(np.rint(cell_length_a)), int(np.rint(cell_length_b)), int(np.rint(cell_length_c)),
                                                                   '\t #number of grid points-SPME and EWALD')
                                                   },
                                       )
                POISSON = Section(name = 'POISSON', subsections = {'ewald': POISSON_EWALD})
                return POISSON

            
            dft_for_pm6_scf_subs = {'scf_ot':scf_ot(),
                                    'scf_outer_scf':scf_outer_scf(),
                                    'scf_print':scf_print()}
    
            dft_for_pm6_subs = {'qs':qs(method_index = 10, qs_subs = {'pm6':qs_pm6()}), 
                                 'possion':poisson_for_pm6(),
                                 'scf':scf(dft_for_pm6_scf_subs,use_ot = 'y')}
    
            force_eval_for_pm6_subs = {'subsys':subsys_section(cell_coord(coord_sec)), 
                                        'dft':dft_for_pm6(project_name, dft_for_pm6_subs),
                                        'force_eval_print':force_eval_print(run_type)
                                       }
            
            FORCE_EVAL = force_eval_section('QUICKSTEP',force_eval_for_pm6_subs)
            
            return FORCE_EVAL         #this return a section    


        elif int(x_1.strip()) == 16:        #PM6 + DIAG
            ##PM6
            def dft_for_pm6(project_name,dft_pm6_subs):
                DFT_for_PM6 = Section(name = 'DFT',
                                      keywords = {'WFN_RESTART_FILE_NAME':Keyword('#WFN_RESTART_FILE_NAME','{}-RESTART.kp(.wfn)'.format(project_name)),
                                                  'CHARGE':Keyword('CHARGE',0),
                                                  'multiplicity':Keyword('MULTIPLICITY',1)
                                                 },
                                      subsections = dft_pm6_subs
                                     )
                return DFT_for_PM6
            
            
            def qs_pm6():
                QS_PM6 = Section(name = 'SE', 
                                   keywords = {'periodic':Keyword('PERIODIC','EWALD',
                                                                  '\t #default-NONE, others: EWALD_R3, EWALD_GKS, treatment for the electrostatic long-range part in semi-empirical calculations'), 
                                               'integral_screen':Keyword('INTEGRAL_SCREENING','KDSO','\t #others: KDSO-D, SLATER, for the Coulomb interactions'), 
                                              }, 
                                  )
                return QS_PM6      #this returns a section    
            
            
            def poisson_for_pm6():
                POISSON_EWALD = Section(name = 'EWALD', 
                                        keywords = {'ewald_type':Keyword('EWALD_TYPE','EWALD'),
                                                    'gmax':Keyword('GMAX', int(np.rint(cell_length_a)), int(np.rint(cell_length_b)), int(np.rint(cell_length_c)),
                                                                   '\t #number of grid points-SPME and EWALD')
                                                   },
                                       )
                POISSON = Section(name = 'POISSON', subsections = {'ewald': POISSON_EWALD})
                return POISSON

            
            dft_for_pm6_scf_subs = {'scf_smear':scf_smear(),
                                    'scf_diag':scf_diag(),
                                    'scf_mixing':scf_mixing(),
                                    'scf_print':scf_print()}
    
            dft_for_pm6_subs = {'qs':qs(method_index = 10, qs_subs = {'pm6':qs_pm6()}), 
                                 'possion':poisson_for_pm6(),
                                 'scf':scf(dft_for_pm6_scf_subs,use_ot = 'n')}
    
            force_eval_for_pm6_subs = {'subsys':subsys_section(cell_coord(coord_sec)), 
                                        'dft':dft_for_pm6(project_name, dft_for_pm6_subs),
                                        'force_eval_print':force_eval_print(run_type)
                                       }
            
            FORCE_EVAL = force_eval_section('QUICKSTEP',force_eval_for_pm6_subs)
            
            return FORCE_EVAL         #this return a section 


        elif int(x_1.strip()) == 17:        #MM method
            subsys_topology_subs = {}
            subsys_topology_subs['center_coord'] = Section(name = 'CENTER_COORDINATES', 
                                                           section_parameters = ['#make atoms center'])
            
            MM_subsys_subs = {}
            MM_subsys_subs['topology'] = Section(name = 'TOPOLOGY', 
                                                 keywords = {'conn_file_format':Keyword('#CONN_FILE_FORMAT','PSF',
                                                                                        '\t #generate a molecule, default-GENERATE, others: UPSF, MOL_SET, G87, G96, AMNER, USER'),
                                                             'conn_file_name':Keyword('#CONN_FILE_NAME','to be specified','\t #contains the molecular connectivity'),
                                                             'coord_file_format':Keyword('#COORD_FILE_FORMAT','XYZ','\t #which coordinates will be read, default-OFF, others: PDB, G96, CRD, CIF, XTL, CP2K'),
                                                             'coord_file_name':Keyword('#COORD_FILE_NAME','to be specified'),
                                                             'multicell':Keyword('#MULTIPLE_UNIT_CELL',1,1,1,'\t #make super cell, in accordance with that in &CELL'),
                                                            },
                                                 subsections = subsys_topology_subs
                                                )
            MM_subsys_subs['cell'] = Section(name = 'CELL',
                                             keywords = {'A':Keyword('A','  ',A[0],'  ',A[1],'  ',A[2]),
                                                         'B':Keyword('B','  ',B[0],'  ',B[1],'  ',B[2]),
                                                         'C':Keyword('C','  ',C[0],'  ',C[1],'  ',C[2]),
                                                         'PERIODIC':Keyword('PERIODIC','XYZ','\t #shoud match with that in &PSOLVER'),
                                                         'ALPHA_BETA_GAMMA': Keyword('ALPHA_BETA_GAMMA',alpha,beta,gamma),
                                                         'multicell':Keyword('#MULTIPLE_UNIT_CELL',1,1,1,'\t #make super cell, in accordance with that in &CELL'),
                                                        }
                                            )
    
            MM_subsys_subs['COORD'] = Section(name = 'COORD', keywords = car_coords)
            
            force_eval_for_MM_subsys = Section(name = 'SUBSYS', subsections = MM_subsys_subs)
    
    
            MM_forcefiels_subs = {}
            MM_forcefiels_subs['spline'] = Section(name = 'SPLINE', section_parameters = ['#parameters for nonboned interactions, pair body potential and many body potential'],
                                                   keywords = {'emax_spline':Keyword('#EMAX_SPLINE',5.0,'\t #[hartree], maximum value of the potential up to which splines will be constructed'),
                                                               'EPS_SPLINE':Keyword('EPS_SPLINE','1E-07','\t #[hartree], threshold for choice of number of points in splines'),
                                                               'rcut_nb':Keyword('#RCUT_NB',12.0,'\t #[angstrom], cutoff radius for nonbonded interactions'),
                                                              }
                                                  )
    
            for x in range(len(element)):     #assign the charge for each element
                MM_forcefiels_subs['ATOMS_{}'.format(x)] = Section(name = 'CHARGE',
                                                                   section_parameters = [element[x]],
                                                                   keywords = {'ATOM': Keyword('ATOM',element[x]),
                                                                               'CHARGE': Keyword('CHARGE',0),
                                                                              }
                                                                  )
    
            add_bond_bend_y_n = input('\nIf to add the &BOND and &BEND section:[y/n]:\n')
            if add_bond_bend_y_n.strip() == 'y':
                MM_forcefiels_subs['BOND'] = Section(name = 'BOND', 
                                                     keywords = {'atoms':Keyword('ATOMS','X','X'),
                                                                 'remind':Keyword('#section can be repeated'),
                                                                 'kind':Keyword('KIND','HARMONIC','\t #Bondpotential-CHARMM, AMBER, G87, G96, QUARTIC, MORSE, CUBIC, FUES'),
                                                                 'R0':Keyword('#R0','[angstrom]',0.0,'\t #equilibrium distance'),
                                                                 'K':Keyword('K','[angstrom^-2kcalmol]',0.0,'\t #force constant of the potential, MORSE needs 2 numbers, QUARTIC needs 3 numbers'),
                                                                }
                                                    )
                MM_forcefiels_subs['BEND'] = Section(name = 'BEND', 
                                                     keywords = {'atoms':Keyword('ATOMS','X','X','X'),
                                                                 'remind':Keyword('#section can be repeated'),
                                                                 'kind':Keyword('KIND','HARMONIC','\t #Bondpotential-CHARMM, AMBER, G87, G96, QUARTIC, MORSE, CUBIC, FUES'),
                                                                 'theta0':Keyword('#THETA0','[deg]',0.0,'\t #equilibrium distance'),
                                                                 'K':Keyword('K','[rad^-2kcalmol]',0.0,'\t #force constant of the potential, MORSE needs 2 numbers, QUARTIC needs 3 numbers'),
                                                                }
                                                    )
            elif add_bond_bend_y_n.strip() == 'n':
                pass
    
    
            nb_subs = {}
            pairs = len(element_succint) * (len(element_succint) + 1)/2     #determine the section_numbers of L-J potential for atomic pairs
    
            print('\nAvailable MM potential types:\n')
            mm_potential_list = {1:'Lennard_Jones potential',
                                 2:'EAM potential',
                                 3:'GENPOT potential',
                                }
            print(yaml.dump(mm_potential_list, sort_keys = False, default_flow_style = False))
    
            mm_pot_inp = input('\nPlease choose the potential type, e.g. 1:\n')
    
            if int(mm_pot_inp.strip()) == 1:      #choose the L-J potential
                atom_pair_list = []
                for a_i in range(len(element_succint)):
                    for a_j in range(a_i, len(element_succint)):
                        atom_pair_list.append('{atom_1} {atom_2}'.format(atom_1 = element_succint[a_i], atom_2 = element_succint[a_j]))
                        
                for pair in atom_pair_list:
                    nb_subs['L-J_{}'.format(pair)] = Section(name = 'LENNARD-JONES', 
                                                             keywords = {'atoms':Keyword('ATOMS', pair),
                                                                         'epsilon':Keyword('EPSILON','[kcalmol]','value to be specified','\t #EPSILON parameter of the LJ potential, [K_e]'),
                                                                         'sigma':Keyword('SIGMA','[angstrom]','value to be specified','\t #SIGMA parameter of the LJ potential, [angstrom]'),
                                                                         'rcut':Keyword('RCUT','[angstrom]','value to be specified','\t #cutoff parameter of the LJ potential, [angstrom]'),
                                                                        }
                                                            )
    
            
            elif int(mm_pot_inp.strip()) == 2:      #choose the EAM potential
                atoms_inp = input('\nPlease type in the atom pair e.g. Fe,Co:\n')
                atoms_1 = atoms_inp.strip().split(',')[0]
                atoms_2 = atoms_inp.strip().split(',')[1]
                nb_subs['eam'] = Section(name = 'EAM', 
                                         keywords = {'atoms':Keyword('ATOMS',atoms_1,atoms_2),
                                                     'param_filename':Keyword('PARAM_FILE_NAME','to be specified'),
                                                     'remind':Keyword('#Section can be repeated'),
                                                    }
                                        )
    
    
            elif int(mm_pot_inp.strip()) == 3:      #choose the GENPOT potential
                print('\nFind atomic elements:',element_succint)
                
                atom_pairs_list = []
                pair_inp = '-1'
                while pair_inp != '':
                    pair_inp = input('\nPlease type in the atom pair e.g. Fe,Co, press enter to quit:\n')
                    atom_pairs_list.append(pair_inp)
                atoms_pair_list = atom_pairs_list[:-1]
                
                
                for atoms_inp in atoms_pair_list:
                    atoms_1 = [x_i.strip() for x_i in atoms_inp.split(',')][0]
                    atoms_2 = [y_i.strip() for y_i in atoms_inp.split(',')][1]
        
                    function = input('\nPlease type in the potential function formula for atom pair {}:\n'.format(atoms_inp.strip()))
                    
                    parameters_inp = input('\nPlease type in the parameters in this function for atom pair {} e.g. a,b,D:\n'.format(atoms_inp.strip()))
                    parameters = ' '.join([x_i.strip() for x_i in parameters_inp.split(',')])
        
                    values_inp = input('\nPlease type in the corresponding values for these parameters of atom pair {}:\n'.format(atoms_inp.strip()))
                    values = ' '.join([y_i.strip() for y_i in values_inp.split(',')])
                    
                    variable = input('\nPlease type in the variable in this function for atom pair {}:\n'.format(atoms_inp.strip()))
                    
                    nb_subs['genpot_{}'.format(atoms_inp.strip())] = Section(name = 'GENPOT', 
                                                                     keywords = {'atoms':Keyword('ATOMS',atoms_1,atoms_2),
                                                                                 'function':Keyword('FUNCTION',function),
                                                                                 'parameters':Keyword('PARAMETERS',parameters),
                                                                                 'variable':Keyword('VARIABLE',variable.strip()),
                                                                                 'values':Keyword('VALUES',values),
                                                                                 'rcut':Keyword('RCUT',15,'\t #[angstrom]'),
                                                                                 'remind':Keyword('#Section can be repeated!'),
                                                                                }
                                                                    )
    
                
            MM_forcefiels_subs['nonbonded'] = Section(name = 'NONBONDED', subsections = nb_subs)
            
            force_eval_MM_subs = {}
            force_eval_MM_subs['forcefield'] = Section(name = 'FORCEFIELD', 
                                                       keywords = {'ignore_missing_critical_param':Keyword('IGNORE_MISSING_CRITICAL_PARAMS','F'),
                                                                   'multiple_potential':Keyword('#MULTIPLE_POTENTIAL','T','\t #default-F'),
                                                                   'param_file_name':Keyword('#PARAM_FILE_NAME','to be specified'),
                                                                   'param_type':Keyword('#PARAMTYPE','CHM','\t #kind of torsion potential, others: OFF, G87, G96, AMBER'),
                                                                  },
                                                       subsections = MM_forcefiels_subs)
    
            force_eval_MM_subs['poisson'] = poisson_ewald()
    
            EACH ={'each':Section(name = 'EACH', 
                                  keywords = {'geo_opt':Keyword('#GEO_OPT',1),
                                              'cell_opt':Keyword('#CELL_OPT',1),
                                              'md':Keyword('#MD',10)
                                             }
                                 )
                  }
            MM_print_subs = {}  
            MM_print_subs['ff_info'] = Section(name = 'FF_INFO', 
                                               keywords = {'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                           'iter':Keyword('COMMON_ITERATION_LEVELS',1),
                                                           'filename':Keyword('FILENAME','mm_ff_info'),
                                                          },
                                               subsections = EACH
                                              )
            MM_print_subs['ff_param_file'] = Section(name = 'FF_PARAMETER_FILE', 
                                               keywords = {'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                           'iter':Keyword('COMMON_ITERATION_LEVELS',2,'\t #default-2'),
                                                           'filename':Keyword('FILENAME','mm_ff_param'),
                                                          },
                                               subsections = EACH
                                              )        
            force_eval_MM_subs['print'] = Section(name = 'PRINT', subsections = MM_print_subs)    
            
            force_eval_MM = Section(name = 'MM', subsections = force_eval_MM_subs)
    
            FORCE_EVAL_MM = Section(name = 'FORCE_EVAL', 
                                    keywords = {'method':Keyword('METHOD','FIST')},
                                    subsections = {'subsys':force_eval_for_MM_subsys,
                                                   'mm':force_eval_MM
                                                  }
                                   )

            return FORCE_EVAL_MM            
    '''
    End the definition of standard FORCE_EVAL for OPT, SP, VIB, TS, using GPW, GAPW, Semi_emperical methods
    '''
    
    #################################################################################################################

    '''
    Begin the definition for other functions
    '''
    def atomic_choose() -> List[int]:
        atomic_cart_z = []
        z = '-1'
        while z != "":           #press enter to exit
            z = input('\nPlease add the height window pair by pair in one line, left < right, Press enter to quit\ne.g. 3.2,4.2 for one pair\n')
            atomic_cart_z.append(([c_i.strip() for c_i in z.split(',')]))
        atomic_cart_z
        z_coords = atomic_cart_z[:-1]
        
        for x_i in range(len(z_coords)):
            for x_j in range(len(z_coords[x_i])):
                z_coords[x_i][x_j] = float(z_coords[x_i][x_j])
        z_coords
        
        z_coords_array = np.array(z_coords)
        
        print('\nYour defined height gap pairs:\n',z_coords_array,'unit: Angstorm\n')
        
        z_coords_choose = [ [] for i in range(len(z_coords_array))]
            
        for coords in range(len(cartesian_coords)):
            for z_window in range(len(z_coords_array)):
                if (cartesian_coords[coords][2] >= z_coords_array[z_window][0]) & (cartesian_coords[coords][2] <= z_coords_array[z_window][1]):
                    z_coords_choose[z_window] += [coords]
        z_coords_choose
        print('\nFind the atomic indexes for correction:\n',z_coords_choose,'\n')       #find the element you want to replace
        
        new_symbol_list = [ [] for i in range(len(z_coords_choose))]
        for x_i in range(len(z_coords_choose)):
            for x_j in z_coords_choose[x_i]:
                new_symbol_list[x_i].append(labels[x_j])
        new_symbol_list
        
        print('\nCorresponding chemical symbols:\n', new_symbol_list,'\n')
        
        new_labels = input('\nYou need to type in {length} letter(s) for new chemical element(s):\n'.format(length = len(z_coords_choose)))
        new_labels_list = [label_i.strip() for label_i in new_labels.split(',')]
        new_element_list = copy.deepcopy(labels)      #copy the printine labels in atoms
        
        for x_i in range(len(z_coords_choose)):
            for x_j in z_coords_choose[x_i]:
                 new_element_list[x_j] = new_labels_list[x_i]
        new_element_list                    #replace the old chemical elements with newly defined
        
        return new_element_list
    
    
    ###This part for add &BS method
    def kind_bs(kinds:str) -> cp2k_section:
        bs_alpha_list = []
        bs_alpha_inp = '-1'
        while bs_alpha_inp != '':
            bs_alpha_inp = input('\nAlpha-NEL, L, N for KIND {},NEL-change of electrons, L-angular, N-principle:e.g. +4,2,3 for 3d orbital\n'.format(kinds))
            print()
            bs_alpha_list.append(([x_i.strip() for x_i in bs_alpha_inp.split(',')]))
        bs_alpha = bs_alpha_list[:-1]
        bs_alpha_arr = np.array(bs_alpha).astype(str)
    
        bs_beta_list = []
        bs_beta_inp = '-1'
        while bs_beta_inp != '':
            bs_beta_inp = input('\nBeta-NEL, L, N for KIND {},NEL-change of electrons, L-angular, N-principle:e.g. +4,2,3 for 3d orbital\n'.format(kinds))
            print()
            bs_beta_list.append([x_i.strip() for x_i in bs_beta_inp.split(',')])
        bs_beta = bs_beta_list[:-1]
        bs_beta_arr = np.array(bs_beta).astype(str)
        
        BS_ALPHA = Section(name = 'ALPHA',keywords = {'nel': Keyword('NEL', ''.join([x_i + ' ' for x_i in bs_alpha_arr[:,0]])), 
                                                      'L': Keyword('L', ''.join([x_i + ' ' for x_i in bs_alpha_arr[:,1]])), 
                                                      'N': Keyword('N', ''.join([x_i + ' ' for x_i in bs_alpha_arr[:,2]]))})
        
        BS_BETA = Section(name = 'BETA',keywords = {'nel': Keyword('NEL', ''.join([x_i + ' ' for x_i in bs_beta_arr[:,0]])), 
                                                    'L': Keyword('L', ''.join([x_i + ' ' for x_i in bs_beta_arr[:,1]])), 
                                                    'N': Keyword('N', ''.join([x_i + ' ' for x_i in bs_beta_arr[:,2]]))})
        BS_subs = {}
        BS_subs['alpha'] = BS_ALPHA
        BS_subs['beta'] = BS_BETA
    
        BS = Section(name = 'BS',subsections = BS_subs)
        return BS

    '''
    End the definition for other functions
    '''

    ##################################################################################################################

    '''
    Begin the detailed various tasks
    '''   
    cp2k_tasks_guideline = {-1:'back to main plate',
                             0:'geometry optimization by fixing cell',
                             1:'cell optimization for both cell and atoms',
                             2:'energy, single point (SP) energy task',
                             3:'energy and force',
                             5:'vibration analysis',
                            15:'ab-intio mocular dynamics (AIMD)',
                            19:'transition state by Dimer',
                            20:'transition state by CI-NEB',
                            21:'phonon calculation with finite displacement',
                            25:'global optimization',
                            30:'other settings',
                            }
    
    print('\nCurrent tasks in cp2k:\n')
    print(yaml.dump(cp2k_tasks_guideline, sort_keys = False, default_flow_style = False))
    
    
    
    x_0 = input('\nPlease choose the index before cp2k tasks! e.g. 2\n')

    if int(x_0.strip()) == -1:      #back to main plate
        return
    
    if int(x_0.strip()) == 0:    #geometry optimization, fixing cell
        project_name = input('\nPlease type in the project name:\n')
        run_type = 'GEO_OPT'
        
        inp_sections_dict = {}
        inp_sections_dict['global'] = global_section(project_name,run_type)
        inp_sections_dict['force_eval'] = FORCE_EVAL_std_sections(project_name,run_type)
        
        print('\nAvailable optimizer for GEO_OPT:\n')
        algo_dict = {0:'LBFGS',1:'BFGS',2:'CG'}
        print(yaml.dump(algo_dict, sort_keys = False, default_flow_style = False))
        
        algo_index = input('\nPlease choose the optimizer, e.g. 1:\n')
    
        motion_subs = {'geo_opt':motion_geo_opt(algo_dict[int(algo_index.strip())]),
                       'motion_print':motion_print()
                      }

        inp_sections_dict['motion'] = motion_section(motion_subs)
        
        
        write_cp2k_inp(project_name, inp_sections_dict)


    if int(x_0.strip()) == 1:    ##geometry optimization, relaxing both cell and atoms
        project_name = input('\nPlease type in the project name:\n')
        run_type = 'CELL_OPT'
        
        inp_sections_dict = {}
        inp_sections_dict['global'] = global_section(project_name,run_type)
        inp_sections_dict['force_eval'] = FORCE_EVAL_std_sections(project_name,run_type)
        
        print('\nAvailable optimizer for CELL_OPT:\n')
        algo_dict = {0:'LBFGS',1:'BFGS',2:'CG'}
        print(yaml.dump(algo_dict, sort_keys = False, default_flow_style = False))
        algo_index = input('\nPlease choose the optimizer, e.g. 1:\n')

        print('\nAvailable cell_opt type:\n')
        cell_opt_type_dict = {0:'direct_cell_opt, with both cell and atom optimized at the same time',
                              1:'add GEO_OPT between cell optmizations, stree tensor calc. at opted geometry',
                              2:'add MD, with MD calc. of stress tensor for cell_opt'
                             }
        print(yaml.dump(cell_opt_type_dict, sort_keys = False, default_flow_style = False))
        
        cell_opt_type_i = input('\nPlease choose the type for CELL_OPT, e.g. 0:\n')
        if int(cell_opt_type_i.strip()) == 0:
            opt_type = 'DIRECT_CELL_OPT'
        
            motion_subs = {'cell_opt':motion_cell_opt(algo = algo_dict[int(algo_index.strip())], opt_type = opt_type),
                           'motion_print':motion_print()}
            
            inp_sections_dict['MOTION'] = motion_section(motion_subs)
            
            write_cp2k_inp(project_name.strip(),inp_sections_dict)
            
            print('\nIf your cell lattice experiences large shifts during optimization, you can add &CELL_REF section, try 30: other settings\n')
            print()
    
        elif int(cell_opt_type_i.strip()) == 1:
            opt_type = 'GEO_OPT'
            
            print('\nAvailable optimizer for geo opt:\n')
            algo_dict_2 = {0:'LBFGS',1:'BFGS',2:'CG'}
            print(yaml.dump(algo_dict_2, sort_keys = False, default_flow_style = False))
            algo_index_2 = input('\nPlease choose the optimizer, e.g. 1:\n')
        
            motion_subs = {'cell_opt':motion_cell_opt(algo = algo_dict[int(algo_index.strip())], opt_type = opt_type),
                           'geo_opt':motion_geo_opt(algo = algo_dict_2[int(algo_index_2.strip())]),
                           'motion_print':motion_print()}
            
            inp_sections_dict['MOTION'] = motion_section(motion_subs)
            
            write_cp2k_inp(project_name,inp_sections_dict)
            
            print('\nIf your cell lattice experiences large shifts during optimization, you can add &CELL_REF section, try 30: other settings\n')
            print()

        elif int(cell_opt_type_i.strip()) == 2:
            opt_type = 'MD'
            
            print('\nAvailable optimizer for geo opt:\n')
            algo_dict_2 = {0:'LBFGS',1:'BFGS',2:'CG'}
            print(yaml.dump(algo_dict_2, sort_keys = False, default_flow_style = False))
            algo_index_2 = input('\nPlease choose the optimizer, e.g. 1:\n')
        
            motion_subs = {'cell_opt':motion_cell_opt(algo = algo_dict[int(algo_index.strip())], opt_type = opt_type),
                           'add_md':motion_md(use_velocity_soft = 'n'),
                           'motion_print_for_md':motion_print_for_md(),
                          }
            
            inp_sections_dict['MOTION'] = motion_section(motion_subs)
            
            write_cp2k_inp(project_name.strip(),inp_sections_dict)
            
            print('\nIf your cell lattice experiences large shifts during optimization, you can add &CELL_REF section, try 30: other settings\n')
            print()


    if int(x_0.strip()) == 2:    ##single point energy calculation
        project_name = input('\nPlease type in the project name:\n')
        run_type = 'ENERGY'
        
        inp_sections_dict = {}
        inp_sections_dict['global'] = global_section(project_name,run_type)
        inp_sections_dict['force_eval'] = FORCE_EVAL_std_sections(project_name,run_type)

        write_cp2k_inp(project_name.strip(),inp_sections_dict)

    
    if int(x_0.strip()) == 3:     ##energy and forces calculation
        project_name = input('\nPlease type in the project name:\n')
        run_type = 'ENERGY_FORCE'
        
        inp_sections_dict = {}
        inp_sections_dict['global'] = global_section(project_name,run_type)
        inp_sections_dict['force_eval'] = FORCE_EVAL_std_sections(project_name,run_type)

        write_cp2k_inp(project_name.strip(),inp_sections_dict)


    if int(x_0.strip()) == 5:   ##performing vibrational analysis
        project_name = input('\nPlease type in the project name:\n')
        run_type = 'VIBRATIONAL_ANALYSIS'
        
        inp_sections_dict = {}
        inp_sections_dict['global'] = global_section(project_name,run_type)
        inp_sections_dict['force_eval'] = FORCE_EVAL_std_sections(project_name,run_type)
        
        motion_subs = {}
        motion_subs['print'] = motion_print()
        MOTION = motion_section(motion_subs)
        
        vibration_subs = {}
        vibration_subs['print'] = vibration_print()
        VIBRATIONAL_ANALYSIS = vibration_section(vibration_subs)
    
    #    inp_sections_dict['motion'] = MOTION    
        inp_sections_dict['vibration'] = VIBRATIONAL_ANALYSIS
        
        write_cp2k_inp(project_name.strip(),inp_sections_dict)


    if int(x_0.strip()) == 15:   ##performing AIMD simulations, this is the main section of cp2k code
        project_name = input('\nPlease type in the project name:\n')
        run_type = 'MD'
        
        inp_sections_dict = {}
        inp_sections_dict['global'] = global_section(project_name,run_type)
        inp_sections_dict['force_eval'] = FORCE_EVAL_std_sections(project_name,run_type)
        
        
        motion_subs = {}
        motion_subs['md'] = motion_md(use_velocity_soft = 'n')
        motion_subs['print_for_md'] = motion_print_for_md()
    
        inp_sections_dict['motion_for_md'] = motion_section(motion_subs)
        
        write_cp2k_inp(project_name.strip(),inp_sections_dict)


    if int(x_0.strip()) == 19:   ##performing TS, using Dimer
        project_name = input('\nPlease type in the project name:\n')
        run_type = 'GEO_OPT'
        
        inp_sections_dict = {}
        inp_sections_dict['global'] = global_section(project_name,run_type)
        inp_sections_dict['force_eval'] = FORCE_EVAL_std_sections(project_name,run_type)
    
    
        rot_opt_subs = {}
        rot_opt_subs['cg'] = Section(name = 'CG', 
                                     subsections = {'line_search':Section(name = 'LINE_SEARCH', 
                                                                          keywords = {'type':Keyword('TYPE','2PNT')}
                                                                         )
                                                   }
                                    )    
        dimer_subs = {}
        dimer_subs['rot_opt'] = Section(name = 'ROT_OPT', 
                                        keywords = {'optimizer':Keyword('OPTIMIZER','CG','\t #default-BFGS shoud change to CG'),
                                                    'max_iter':Keyword('MAX_ITER',200,'\t #maximum number of geometry optimization steps'),
                                                    'max_dr':Keyword('MAX_DR','3E-03'),
                                                    'max_force':Keyword('MAX_FORCE','4.5E-04','\t #[bohr^-1*hartree]'),
                                                    'rms_dr':Keyword('RMS_DR','1.5E-03'),
                                                    'rms_force':Keyword('RMS_FORCE','3E-04','\t #[bohr^-1*hartree]')
                                                   },
                                        subsections = rot_opt_subs
                                       )
        ts_subs = {}
        ts_subs['dimer'] = Section(name = 'DIMER',
                                   keywords = {'angle_tol':Keyword('ANGLE_TOLERANCE','[deg]',5.0),
                                               'dr':Keyword('DR',0.01,'\t #default is ok'),
                                               'interpolate_gradient':Keyword('INTERPOLATE_GRADIENT','T','\t #default'),
                                               'k_dimer':Keyword('K_DIMER','F','\t #default-activates the constrained k-dimer translation'),
                                               
                                              },
                                   subsections = dimer_subs
                                  )
        
        geo_opt_subs = {}
        geo_opt_subs['transition_state'] = Section(name = 'TRANSITION_STATE', 
                                                   keywords = {'method':Keyword('METHOD','DIMER')},
                                                   subsections = ts_subs)
        geo_opt_subs['cg'] =  rot_opt_subs['cg']   #same with rot_opt_subs['cg']
        
        motion_dimer_subs = {}
        motion_dimer_subs['geo_opt'] = Section(name = 'GEO_OPT', 
                                               keywords = {'type':Keyword('TYPE','TRANSITION_STATE','\t #use Dimer for TS'),
                                                           'optimizer':Keyword('OPTIMIZER','CG')
                                                          },
                                               subsections = geo_opt_subs
                                              )
    
        motion_dimer_subs['print'] = motion_print()
    
        inp_sections_dict['motion'] = motion_section(motion_dimer_subs)
    
        write_cp2k_inp(project_name.strip(),inp_sections_dict)


    if int(x_0) == 20:   ##performing TS, using CI_NEB
        project_name = input('\nPlease type in the project name:\n')
        run_type = 'BAND'
        
        inp_sections_dict = {}
        inp_sections_dict['global'] = global_section(project_name,run_type)
        inp_sections_dict['force_eval'] = FORCE_EVAL_std_sections(project_name,run_type)
        
        motion_subs = {}
        motion_subs['band'] = motion_band()
        motion_subs['print'] = motion_print()
    
        inp_sections_dict['motion'] = motion_section(motion_subs)
        write_cp2k_inp(project_name.strip(),inp_sections_dict)
    
    
    if int(x_0) == 21:      ##Phonon calculation,finite displacement
        project_name = input('\nPlease type in the project name:\n')
        run_type = 'ENERGY_FORCE'
        
        inp_sections_dict = {}
        inp_sections_dict['global'] = global_section(project_name,run_type)
        inp_sections_dict['force_eval'] = FORCE_EVAL_std_sections(project_name,run_type)
        
        write_cp2k_inp(project_name.strip(),inp_sections_dict)


    if int(x_0) == 25:      ##global optimization, with minima hopping by Goedecker
        project_name = input('\nPlease type in the project name:\n')
        run_type = 'NONE'
        global_for_min_hop = Section(name = 'GLOBAL',
                                     keywords = {'project_name':Keyword('PROJECT_NAME',project_name),
                                                 'program_name':Keyword('PROGRAM_NAME','SWARM'),
                                                 'run_type':Keyword('RUN_TYPE',run_type),
                                                 'seed':Keyword('SEED',42)
                                                }
                                    )

        
        global_opt_subs = {}
        global_opt_subs['history'] = Section(name = 'HISTORY',
                                             keywords = {'energy_precision':Keyword('ENERGY_PRECISION','1E-5','\t #energy threshold to be considered equal'),
                                                         'fingerprint_precision':Keyword('FINGERPRINT_PRECISION','1E-2','\t #euclidean distance to be considered equal')
                                                        },
                                            )

        minima_method_dict = {1:'minima hopping',
                              2:'minima crawling',
                             }

        print('\nAvailable minima methods:\n')
        print(yaml.dump(minima_method_dict, sort_keys = False, default_flow_style = False))   

        minima_method_idx = input('\nPlease choose the minima method, e.g. 1:\n')
        if int(minima_method_idx.strip()) == 1:     #choose the minima hopping
            global_opt_subs['minima_hopping'] = Section(name = 'MINIMA_HOPPING', 
                                                        keywords = {'e_accept_init':Keyword('E_ACCEPT_INIT','5E-03','\t #[hartree], initial value of acceptance energy'),
                                                                    'temp_init':Keyword('TEMPERATURE_INIT',100,'\t #initial temperature, [K]'),
                                                                   }
                                                       )     
            
        if int(minima_method_idx.strip()) == 2:     #choose the minima crawling
            global_opt_subs['minima_hopping'] = Section(name = 'MINIMA_CRAWLING', 
                                                        keywords = {'temp_max':Keyword('TEMPSTEP_MAX',100,'\t #maximum number of temperature steps'),
                                                                    'temp_init':Keyword('TEMPERATURE_INIT',100,'\t #initial temperature, [K]'),
                                                                   }
                                                       )

        
        swarm_subs = {}
        swarm_subs['global_opt'] = Section(name = 'GLOBAL_OPT',
                                           keywords = {'e_target':Keyword('E_TARGET','-0.028421532','\t #[hartree],optimization will quit once a lower potential energy is reached'),
                                                       'method':Keyword('METHOD','MINIMA_HOPPING'),
                                                       
                                                      },
                                           subsections = global_opt_subs
                                          )
        
        swarm_section = Section(name = 'SWARM',
                                keywords = {'behavior':Keyword('BEHAVIOR','GLOBAL_OPT'),
                                            'max_iter':Keyword('MAX_ITER',500),
                                            'num_of_workers':Keyword('NUMBER_OF_WORKERS',1,'\t #to make (total_cpus - 1)/number_of_workers is an integer'),
                                            'replay_commun_log':Keyword('#REPLAY_COMMUNICATION_LOG','swarm_translog_replay.xyz','\t #Filename of communication log of previous run, to restart a swarm'),
                                           },
                                subsections = swarm_subs
                               )

        
        inp_sections_dict = {}
        inp_sections_dict['global'] = global_for_min_hop
        inp_sections_dict['swarm'] = swarm_section
        inp_sections_dict['force_eval'] = FORCE_EVAL_std_sections(project_name,run_type)
        
        print('\nAvailable optimizer for GEO_OPT:\n')
        algo_dict = {0:'LBFGS',1:'BFGS',2:'CG'}
        print(yaml.dump(algo_dict, sort_keys = False, default_flow_style = False))
        
        algo_index = input('\nPlease choose the optimizer, e.g. 1:\n')
    
        motion_subs = {'geo_opt':motion_geo_opt(algo_dict[int(algo_index.strip())]),
                       'md':motion_md(use_velocity_soft = 'y'),
                       'motion_print':motion_print_for_md(),
                      }

        inp_sections_dict['motion'] = motion_section(motion_subs)
        
        
        write_cp2k_inp(project_name, inp_sections_dict)    
    

    if int(x_0) == 30:
        other_settings_guideline = {0:'back to main plate',
                                    15:'change between OT and DIAG',
                                    16:'change the XC_FUNCTIONAL',
                                    17:'perform basis set superposition error (BSSE) calc.',
                                    18:'use LS_SCF method in place of SCF method',
                                    19:'use smearing in SCF',
                                    20:'DFT+U with ramping and enforcing occupation',
                                    21:'change PSOLVER in &DFT',
                                    22:'use electric field', 
                                    23:'add magnetization tag', 
                                    24:'use &BS for magnetization calculation', 
                                    25:'make supercell', 
                                    26:'dipole correction along Z', 
                                    27:'print bandstructure in &DFT',
                                    28:'print DOS,PDOS,LDOS in &DFT',
                                    30:'print other things in &DFT',
                                    31:'decrease the number of shells in &HF',
                                    33:'add prints in MOTION',
                                    40:'use DFT-D', 
                                    41:'add vibration-IR calculation',
                                    42:'add vibration-Raman calculation',
                                    43:'add vibration-IR + Raman calculation',
                                    44:'use mode selective vibration analysis (MSVA) method',
                                    50:'add atoms constraint list in &MOTION',
                                    51:'set reference cell for CELL_OPT or NPT in AIMD',
                                    52:'use MSST in AIMD',
                                    53:'other settings for AIMD',
                                    54:'perform constrained MD',
                                    55:'use implicit solvent model, self-consistent continuum solvation (SCCS)',
                                    60:'calculate XAS',
                                    61:'calculate excitation',
                                    62:'add excited PES settings (opt, vib)',
                                    63:'calculate NMR',
                                    66:'GW calculation',
                                    70:'perform CDFT calculation',
                                   }
    
        print('\nAvailable other settings:\n')
        print(yaml.dump(other_settings_guideline, sort_keys = False, default_flow_style = False))
        other_settings_index = input('\nPlease choose the setting index, e.g. 19:\n')
    
        project_name = 'additional_inp_settings' #this project_name only used in this function!!!

        if int(other_settings_index.strip()) == 0:      #get back to main plate
            return       


        
        elif int(other_settings_index.strip()) == 15:   #change between OT and DIAG
            scf_algo_dict = {1:'OT', 
                             2:'DIAG',
                            }
            print('\nAvailable SCF algorithms:\n')
            print(yaml.dump(scf_algo_dict, sort_keys = False, default_flow_style = False))            

            algo_index = input('\nPlease choose the algorithm for SCF, e.g. 1:\n')
            if int(algo_index.strip()) == 1:   #choose OT
                dft_scf = Section('SCF', 
                                  subsections = {'ot':scf_ot(),
                                                 'outer_scf':scf_outer_scf()
                                                }
                                 )
                force_eval_dft = Section(name = 'DFT', subsections = {'scf': dft_scf})
                force_eval = Section(name = 'FORCE_EVAL', subsections = {'dft': force_eval_dft})

                write_cp2k_inp('use_OT', {'force_eval':force_eval})

            elif int(algo_index.strip()) == 2:   #choose DIAG
                dft_scf = Section('SCF', 
                                  subsections = {'diag':scf_diag(),
                                                 'mixing':scf_mixing()
                                                }
                                 )
                force_eval_dft = Section(name = 'DFT', subsections = {'kpoints':kpoints(),
                                                                      'scf': dft_scf
                                                                     }
                                        )
                force_eval = Section(name = 'FORCE_EVAL', subsections = {'dft': force_eval_dft})

                write_cp2k_inp('use_DIAG', {'force_eval':force_eval}) 

        

        elif int(other_settings_index.strip()) == 16:   #change the xc_functional

            xc_functional_type_dict = {1:'pure functional', 
                                       2:'hybrid functional with RI_HFX',
                                       3:'hybrid functional not with RI_HFX'
                                      }
            print('\nAvailable other settings:\n')
            print(yaml.dump(xc_functional_type_dict, sort_keys = False, default_flow_style = False))
            func_type_index = input('\nPlease choose the funtional type, e.g. 1:\n')

            if int(func_type_index.strip()) == 1:      #choose the pure functional
                XC_FUNCT_section = xc_functional_pure(functional_name = parse_xc_functionals_type(type_val = 0))

            if int(func_type_index.strip()) == 2:   #choose the hybrid functional, with RI_HFX
                XC_FUNCT_section = xc_functional_hybrid(functional_name = parse_xc_functionals_type(type_val = 1), use_RI = 'y')

            if int(func_type_index.strip()) == 3:   #choose the hybrid functional, not with RI_HFX
                XC_FUNCT_section = xc_functional_hybrid(functional_name = parse_xc_functionals_type(type_val = 1), use_RI = 'n')

            
            DFT_section = Section(name = 'DFT', subsections = {'xc': XC_FUNCT_section})

            FORCE_EVAL = Section(name = 'FORCE_EVAL', subsections = {'dft': DFT_section})

            write_cp2k_inp('change_the_xc', {'force_eval': FORCE_EVAL})
        

        
        elif int(other_settings_index.strip()) == 17:   #perform BSSE
            print('\nThe &DFT section is same with normal SP calc.\n')
            print('\nBSSE not support for kpoints!')
            GLOBAL_for_bsse = Section(name = 'GLOBAL',
                                      keywords = {'project_name':Keyword('PROJECT_NAME','BSSE'),
                                                  'print_level':Keyword('PRINT_LEVEL','MEDIUM'),
                                                  'run_type':Keyword('RUN_TYPE','BSSE')
                                                 }
                                     )
            
            subsys_for_bsse_subs = {}            
            subsys_for_bsse_subs['CELL'] = Section(name = 'CELL',
                                    keywords = {'A':Keyword('A','  ',A[0],'  ',A[1],'  ',A[2]),
                                                'B':Keyword('B','  ',B[0],'  ',B[1],'  ',B[2]),
                                                'C':Keyword('C','  ',C[0],'  ',C[1],'  ',C[2]),
                                                'PERIODIC':Keyword('PERIODIC','XYZ','\t #shoud match with that in &PSOLVER'),
                                                'ALPHA_BETA_GAMMA': Keyword('ALPHA_BETA_GAMMA',alpha,beta,gamma),
                                                }
                                    )
            subsys_for_bsse_subs['COORD'] = Section(name = 'COORD', keywords = car_coords)
        
            basis_set = basis_set()
            potential = potential()
            
            for x in range(len(element)):
                subsys_for_bsse_subs['KIND_{}'.format(x)] = Section(name = 'KIND',
                                                      section_parameters = [element[x]],
                                                      keywords = {'ELEMENT': Keyword('ELEMENT',element[x]),
                                                                  'BASIS_SET': Keyword('BASIS_SET',basis_set),
                                                                  'POTENTIAL': Keyword('POTENTIAL',potential)},
                                                          )
            for y in range(len(element)):
                subsys_for_bsse_subs['KIND_{}_ghost'.format(y)] = Section(name = 'KIND',
                                                      section_parameters = ['{}_ghost'.format(element[y])],
                                                      keywords = {'ELEMENT': Keyword('ELEMENT',element[y]),
                                                                  'BASIS_SET': Keyword('BASIS_SET',basis_set),
                                                                  'POTENTIAL': Keyword('POTENTIAL',potential),
                                                                  'ghost':Keyword('GHOST'),
                                                                 },
                                                          )                
            force_eval_subsys_for_bsse = Section(name = 'SUBSYS', subsections = subsys_for_bsse_subs)

            bsse_subs = {}
            
            list_1_inp = input('\nPlease type in the atom index for fragment 1, e.g. 1,2,3..6[for 3-6],14,:\n')
            list_1_tot = [x_j.strip() for x_j in list_1_inp.split(',')]
            
            LIST_f_1 = {}
            for x_j in list_1_tot:
                LIST_f_1[x_j] = Keyword('LIST',x_j)
            bsse_subs['fragment_1'] = Section(name = 'FRAGMENT', keywords = LIST_f_1)

            list_2_inp = input('\nPlease type in the atom index for fragment 2, e.g. 1,2,3..6[for 3-6],14,:\n')
            list_2_tot = [x_j.strip() for x_j in list_2_inp.split(',')]
            
            LIST_f_2 = {}
            for y_j in list_2_tot:
                LIST_f_2[x_j] = Keyword('LIST',y_j)
            bsse_subs['fragment_2'] = Section(name = 'FRAGMENT', keywords = LIST_f_2)

            chg_spin_for_A_and_B = input('\nType in the charge and multiplicity for A+B system, e.g. 0,1:\n')
            chg_spin_for_A = input('\nType in the charge and multiplicity for Fragment A, e.g. 0,1:\n')
            chg_spin_for_B = input('\nType in the charge and multiplicity for Fragment B, e.g. 0,1:\n')

            chg_spin_A_B_list = [x_i.strip() for x_i in chg_spin_for_A_and_B.split(',')]
            chg_spin_A_list = [x_i.strip() for x_i in chg_spin_for_A.split(',')]
            chg_spin_B_list = [x_i.strip() for x_i in chg_spin_for_B.split(',')]

            charge_A_and_B = chg_spin_A_B_list[0]
            spin_A_and_B = chg_spin_A_B_list[1]
            charge_A = chg_spin_A_list[0]
            spin_A = chg_spin_A_list[1]
            charge_B = chg_spin_B_list[0]
            spin_B = chg_spin_B_list[1]
            
            bsse_subs['config_real_A_and_real_B'] = Section(name = 'CONFIGURATION', 
                                                            keywords = {'rel_A_and_B':Keyword('#for real_A and real_B fragments'),
                                                                        'glb_conf':Keyword('GLB_CONF',1,1),
                                                                        'sub_conf':Keyword('SUB_CONF',1,1),
                                                                        'charge':Keyword('CHARGE',int(charge_A_and_B)),
                                                                        'multiplicity':Keyword('MULTIPLICITY',int(spin_A_and_B)),
                                                                       }
                                                           )
            bsse_subs['config_real_A'] = Section(name = 'CONFIGURATION', 
                                                            keywords = {'real_A':Keyword('#for real_A fragment'),
                                                                        'glb_conf':Keyword('GLB_CONF',1,0),
                                                                        'sub_conf':Keyword('SUB_CONF',1,0),
                                                                        'charge':Keyword('CHARGE',int(charge_A)),
                                                                        'multiplicity':Keyword('MULTIPLICITY',int(spin_A)),
                                                                       }
                                                           )
            bsse_subs['config_real_B'] = Section(name = 'CONFIGURATION', 
                                                            keywords = {'real_B':Keyword('#for real_B fragment'),
                                                                        'glb_conf':Keyword('GLB_CONF',0,1),
                                                                        'sub_conf':Keyword('SUB_CONF',0,1),
                                                                        'charge':Keyword('CHARGE',int(charge_B)),
                                                                        'multiplicity':Keyword('MULTIPLICITY',int(spin_B)),
                                                                       }
                                                           )
            bsse_subs['config_real_A_and_ghost_B'] = Section(name = 'CONFIGURATION', 
                                                            keywords = {'real_A_and_ghost_B':Keyword('#for real_A and ghost_B fragments'),
                                                                        'glb_conf':Keyword('GLB_CONF',1,1),
                                                                        'sub_conf':Keyword('SUB_CONF',1,0),
                                                                        'charge':Keyword('CHARGE',int(charge_A)),
                                                                        'multiplicity':Keyword('MULTIPLICITY',int(spin_A)),
                                                                       }
                                                           )
            bsse_subs['config_ghost_A_and_real_B'] = Section(name = 'CONFIGURATION', 
                                                            keywords = {'ghost_A_and_real_B':Keyword('for ghost_A and real_B fragments'),
                                                                        'glb_conf':Keyword('GLB_CONF',1,1),
                                                                        'sub_conf':Keyword('SUB_CONF',0,1),
                                                                        'charge':Keyword('CHARGE',int(charge_B)),
                                                                        'multiplicity':Keyword('MULTIPLICITY',int(spin_B)),
                                                                       }
                                                           )            
            force_eval_bsse = Section(name = 'BSSE', subsections = bsse_subs)

            FORCE_EVAL_for_bsse = Section(name = 'FORCE_EVAL', 
                                          subsections = {'subsys':force_eval_subsys_for_bsse,
                                                         'bsse':force_eval_bsse
                                                        })
            
            write_cp2k_inp('add_BSSE',{'global': GLOBAL_for_bsse, 'force_eval':FORCE_EVAL_for_bsse})


        
        elif int(other_settings_index.strip()) == 18:   #using LS_SCF method for calculation
            print('\nLS_SCF method for very large systems, for small systems, not promise the shorter time!')
            print('\nCan be used with DFTB or XTB method\n')
            print('The &SCF part is meaningless in LS_SCF method. Please replace the &SCF part with &LS_SCF part!!!\n')
    
            dft_qs_for_ls_scf = Section(name = 'QS', 
                                        keywords = {'ls_scf':Keyword('LS_SCF','T','\t #use LS_SCF method'), 
                                                   })
            
            use_curvy_steps_sub = input('If to use CURVY_STEPS for difficult SCF convergence, but slower? [y/n]:\n')
            if use_curvy_steps_sub.strip() == 'n':
                dft_ls_scf = Section(name = 'LS_SCF', 
                                     keywords = {'puri_method':Keyword('PURIFICATION_METHOD','TRS4',
                                                                       '\t #purify KS matrix -> density matrix, TRS4-trace resetting 4th order, others: SIGN,TC2,PEXSI'),
                                                 'eps_scf':Keyword('EPS_SCF','1E-07'),
                                                 'eps_filter':Keyword('EPS_FILTER','5E-06'),
                                                 'max_scf':Keyword('MAX_SCF',60),
                                                 'sign_method':Keyword('SIGN_METHOD','NEWTONSCHULZ','\t #for computation of sign matrix, others:PROOT, SUBMATRIX'),
                                                 'sign_order':Keyword('SIGN_ORDER',2,'\t #default value, for computation of the sign matrix'),
                                                 'submatrix_sign_method':Keyword('SUBMATRIX_SIGN_METHOD','NEWTONSCHULZ','\t #others:DIRECT,DIRECT_MUADJ,DIRECT_MUADJ_LOWMEM'),
                                                 'S_preconditioner':Keyword('S_PRECONDITIONER','ATOMIC','\t #others:MOLECULAR-if molecules defined and not large, NONE-if use CURVY_STEPS'),
                                                 'S_inversion':Keyword('S_INVERSION','SIGN_SQRT','\t #or:HOTELLING-use Hotelling iteration, method to compute inverse of S'),
                                                 'S_sqrt_method':Keyword('S_SQRT_METHOD','NEWTONSCHULZ','\t #others:PROOT'),
                                                 'S_sqrt_order':Keyword('S_SQRT_ORDER',3,'\t #order of iteration method for calculation of sqrt of S'),
                                                 'dynamic_threshold':Keyword('#DYNAMIC_THRESHOLD','T','\t #if the threshold for the purification chosen dynamically, T-outputs HOMO/LUMO/gap'),
                                                 'mixing':Keyword('#MIXING',4,'\t #minimal number of density mixing before DIIS, default-2'),
                                                 'mixing_frac':Keyword('MIXING_FRACTION',0.45,'\t #mixing density matrices, smaller value-more stability'),
                                                 'mu':Keyword('#MU',-0.15,'\t #value for chemical potential, i.e. some suitable energy between HOMO and LUMO, no need for TRS4'),
                                                }
                                    )
                
            elif use_curvy_steps_sub.strip() == 'y':
                dft_ls_scf = Section(name = 'LS_SCF', 
                                     keywords = {'puri_method':Keyword('PURIFICATION_METHOD','TRS4',
                                                                       '\t #purify KS matrix -> density matrix, TRS4-trace resetting 4th order, others: SIGN,TC2,PEXSI'),
                                                 'eps_scf':Keyword('EPS_SCF','1E-07'),
                                                 'eps_filter':Keyword('EPS_FILTER','5E-06'),
                                                 'max_scf':Keyword('MAX_SCF',60),
                                                 'sign_method':Keyword('SIGN_METHOD','NEWTONSCHULZ','\t #for computation of sign matrix, others:PROOT, SUBMATRIX'),
                                                 'sign_order':Keyword('SIGN_ORDER',2,'\t #default value, for computation of the sign matrix'),
                                                 'submatrix_sign_method':Keyword('SUBMATRIX_SIGN_METHOD','NEWTONSCHULZ','\t #others:DIRECT,DIRECT_MUADJ,DIRECT_MUADJ_LOWMEM'),
                                                 'S_preconditioner':Keyword('S_PRECONDITIONER','NONE','\t #others:MOLECULAR-if molecules defined and not large, NONE-if use CURVY_STEPS'),
                                                 'S_inversion':Keyword('S_INVERSION','SIGN_SQRT','\t #or:HOTELLING-use Hotelling iteration, method to compute inverse of S'),
                                                 'S_sqrt_method':Keyword('S_SQRT_METHOD','NEWTONSCHULZ','\t #others:PROOT'),
                                                 'S_sqrt_order':Keyword('S_SQRT_ORDER',3,'\t #order of iteration method for calculation of sqrt of S'),
                                                 'dynamic_threshold':Keyword('#DYNAMIC_THRESHOLD','T','\t #if the threshold for the purification chosen dynamically, T-outputs HOMO/LUMO/gap'),
                                                 'mixing':Keyword('#MIXING',4,'\t #minimal number of density mixing before DIIS, default-2'),
                                                 'mixing_frac':Keyword('MIXING_FRACTION',0.45,'\t #mixing density matrices, smaller value-more stability'),
                                                 'mu':Keyword('#MU',-0.15,'\t #value for chemical potential, i.e. some suitable energy between HOMO and LUMO, no need for TRS4'),
                                                },
                                     subsections = {'curvy_steps':Section(name = 'CURVY_STEPS', 
                                                                          section_parameters = ['\t #use curvy-steps to update density matrix'])
                                                   }
                                    )            
            
            DFT = Section(name = 'DFT', subsections = {'qs':dft_qs_for_ls_scf, 'ls_scf':dft_ls_scf})
            FORCE_EVAL = Section(name = 'FORCE_EVAL', subsections = {'dft':DFT})
            
            write_cp2k_inp('using_LS_SCF_method',{'force_eval':FORCE_EVAL})
        
    
        
        elif int(other_settings_index.strip()) == 19:  #using smearing
            print('\nOnly metallic system and small gap systems can use smearing in SCF!!!\n')
            print('Not support for &OT!!!\n')
            print('Please pay attention to your system!!!\n')
    
            scf_smear = Section(name = 'SMEAR', section_parameters = ['ON'], 
                                keywords = {'e_temp':Keyword('ELECTRONIC_TEMPERATURE',300), 
                                            'method': Keyword('METHOD','FERMI_DIRAC'),
                                            'window_size':Keyword('WINDOW_SIZE','[eV]',0.3,'\t #size of the energy window centred at the Fermi level')
                                           })
            
            dft_scf = Section(name = 'SCF', keywords = {'added_mos': Keyword('ADDED_MOS',20, '\t #should be used for smearing, -1 for all')}, 
                              subsections = {'scf_smear':scf_smear,
                                             'scf_diag':scf_diag(), 
                                             'scf_mixing':scf_mixing()})
            
            force_eval_dft = Section(name = 'DFT', subsections = {'dft_scf': dft_scf})
            FORCE_EVAL_for_smear = Section(name = 'FORCE_EVAL', 
                                           subsections = {'force_eval_dft': force_eval_dft})
            
            write_cp2k_inp('using_smear_in_scf',{'FORCE_EVAL':FORCE_EVAL_for_smear})
    
    
        
        elif int(other_settings_index.strip()) == 20:    # DFT + U with ramping and enforcing occupation
            print('\n Currently CP2K cannot support &KPOINTS within DFT+U !!!\n')
            print('Please notice your &KPOINTS section set!!!\n')
            print('You should use large supercell!!!!\n')
            print('Remenber to use UKS for spin-polarized calculation!!!\n')
            
            new_element_list = atomic_choose()
            new_car_coords = {}
            for x_i in range(len(cartesian_coords)):
                new_car_coords[x_i] = Keyword('{new_element}'.format(new_element = new_element_list[x_i]),'  ', 
                                              f'{cartesian_coords[x_i][0]:.8f}', '  ',
                                              f'{cartesian_coords[x_i][1]:.8f}', '  ',
                                              f'{cartesian_coords[x_i][2]:.8f}')
                new_car_coords
            

            
            new_element_set = list(set(new_element_list))
            print('\nCurrent newly defined elements set:\n',new_element_set,'\n')
            
            elements_true_inp = input('\nCorresponding actual symbols are ? e.g. Fe,Co,Ni, type in {} elements:\n'.format(len(new_element_set)))
            elements_true = [x_j.strip() for x_j in elements_true_inp.split(',')]
            print()
            
            
            subsus_new_subs = {}
            subsus_new_subs['super_cell_topo'] = Section(name = 'TOPOLOGY', keywords = {'multi_cell':Keyword('#MULTIPLE_UNIT_CELL',2,2,2)})
            subsus_new_subs['super_cell_cell'] = Section(name = 'CELL', keywords = {'multi_cell':Keyword('#MULTIPLE_UNIT_CELL',2,2,2)})
            subsus_new_subs['new_COORD'] = Section(name = 'COORD',keywords = new_car_coords)
            
            kind_subs = {}
            dft_plus_u_subs = {}
            dft_plus_u_subs['enforce_occupation'] = Section(name = 'ENFORCE_OCCUPATION', 
                                                            keywords = {'max_scf':Keyword('MAX_SCF',15,'\t #effective enforce steps'), 
                                                                       'orbitals':Keyword('ORBITALS','to be specified', '\t #e.g. -3 -1'), 
                                                                       'nelec':Keyword('NELEC','to be specified', '\t #e.g. 2 0'), 
                                                                        'smear': Keyword('SMEAR','T')})
            kind_subs['DFT_PLUS_U'] = Section(name = 'DFT_PLUS_U', 
                                         keywords = {'L': Keyword('L','to be specified','\t #0-s, 1-p, 2-d, 3-f,4-g, which orbital to plus U'), 
                                                     'Ueff': Keyword('U_MINUS_J','[eV]','to be specified','\t #effective U value'), 
                                                     'U ramping': Keyword('#U_RAMPING','[eV]',0.5,'\t #if U ramping, need correction'), 
                                                     'eps_U_ramping': Keyword('#EPS_U_RAMPING','1E-04','\t #ramping convergence')
                                                    }, 
                                             subsections = dft_plus_u_subs)
    
            for x_i in range(len(elements_true)):            
                subsus_new_subs[int(x_i)] = Section(name = 'KIND', 
                                                 section_parameters = [new_element_set[int(x_i)]],
                                                 keywords = {'element': Keyword('ELEMENT', elements_true[x_i]), 
                                                             'basis_set': Keyword('BASIS_SET', 'DZVP-MOLOPT-SR-GTH'), 
                                                             'potential': Keyword('POTENTIAL', 'GTH-PBE')}, 
                                                    subsections = kind_subs)
                subsus_new_subs
                
            force_eval_new_subs = {}
            force_eval_new_subs['SUBSYS'] = Section(name = 'SUBSYS', subsections = subsus_new_subs)
    
            dft_print_plus_u = Section(name = 'PLUS_U', 
                                       subsections = {'each': Section(name = 'EACH', keywords = {'qs_scf': Keyword('QS_SCF',1)})})
    
            force_eval_new_subs['DFT'] = Section(name = 'DFT',
                                                 subsections = {'print': Section(name = 'PRINT', subsections = {'plus_u': dft_print_plus_u})})
            FORCE_EVAL_new = Section(name = 'FORCE_EVAL',subsections = force_eval_new_subs)
            print()
            write_cp2k_inp('dft_plus_u_with_occupation_control',{'FORCE_EVAL':FORCE_EVAL_new})

    
    
        elif int(other_settings_index.strip()) == 21:   #change PSOLVER for &DFT
            psolver_dict = {1:'PERIODIC', 
                            2:'MT',
                            3:'WAVELET'
                           }
            
            print('\nAvailable PSOLVER in &DFT:\n')
            print(yaml.dump(psolver_dict, sort_keys = False, default_flow_style = False))
            
            x_psolver = input('\nPlease choose the PSOLVER, e.g. 1:\n')
            
            if int(x_psolver.strip()) == 1:    #PERIODIC psolver
                ewald_subs = {}
                ewald_subs['multipoles'] = Section(name = 'MULTIPOLES', section_parameters = ['T \t #use of multipoles in the treatment of the electrostatics'],
                                                   keywords = {'max_multipole_expansion':Keyword('MAX_MULTIPOLE_EXPANSION','QUADRUPOLE','\t #maximum level of multipoles expansion for electrostatics, others: CHARGE, DIPOLE')}
                                                  )
                poisson_subs = {}
                poisson_subs['ewald'] = Section(name = 'EWALD', section_parameters = ['\t #controlling electrostatic only for CLASSICAL MM'],
                                keywords = {'ewald_type':Keyword('EWALD_TYPE','SPME','\t #recommended-smooth particle mesh using beta-Euler splines'),
                                            'gmax':Keyword('GMAX', int(2 * np.rint(cell_length_a)), int(2 * np.rint(cell_length_b)), int(2 * np.rint(cell_length_c)),
                                                           '\t #number of grid points-SPME and EWALD')
                                           },
                                                subsections = ewald_subs
                                               )
                dft_poisson = Section(name = 'POISSON', 
                                      keywords = {'periodic':Keyword('PERIODIC','XYZ','\t #should match with that in &CELL'), 
                                                  'psolver':Keyword('PSOLVER','PERIODIC')
                                                 },
                                      subsections = poisson_subs
                                     )
                dft_subs = {}
                dft_subs['poisson'] = dft_poisson
                force_eval_dft = Section(name = 'DFT', subsections = dft_subs)
                FORCE_EVAL = Section(name = 'FORCE_EVAL',subsections = {'force_eval_dft':force_eval_dft})
                write_cp2k_inp('change_dft_psolver_to_PERIODIC',{'force_eval_new':FORCE_EVAL})


            elif int(x_psolver.strip()) == 2:  # MT psolver
                dft_poisson = Section(name = 'POISSON', 
                                      keywords = {'periodic':Keyword('PERIODIC','XYZ','\t #should be corrected to your system, for 0D and 2D, and match with that in &CELL'), 
                                                  'remind':Keyword('#results are completely wrong if the cell is smaller than twice the cluster size'),
                                                  'psolver':Keyword('PSOLVER','MT')}, 
                                      subsections = {'mt':Section(name = 'MT', 
                                                                  keywords = {'alpha':Keyword('ALPHA',7.0,'\t #default, convergence parameter ALPHA*RMIN'), 
                                                                              'REL_CUTOFF':Keyword('REL_CUTOFF',2.0,'\t #default value')
                                                                             }
                                                                 ),
                                                     'ewald':Section(name = 'EWALD', 
                                                                     keywords = {'ewald_type':Keyword('EWALD_TYPE','SPME','\t #recommended-smooth particle mesh using beta-Euler splines'),
                                                                                 'gmax':Keyword('GMAX', int(2 * np.rint(cell_length_a)), int(2 * np.rint(cell_length_b)), int(2 * np.rint(cell_length_c)),
                                                                                                '\t #number of grid points-SPME and EWALD')
                                                                                }
                                                                    ),
                                                     'multipoles' : Section(name = 'MULTIPOLES', section_parameters = ['T'],
                                                                            keywords = {'max_multipole_expansion':Keyword('MAX_MULTIPOLE_EXPANSION','QUADRUPOLE','\t #maximum level of multipoles expansion for electrostatics, others: CHARGE, DIPOLE')}
                                                  )
                                                    }
                                     )

                print_mt_subs = {}
                EACH = Section(name = 'EACH', 
                               keywords = {'qs_scf':Keyword('QS_SCF',0,'\t #do not print any in scf'),
                                           'geo_opt':Keyword('GEO_OPT',0,'\t #do not print any in geo_opt'),
                                           'cell_opt':Keyword('CELL_OPT',0,'\t #do not print any in cell_opt')
                                          }
                              )
                print_mt_subs['e_den_cube'] = Section(name = 'E_DENSITY_CUBE', 
                                                      keywords = {'remind':Keyword('#use this tag to monitor the electronic density, especially for MT'),
                                                                  'add_last':Keyword('ADD_LAST', 'NUMERIC','\t #only print last, even each set to 0'),
                                                                  'common_iter_levels':Keyword('COMMON_ITERATION_LEVELS',0,'\t #default value'),
                                                                  'stride':Keyword('STRIDE',2,2,2),
                                                                 },
                                                      subsections = {'each':EACH}
                                                     )
                dft_print_for_MT = Section(name = 'PRINT', subsections = print_mt_subs)
                
                dft_subs = {}
                dft_subs['poisson'] = dft_poisson
                dft_subs['print'] = dft_print_for_MT
                
                force_eval_dft = Section(name = 'DFT', subsections = dft_subs)
                FORCE_EVAL = Section(name = 'FORCE_EVAL',
                                     subsections = {'force_eval_dft':force_eval_dft}
                                    )
                write_cp2k_inp('change_dft_psolver_to_MT',{'force_eval_new':FORCE_EVAL})

            
            elif int(x_psolver.strip()) == 3:  # WAVELET psolver
                poisson_subs = {}
                poisson_subs['wavlet'] = Section(name = 'WAVELET', 
                                                 keywords = {'scf_type':Keyword('SCF_TYPE',40,'\t #possible values:8,14,16,20,24,30,40,50,60,100')})
    
                poisson_subs['ewald'] = Section(name = 'EWALD',
                                                keywords = {'ewald_type':Keyword('EWALD_TYPE','SPME','\t #recommended-smooth particle mesh using beta-Euler splines'),
                                                            'gmax':Keyword('GMAX', int(2 * np.rint(cell_length_a)), int(2 * np.rint(cell_length_b)), int(2 * np.rint(cell_length_c)),
                                                                                                '\t #number of grid points-SPME and EWALD')
                                                           })
                poisson_subs['multipoles'] = Section(name = 'MULTIPOLES',
                                                     section_parameters = ['T \t ##use of multipoles in the treatment of the electrostatics'],
                                                     keywords = {'max_multipole_expansion':Keyword('MAX_MULTIPOLE_EXPANSION','QUADRUPOLE',
                                                                                                   '\t #maximum level of multipoles expansion for electrostatics, others: CHARGE, DIPOLE')}
                                                    )
                
                dft_poisson = Section(name = 'POISSON', 
                                      keywords = {'periodic':Keyword('PERIODIC','XYZ','\t #should be corrected to your system, 0D,2D(only XZ),3D, and match with that in &CELL'), 
                                                  'remind':Keyword('#no need for large cell, but with cubic box and molecule in center, suitable for molecule calc.'),
                                                  'psolver':Keyword('PSOLVER','WAVELET')}, 
                                      subsections = poisson_subs,
                                     )
                
                subsys_subs = {}
                subsys_subs['topology'] = Section(name = 'TOPOLOGY',
                                                  subsections = {'center':Section(name = 'CENTER_COORDINATES', 
                                                                                  section_parameters = ['T \t #recommend to use this tag in PSOLVER of MT'])
                                                                }
                                                 )
                force_eval_subsys = Section(name = 'SUBSYS',subsections = subsys_subs)
                
                dft_subs = {}
                dft_subs['poisson'] = dft_poisson
                force_eval_dft = Section(name = 'DFT', subsections = dft_subs)
                FORCE_EVAL = Section(name = 'FORCE_EVAL',subsections = {'subsys':force_eval_subsys,'dft':force_eval_dft})
                write_cp2k_inp('change_dft_psolver_to_WT',{'force_eval_new':FORCE_EVAL})
            

        elif int(other_settings_index.strip()) == 22:   #add electric field
            e_field_methods = {1:'External field on a grid',
                               2:'Periodic electric field on Gaussian basis',
                               3:'EFIELD for real time propagation'
                              }
            
            print('\nAvailable external fields in CP2K:\n')
            print(yaml.dump(e_field_methods, sort_keys = False, default_flow_style = False))  

            e_field_index = input('\nPlease choose the method to perform external field, e.g. 1:\n')

            if int(e_field_index.strip()) == 1:    #choose the electrostatic external potential
                print('This method is to add the electrostatic external potential dependent on the atomic positions (X,Y,Z)')
                print('Support grid, only works with DFT based methods (GPW/GAPW)')
                print('Note that this is not periodic! Can only be used with molecules and slabs!')
                print('Multimat currently assumes you want to add the electric field along Z direction!')

                e_field_val = input('\nType in the value of strength of electric field [eV/angstrom], e.g. 0.2:\n')
                
                external_potential_section = Section(name = 'EXTERNAL_POTENTIAL', 
                                                     keywords = {'function':Keyword('FUNCTION','(A/B)*Z'), 
                                                                 'values':Keyword('VALUES','[eV]','{}'.format(e_field_val),'[angstrom]','1.0'),
                                                                 'parameters':Keyword('PARAMETERS','A','B'),
                                                                }
                                                    )
                dft_for_field = Section(name = 'DFT', subsections = {'ext_field':external_potential_section})
                force_eval_for_field = Section(name = 'FORCE_EVAL',subsections = {'dft_field':dft_for_field})
                
                write_cp2k_inp('add_external_field',{'FORCE_EVAL':force_eval_for_field})
            
            elif int(e_field_index.strip()) == 2:     #choose the periodic electric field
                print('This method applies electric fields that are calculated analytically in the Gaussian basis')
                print('Periodic electric field uses the Berry phase formalism of the Modern Theory of Polarizablility and can be used for periodic systems')
                print('Only supports OT, and not for RTP (real-time propagation) or EMD, that is RESTART_RTP has to be .FALSE. when restarting the job')

                int_a_u_val = input('\nType in the intensity value of electric field in [a.u.], e.g. 0.1\n')
                periodic_efield = Section(name = 'PERIODIC_EFIELD',
                                          keywords = {'displace_field':Keyword('DISPLACEMENT_FIELD','F','\t #use the displacement field formulation'),
                                                      'd_filter':Keyword('#D_FILTER','1.0','1.0','1.0','\t #filter for displacement field (x,y,z-dirction)'),
                                                      'intensity':Keyword('INTENSITY','{}'.format(int_a_u_val),'\t #intensity of the electric field in a.u.'),
                                                      'polarisation':Keyword('POLARISATION','0.0','0.0','1.0', '\t #polarisation vector of electric field'),
                                                     }
                                         )
                
                dft_for_field = Section(name = 'DFT', subsections = {'periodic_efield':periodic_efield})
                force_eval_for_field = Section(name = 'FORCE_EVAL',subsections = {'dft_field':dft_for_field})   
                
                write_cp2k_inp('add_periodic_efield',{'FORCE_EVAL':force_eval_for_field})

            elif int(e_field_index.strip()) == 2:     #choose the efield, this is a complex method in CP2K
                print('This method is for finite, time dependent electric fields')
                print('The field can be applied analytically to the GTO')
                print('For static fields use EXTERNAL_POTENTIAL')

                use_RTP = input('\nIf use time dependent propagation? [y/n]\n')
                if use_RTP == 'n': 
                    int_a_u_val = input('\nType in the intensity value of electric field in [a.u.], e.g. 0.1\n')                    
                    efield = Section(name = 'EFIELD', 
                                     keywords = {'intensity':Keyword('INTENSITY','{}'.format(int_a_u_val), '\t #intensity of the electric field [a.u.]'),
                                                 'polarisation':Keyword('POLARISATION','0.0','0.0','1.0', '\t #polarisation vector of electric field')
                                                }
                                    )

                    dft_for_field = Section(name = 'DFT', subsections = {'periodic_efield':efield})
                    force_eval_for_field = Section(name = 'FORCE_EVAL',subsections = {'dft_field':dft_for_field})   
                    
                    write_cp2k_inp('add_efield',{'FORCE_EVAL':force_eval_for_field})

                elif use_RTP == 'y':
                    int_a_u_val = input('\nType in the intensity value of electric field in [a.u.], e.g. 0.1\n')                    
                    efield = Section(name = 'EFIELD', 
                                     keywords = {'intensity':Keyword('INTENSITY','{}'.format(int_a_u_val), '\t #intensity of the electric field [a.u.]'),
                                                 'envelop':Keyword('ENVELOP','CONSTANT','default-no envelop function used, others:GAUSSIAN, RAMP, CUSTOM'),
                                                 'phase':Keyword('#PHASE','1.0','\t #phase offset of the cosine given in multiples of pi, for RTP'),
                                                 'vec_pot_initial':Keyword('#VEC_POT_INITIAL','0.0','0.0','0.0','\t #initial value of vector potential (for velocity gauge)'),
                                                 'wavelength':Keyword('WAVELENGTH','1.0','\t #wavelength of efield for RTP'),
                                                 'polarisation':Keyword('POLARISATION','0.0','0.0','1.0', '\t #polarisation vector of electric field')
                                                }
                                    )

                    dft_for_field = Section(name = 'DFT', subsections = {'periodic_efield':efield})
                    force_eval_for_field = Section(name = 'FORCE_EVAL',subsections = {'dft_field':dft_for_field})   
                    
                    write_cp2k_inp('add_efield',{'FORCE_EVAL':force_eval_for_field})



        
        elif int(other_settings_index.strip()) == 23:   #add magnetization keyword for each kind
            print('\nRemember to determine the UKS tag!!!\n')
            
            new_element_list = atomic_choose()
            new_car_coords = {}
            for x_i in range(len(cartesian_coords)):
                new_car_coords[x_i] = Keyword('{new_element}'.format(new_element = new_element_list[x_i]),'  ', 
                                              f'{cartesian_coords[x_i][0]:.8f}', '  ',
                                              f'{cartesian_coords[x_i][1]:.8f}', '  ',
                                              f'{cartesian_coords[x_i][2]:.8f}')
                new_car_coords
            
            print()
            new_element_set = list(set(new_element_list))
            print('current newly defined elements set:\n',new_element_set,'\n')
            
            elements_true_inp = input('Corresponding actual symbols are ? e.g. Fe,Co,Ni, type in {} elements:\n'.format(len(new_element_set)))
            elements_true = [x_j.strip() for x_j in elements_true_inp.split(',')]
            print()
            
            magmoms_inp = input('Type in the magnetizations for these {} elements :e.g. 1.2,2.2,3.2\n'.format(len(new_element_set)))
            magmoms = [y_j.strip() for y_j in magmoms_inp.split(',')]
            
            force_eval_new_subs = {}
            subsus_new_subs = {}
            
            
            subsus_new_subs['new_COORD'] = Section(name = 'COORD',keywords = new_car_coords)
            
            for x_i in range(len(elements_true)):
                subsus_new_subs[int(x_i)] = Section(name = 'KIND', 
                                                 section_parameters = [new_element_set[int(x_i)]],
                                                 keywords = {'element': Keyword('ELEMENT', elements_true[x_i]), 
                                                             'basis_set': Keyword('BASIS_SET', 'DZVP-MOLOPT-SR-GTH'), 
                                                             'potential': Keyword('POTENTIAL', 'GTH-PBE'),
                                                             'magmom': Keyword('MAGNETIZATION', magmoms[x_i])})
                subsus_new_subs
    
            force_eval_new_subs['SUBSUS_new'] = Section(name = 'SUBSUS', subsections = subsus_new_subs)
            FORCE_EVAL_new = Section(name = 'FORCE_EVAL',subsections = force_eval_new_subs)
            print()
            write_cp2k_inp('add_magnetization_each_kind',{'FORCE_EVAL':FORCE_EVAL_new})
    
    
        
        elif int(other_settings_index.strip()) == 24:  #add &BS within magnetization calculation
            new_element_list = atomic_choose()
            new_car_coords = {}
            for x_i in range(len(cartesian_coords)):
                new_car_coords[x_i] = Keyword('{new_element}'.format(new_element = new_element_list[x_i]),'  ', 
                                              f'{cartesian_coords[x_i][0]:.8f}','  ', 
                                              f'{cartesian_coords[x_i][1]:.8f}','  ',
                                              f'{cartesian_coords[x_i][2]:.8f}')
                new_car_coords
            
            print()
            
            new_element_set = list(set(new_element_list))
            print('\nCurrent newly defined elements set:\n',new_element_set,'\n')
            
            elements_true_inp = input('\nCorresponding actual symbols are ? e.g. Fe,Co,Ni, type in {} elements:\n'.format(len(new_element_set)))
            elements_true = [x_j.strip() for x_j in elements_true_inp.split(',')]
            print()
    
            force_eval_new_subs = {}
            subsus_new_subs = {}
            
            subsus_new_subs['new_COORD'] = Section(name = 'COORD', keywords = new_car_coords)
            
            for x_i in range(len(elements_true)):
                subsus_new_subs[int(x_i)] = Section(name = 'KIND', 
                                                    section_parameters = [new_element_set[int(x_i)]],
                                                    keywords = {'element': Keyword('ELEMENT', elements_true[x_i]), 
                                                                'basis_set': Keyword('BASIS_SET', 'DZVP-MOLOPT-SR-GTH'), 
                                                                'potential': Keyword('POTENTIAL', 'GTH-PBE')
                                                               }, 
                                                    subsections = {'BS': kind_bs(new_element_set[int(x_i)])}
                                                   )
                subsus_new_subs
    
            force_eval_new_subs['SUBSUS_new'] = Section(name = 'SUBSUS', subsections = subsus_new_subs)
            FORCE_EVAL_new = Section(name = 'FORCE_EVAL',subsections = force_eval_new_subs)
            print()
            write_cp2k_inp('using_BS_for_each_kind',{'FORCE_EVAL':FORCE_EVAL_new})
    
    
    
        elif int(other_settings_index.strip()) == 25:  #make supercell calculation
            multi_inp = input('\nPlease type in the supercell number: e.g. 2,2,2\n')
            super_num = multi_inp.strip().split(',')
            m_x = int(super_num[0].strip())
            m_y = int(super_num[1].strip())
            m_z = int(super_num[2].strip())
            
            force_eval_subsys_cell = Section(name = 'CELL', 
                                             keywords = {'multi_unit_cell':Keyword('MULTIPLE_UNIT_CELL',m_x,m_y,m_z,'\t #in order of X,Y,Z')})
            force_eval_subsys_topology = Section(name = 'TOPOLOGY', 
                                                 keywords = {'multi_unit_lattice':Keyword('MULTIPLE_UNIT_CELL',m_x,m_y,m_z,'\t #in order of X,Y,Z')})
            force_eval_subsys_subs = {}
            force_eval_subsys_subs['topology'] = force_eval_subsys_topology
            force_eval_subsys_subs['cell'] = force_eval_subsys_cell
    
            force_eval_subsys = Section(name = 'SUBSYS', subsections = force_eval_subsys_subs)
            FORCE_EVAL_new = Section(name = 'FORCE_EVAL', subsections = {'SUBSYS':force_eval_subsys})
    
            write_cp2k_inp('make_multiple_unit_cell',{'FORCE_EVAL':FORCE_EVAL_new})

        
        
        elif int(other_settings_index.strip()) == 26:  #add dipole correction along Z for slab
            force_eval_dft = Section(name = 'DFT', 
                                     keywords = {'surface-dipole-corr':Keyword('SURFACE_DIPOLE_CORRECTION','T'), 
                                                 'corr-direction':Keyword('SURF_DIP_DIR','Z'), 
                                                 'dip_position':Keyword('SURF_DIP_POS','-1.0','\t #default-suitable value-a position that has minimum electron density on the grid')
                                                }
                                    )
            FORCE_EVAL = Section(name = 'FORCE_EVAL', subsections = {'dft':force_eval_dft})
            write_cp2k_inp('add_dipole_correction_Z',{'force_eval':FORCE_EVAL})
    
    
            
        elif int(other_settings_index.strip()) == 27:         #calculate bandstructure in &DFT and print
            structure = Structure.from_file(cif_filename)
            
            symprec_inp = input('\nType in the symprec value for symmetry, 0.1 is recommended, not use too small value:\n')
            symprec_val = float(symprec_inp.strip())
            
            symmetry_add = SpacegroupAnalyzer(structure, symprec = symprec_val, angle_tolerance = 5.0)
            print('\nFind space group & number:', symmetry_add.get_space_group_symbol(), ' ', symmetry_add.get_space_group_number())        
            
            primitive_cell = symmetry_add.find_primitive()
            k_path_seek = KPathSetyawanCurtarolo(primitive_cell, symprec = symprec_val)
    
            
            high_ks = copy.deepcopy(k_path_seek.kpath['kpoints'])
            high_ks['G'] = [0.0,0.0,0.0]
            high_ks.pop('\\Gamma')          #replace '\\Gamma' in 'G'
    
            high_ks_for_print = copy.deepcopy(high_ks)
            for kpts in high_ks_for_print:
                high_ks_for_print[kpts] = str(np.array(high_ks_for_print[kpts]).astype(float))
            high_ks_for_print                  #for print the high-symmetry k points dictionary
    
    
            high_k_path = copy.deepcopy(k_path_seek.kpath['path'])         #discontinuous k-path
            for x in range(len(high_k_path)):
                for y in range(len(high_k_path[x])):
                    if high_k_path[x][y] == '\\Gamma':
                        high_k_path[x][y] = 'G'
            
            high_k_path_continuous = []
            for x in range(len(high_k_path)):
                for y in high_k_path[x]:
                    high_k_path_continuous.append(y)
            high_k_path_continuous                                  #continuous k-path
    
            print('\nBrillouin zone high-symmetry kpoints:\n')
            print(yaml.dump(high_ks_for_print, sort_keys = False, default_flow_style = False))
            print('Recommended k_path:\n',high_k_path,'\n')
            
           
            print_band_structure_subs = {}
            
            for x_a in range(len(high_k_path)):
                kpoint_set_kwds = {}
                kpoint_set_kwds['unit'] = Keyword('UNIT','B_VECTOR')
                kpoint_set_kwds['npoints'] = Keyword('NPOINTS',10,'\t #number of kpoints between two high k points')
                for x_b in range(len(high_k_path[x_a])):
                    kpoint_set_kwds[x_b] = Keyword('SPECIAL_POINT  ', 
                                                   high_k_path[x_a][x_b],'  ', 
                                                   '%.8f' % high_ks[high_k_path[x_a][x_b]][0],'  ', 
                                                   '%.8f' % high_ks[high_k_path[x_a][x_b]][1],'  ', 
                                                   '%.8f' % high_ks[high_k_path[x_a][x_b]][2],'  ',)
                
                print_band_structure_subs[x_a] = Section(name = 'KPOINT_SET', keywords = kpoint_set_kwds)
    
            print_band_structure = Section(name = 'BAND_STRUCTURE', 
                                           keywords = {'file_name':Keyword('FILE_NAME','{}.bs'.format(project_name)),
                                                       'added_mos':Keyword('ADD_MOS',20,'\t #for additional MOs, -1 for all'),
                                                      },
                                           subsections = print_band_structure_subs
                                          )
            
            dft_print_subs = {}
            dft_print_subs['band_structure'] = print_band_structure
            
            dft_print = Section(name = 'PRINT', subsections = dft_print_subs)
            
            dft_subs = {}
            dft_subs['print'] = dft_print
            force_eval_subs = {}
            force_eval_subs['dft'] = Section(name = 'DFT', subsections = dft_subs)
            FORCE_EVAL_for_print = Section(name = 'FORCE_EVAL', subsections = force_eval_subs)
            
            #view the Brillouin zone for high-symmetry k path
            path_defined = ''.join([x_i for x_i in high_k_path_continuous ])
            ase_band_path = bandpath(path = path_defined, npoints = 50, cell = primitive_cell.lattice.matrix,special_points = high_ks)
            ase_band_path.plot()
            
            write_cp2k_inp('dft_print_bs', {'FORCE_EVAL': FORCE_EVAL_for_print})
    
    
        
        elif int(other_settings_index.strip()) == 28:               #print DOS,PDOS,LDOS in &DFT
            print('\nCP2K currently do not support PDOS within k points!!!\n')
            print('CP2K supports the DOS within k points!!!\n')
            print('Please use the supercell for PDOS!!!')
            
            GLOBAL = global_section('dos','ENERGY')
            
            dft_print_subs = {}
            dft_print_subs['mo'] = Section(name = 'MO', 
                                           keywords = {'energies':Keyword('ENERGIES','T'), 
                                                       'occupation_numbers':Keyword('OCCUPATION_NUMBERS','T'),
                                                       'filename':Keyword('FILENAME','dft_mo'),
                                                       'iter':Keyword('COMMON_ITERATION_LEVELS',0),
                                                       'add_last':Keyword('ADD_LAST','NUMERIC'),
                                                      },
                                           subsections = {'each':Section(name = 'EACH', 
                                                                         keywords = {'QS_SCF':Keyword('QS_SCF',0)}
                                                                        )
                                                         }
                                          )
            dft_print_subs['molden'] = Section(name = 'MO_MOLDEN',
                                               keywords = {'ndigits':Keyword('NDIGITS',9)})
            dft_print_subs['dos'] = Section(name = 'DOS', 
                                            keywords = {'ndigits':Keyword('NDIGITS',6)})
    
            print_pdos_subs = {}
            print_pdos_subs['ldos'] = Section(name = 'LDOS',
                                              keywords = {'components':Keyword('COMPONENTS','T'), 
                                                          'list':Keyword('LIST',15,16,'\t #to be specified, the atomic index you want to project')})
            dft_print_subs['pdos'] = Section(name = 'PDOS', 
                                             keywords = {'remind':Keyword('#PDOS sampling only for Gamma point, use supercell'),
                                                         'components':Keyword('COMPONENTS','T','\t #print pdos of each element'), 
                                                         'nlumo':Keyword('NLUMO',1500,'\t #Number of virtual orbitals,-1=all, too many may cause a Cholesky error')},
                                             subsections = print_pdos_subs,
                                            )
            
            dft_subs = {}
            dft_subs['dft_print'] = Section(name = 'PRINT',subsections = dft_print_subs)
            dft_subs['dft_scf'] = Section(name = 'SCF',keywords = {'added_mos':Keyword('ADDED_MOS',800, '\t #additional MOs, -1 for all')})
            
            force_eval_subs = []
            subsys_subs = []
            subsys_subs['topology'] = Section(name = 'TOPOLOGY', keywords = {'multi_cell':Keyword('#MULTIPLE_UNIT_CELL',2,2,2)})
            subsys_subs['cell'] = Section(name = 'CELL', keywords = {'multi_cell':Keyword('#MULTIPLE_UNIT_CELL',2,2,2)})
            force_eval_subs['subsys'] = Section(name = 'SUBSYS', subsections = subsys_subs)
            force_eval_subs['dft'] = Section(name = 'DFT',
                                             keywords = {'uks':Keyword('#UKS','T','\t #if spin-polarized, switch on')},
                                             subsections = dft_subs)
            
            FORCE_EVAL = Section(name = 'FORCE_EVAL', subsections = force_eval_subs)

            inp_sections_dict = {}
            inp_sections_dict['global'] = GLOBAL
            inp_sections_dict['force_eval'] = FORCE_EVAL
            
            write_cp2k_inp('add_dos',inp_sections_dict)
            
            
    
        elif int(other_settings_index.strip()) == 30:               #print other things in &DFT
            each = {'EACH':Section(name = 'EACH',keywords = {'qs_scf':Keyword('#QS_SCF',10), 
                                                             'geo_opt':Keyword('#GEO_OPT',10), 
                                                             'cell_opt':Keyword('#CELL_OPT',10), 
                                                             'md':Keyword('#MD',10)})}
            dft_print_subs = {}

            dft_print_subs['mo_cubes'] = Section(name = 'MO_CUBES', 
                                                 section_parameters = ['ON'], 
                                                 keywords = {'nhomo':Keyword('NHOMO',5,'\t #-1 = all'), 
                                                             'nlumo':Keyword('NLUMO',5,'\t #-1 = all'), 
                                                             'stride':Keyword('STRIDE',2,2,2), 
                                                             'write_cube':Keyword('WRITE_CUBE','T'),
                                                             'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                             'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                            }, 
                                                 subsections = each)
            
            dft_print_subs['mo'] = Section(name = 'MO',
                                           section_parameters = ['ON'], 
                                           keywords = {'ndigits':Keyword('NDIGITS',8), 
                                                       'energies':Keyword('ENERGIES','T'), 
                                                       'coefficients':Keyword('COEFFICIENTS','T'),
                                                       'occupation_numbers':Keyword('OCCUPATION_NUMBERS','T'),
                                                       'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                       'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                       'filename':Keyword('FILENAME','dft_mo_info'),
                                                       'mo_index_range':Keyword('#MO_INDEX_RANGE',10,15,'\t #index range,can print fermi energy for &OT')}, 
                                           subsections = each)
            
            dft_print_subs['mo_molden'] = Section(name = 'MO_MOLDEN', 
                                                  section_parameters = ['ON'], 
                                                  keywords = {'ndigits':Keyword('NDIGITS',8), 
                                                              'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                              'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                              'remind':Keyword('#only include information from Gamma point'),
                                                             }, 
                                                  subsections = each)
            
            dft_print_subs['v_hartree_cube'] = Section(name = 'V_HARTREE_CUBE', 
                                                       section_parameters = ['ON'], 
                                                       keywords = {'stride':Keyword('STRIDE',2),
                                                                   'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                                   'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                                  },
                                                       subsections = each
                                                      )
            
            dft_print_subs['efield_cube'] = Section(name = 'EFIELD_CUBE', 
                                                    section_parameters = ['ON'], 
                                                 keywords = {'stride': Keyword('STRIDE',2),
                                                             'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                             'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                            },
                                                    subsections = each
                                                   )
            
            dft_print_subs['elf_cube'] = Section(name = 'ELF_CUBE', 
                                                 section_parameters = ['ON'], 
                                                 keywords = {'stride': Keyword('STRIDE',2,2,2),
                                                             'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                             'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                            },
                                                 subsections = each
                                                )
    
            dft_print_subs['e_density_cube'] = Section(name = 'E_DENSITY_CUBE', 
                                                       section_parameters = ['ON'], 
                                                       keywords = {'stride':Keyword('STRIDE',2,2,2),
                                                                   'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                                   'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                                  }, 
                                                       subsections = each)

            dft_print_subs['total_density_cube'] = Section(name = 'TOTAL_DENSITY_CUBE', 
                                                           section_parameters = ['ON'], 
                                                           keywords = {'stride':Keyword('STRIDE',2,2,2),
                                                                       'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                                       'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                                      },
                                                           subsections = each
                                                          )
            dft_print_subs['lowdin'] = Section(name = 'LOWDIN', 
                                               section_parameters = ['ON'], 
                                               keywords = {'print_all':Keyword('PRINT_ALL','F'), 
                                                           'print_gop':Keyword('PRINT_GOP','F'),
                                                           'filename':Keyword('FILENAME','lowdin_pop'),
                                                           'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                           'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                          }, 
                                               subsections = each
                                              )
            dft_print_subs['mulliken'] = Section(name = 'MULLIKEN', 
                                                 section_parameters = ['ON'], 
                                                 keywords = {'print_all':Keyword('PRINT_ALL','F'), 
                                                             'print_gop':Keyword('PRINT_GOP','F'),
                                                             'filename':Keyword('FILENAME','mulliken_pop'),
                                                             'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                             'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print')
                                                            }, 
                                                 subsections = each
                                                )
            dft_print_subs['hirshfeld'] = Section(name = 'HIRSHFELD', 
                                                  section_parameters = ['ON'], 
                                                  keywords = {'filename':Keyword('FILENAME','hirshfeld_pop'),
                                                              'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                              'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                             }, 
                                                  subsections = each
                                                 )
            dft_print_subs['moment'] = Section(name = 'MOMENT', 
                                               keywords = {'periodic':Keyword('#PERIODIC','T','\t #use Berry phase formula, F-use simple operator-need PERIODIC NONE'), 
                                                           'reference':Keyword('#REFERENCE','COM','\t #reference point to calculate electric moment, COM-center of mass, COAS-center of atomic charges, ZERO-original coordinate system'),
                                                           'magnetic':Keyword('#MAGNETIC','F','\t #calculate magnetic moments, only for isolated system'),
                                                           'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                           'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                           'filename':Keyword('FILENAME','dft_moments'),
                                                          },
                                               subsections = each
                                              )
            dft_print_subs['KS_matrix'] = Section(name = 'KS_CSR_WRITE', 
                                               keywords = {
                                                           'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                           'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                           'filename':Keyword('FILENAME','ks_matrix'),
                                                           'real_space':Keyword('#REAL_SPACE','T','\t #print the KS matrix in real-space instead of k-space'),
                                                           'upper_triangular':Keyword('#UPPER_TRIANGULAR','T','\t #print only the upper triangular part of the matrix')
                                                          },
                                               subsections = each
                                              )

            dft_print_subs['external_potential_cube'] = Section(name = 'EXTERNAL_POTENTIAL_CUBE', 
                                               keywords = {
                                                           'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                           'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                           'stride':Keyword('STRIDE',2,2,2),
                                                          },
                                               subsections = each
                                              )     
            
            dft_print_subs['efield_cube'] = Section(name = 'EFIELD_CUBE', 
                                               keywords = {
                                                           'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                           'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                           'stride':Keyword('STRIDE',2,2,2),
                                                          },
                                               subsections = each
                                              )  

            dft_print_subs['overlap_matrix'] = Section(name = 'S_CSR_WRITE', 
                                               keywords = {
                                                           'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print'),
                                                           'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                           'filename':Keyword('FILENAME','overlap_matrix'),
                                                           'real_space':Keyword('#REAL_SPACE','T','\t #print the KS matrix in real-space instead of k-space'),
                                                           'upper_triangular':Keyword('#UPPER_TRIANGULAR','T','\t #print only the upper triangular part of the matrix')
                                                          },
                                               subsections = each
                                              )     
            
            dft_print_contents_dict = {-1:'mo',
                                       0:'mo_cubes',
                                       1:'mo_molden',
                                       2:'v_hartree_cube',
                                       3:'efield_cube',
                                       4:'elf_cube',
                                       5:'e_density_cube',
                                       6:'total_density_cube',
                                       7:'lowdin',
                                       8:'mulliken',
                                       9:'hirshfeld',
                                       10:'moment',
                                       11:'KS_matrix',
                                       12:'external_potential_cube',
                                       13:'efield_cube',
                                       14:'overlap_matrix',
                                      }
            print('\nAvailable contents in &PRINT of &DFT section:\n')
            print(yaml.dump(dft_print_contents_dict, sort_keys = False, default_flow_style = False))

            print_index_inp = input('\nPlease choose the index(es) to print in &DFT, e.g. 1,2,3\n')
            print_indexes_list = print_index_inp.strip().split(',')

            dft_print_subs_options = {}
            for x_i in print_indexes_list:
                dft_print_subs_options[x_i] = dft_print_subs[dft_print_contents_dict[int(x_i)]]
                
            dft_print = Section(name = 'PRINT',subsections = dft_print_subs_options)
            force_eval_dft = Section(name = 'DFT',subsections = {'dft_print':dft_print})
            FORCE_EVAL = Section(name = 'FORCE_EVAL',subsections = {'force_eval_dft':force_eval_dft})
            
            write_cp2k_inp('add_force_eval_dft_prints',{'FORCE_EVAL':FORCE_EVAL})
            
    
    
        elif int(other_settings_index.strip()) == 31:               #decrease the periodic images for SHORTRANGE
            print('\nThis setting is used for hybrid functional when the POTENTIAL_TYPE is SHORTRANGE!\n')
            print('Not useful for RI-HFX method, suitable for ADMM with Gamma only\n')
            print('Please be careful!!!\n')
            
            hf_periodic = Section(name = 'PERIODIC',
                                  keywords = {'num_of_shells':Keyword('NUMBER_OF_SHELLS',3,'\t #default is -1, can set 0 for 1 shell, 1 for 7shells, 2 for 19 shells, 3 for 27 shells, 4 for 33 shells')})
            xc_hf = Section(name = 'HF',subsections = {'hf_periodic':hf_periodic})
            dft_xc = Section(name = 'XC',subsections = {'xc_hf':xc_hf})
            force_eval_dft = Section(name = 'DFT',subsections = {'dft_xc':dft_xc})
            FORCE_EVAL = Section(name = 'FORCE_EVAL',subsections = {'dft':force_eval_dft})
            
            write_cp2k_inp('decrease_shells_in_SHORTRANGE',{'force_eval':FORCE_EVAL})
            
    
    
        elif int(other_settings_index.strip()) == 33:  #add prints in &MOTION
            EACH = Section(name = 'EACH', keywords = {'cell_opt':Keyword('CELL_OPT',1),
                                                      'geo_opt':Keyword('GEO_OPT',1),
                                                      'qs_scf':Keyword('QS_SCF',10),
                                                      'md':Keyword('MD',10),
                                                      'rot_opt':Keyword('ROT_OPT',1),
                                                      'shell_opt':Keyword('SHELL_OPT',1),
                                                      'tddft_scf':Keyword('TDDFT_SCF',1),
                                                      'xas_scf':Keyword('XAS_SCF',1),
                                                     }
                          )
            
            add_p_motion_subs = {}
            add_p_motion_subs['cell'] = Section(name = 'CELL', keywords = {'ADD_LAST':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                                           'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                                           'filename':Keyword('FILENAME','motion_print_cell'),
                                                                          },
                                                subsections = {'each':EACH}
                                               )
            add_p_motion_subs['forces'] = Section(name = 'FORCES', keywords = {'ADD_LAST':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                                           'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                                           'filename':Keyword('FILENAME','motion_print_forces'),
                                                                               'format':Keyword('FORMAT','XYZ'),
                                                                               'unit':Keyword('UNIT','hartree*bohr^-1')
                                                                          },
                                                subsections = {'each':EACH}
                                               )
            add_p_motion_subs['polar_matrix'] = Section(name = 'POLAR_MATRIX', keywords = {'ADD_LAST':Keyword('ADD_LAST','NUMERIC'),
                                                                           'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                                           'filename':Keyword('FILENAME','motion_print_polar_marrix'),
                                                                          },
                                                subsections = {'each':EACH}
                                               )        
            add_p_motion_subs['restart'] = Section(name = 'RESTART', keywords = {'ADD_LAST':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                                           'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                                                 'backup_copied':Keyword('BACKUP_COPIES',0),
                                                                           'filename':Keyword('FILENAME','motion_print_restart'),
                                                                          },
                                                subsections = {'each':EACH}
                                               )
            add_p_motion_subs['restart_history'] = Section(name = 'RESTART_HISTORY', section_parameters = ['OFF'])
            add_p_motion_subs['stress'] = Section(name = 'STRESS', keywords = {'ADD_LAST':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                                           'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                                           'filename':Keyword('FILENAME','motion_print_stress'),
                                                                          },
                                                subsections = {'each':EACH}
                                               )
            add_p_motion_subs['trajectory'] = Section(name = 'TRAJECTORY', keywords = {'ADD_LAST':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                                                       'charge_beta':Keyword('#CHARGE_BETA','T','\t #default-F,write the MM charges to the BETA field of the PDB file'),
                                                                                       'charge_extended':Keyword('#CHARGE_EXTENDED','T','\t #default-F,write the MM charges to the very last field of the PDB file (starting from column 81)'),
                                                                                       'charge_occu':Keyword('#CHARGE_OCCUP','T','\t #default-F,write the MM charges to the OCCUP field of the PDB file'),
                                                                                       'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                                                       'filename':Keyword('FILENAME','motion_trajectory'),
                                                                                       'format':Keyword('FORMAT','XYZ','\t #others: ATOMIC, DCD, PDB'),
                                                                                       'print_atom_kind':Keyword('#PRINT_ATOM_KIND','T','\t #only for XMOL format, write the atom kind given in the subsys section instead of the element symbol'),
                                                                                       'unit':Keyword('UNIT','angstrom'),
                                                                                      },
                                                subsections = {'each':EACH}
                                               )
            add_p_motion_subs['velocities'] = Section(name = 'VELOCITIES', keywords = {'ADD_LAST':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                                                       'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                                                       'filename':Keyword('FILENAME','motion_print_velocities'),
                                                                                       'format':Keyword('FORMAT','XYZ','\t #others: ATOMIC, DCD, PDB'),
                                                                                       'print_atom_kind':Keyword('#PRINT_ATOM_KIND','T','\t #only for XMOL format, write the atom kind given in the subsys section instead of the element symbol'),
                                                                                       'unit':Keyword('UNIT','bohr*au_t^-1'),
                                                                                      },
                                                subsections = {'each':EACH}
                                               )
            
            add_p_for_motion = Section(name = 'PRINT', subsections = add_p_motion_subs)
            MOTION_added_print = Section(name = 'MOTION', subsections = {'print':add_p_for_motion})
    
            write_cp2k_inp('add_print_for_MOTION',{'MOTION':MOTION_added_print})
    
    
    
        
        elif int(other_settings_index.strip()) == 40:       #using DFT-D correction
            dft_xc_subs = {}

            pot_type_dict = {1:'PAIR_POTENTIAL', 
                             2:'NON_LOCAL'}
            
            print('Currently available potential types:\n')
            print(yaml.dump(pot_type_dict, sort_keys = False, default_flow_style = False))

            dict_x = input('Please choose potential type for vdw, e.g. 1:\n')

            if int(dict_x.strip()) == 1:   #choose the pair potential for vdw
                funct_name = input('\nPlease type in the name of functional:\n')
                
                dft_xc_subs['vdw_potential'] = vdw_pair_potential(pot_type_dict[1],funct_name)

            if int(dict_x.strip()) == 2:   #choose the non local for vdw
                non_local_type_dict = {1:'RVV10',
                                       2:'LMKLL',
                                       3:'DRSLL'
                                      }
                print('\nCurrently available non local vdw potential types:\n')
                print(yaml.dump(non_local_type_dict, sort_keys = False, default_flow_style = False))

                type_x0 = input('\nPlease choose the non local vdw type, e.g. 1:\n')
                
                dft_xc_subs['vdw_potential'] = vdw_non_local(non_local_type_dict[int(type_x0.strip())])

            dft_xc_section = Section(name = 'XC', subsections = dft_xc_subs)

            force_eval_dft = Section(name = 'DFT', subsections = {'dft_xc':dft_xc_section})

            force_eval = Section(name = 'FORCE_EVAL', subsections = {'force_eval_dft':force_eval_dft})
            
            write_cp2k_inp('add_DFT_D',{'FORCE_EVAL':force_eval})
        
    
    
        elif int(other_settings_index.strip()) == 41:   #calculate IR spectra via vibrational_analysis
            print('\nIR calculation not support k points in cp2k currently!\n')
            print('You should use supercell\n')
            
            GLOBAL = global_section('IR','VIBRATIONAL_ANALYSIS')
    
            force_eval_dft_subs = {}
            dft_print_subs = {}
            dft_print_subs['moments'] = Section(name = 'MOMENTS',
                                                section_parameters = ['ON'], 
                                                keywords = {'periodic':Keyword('PERIODIC','T','\t #F-for non-periodic system'),
                                                            'filename':Keyword('#FILENAME','IR-dipole'),
                                                            'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                            'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                           },
                                                subsections = {'each':Section(name = 'EACH', 
                                                                              keywords = {'qs_scf':Keyword('#QS_SCF',0),
                                                                                          'geo_opt':Keyword('#GEO_OPT',0),
                                                                                          'cell_opt':Keyword('#CELL_OPT',0),
                                                                                          'md':Keyword('#MD',0),
                                                                                         }
                                                                             )
                                                              }
                                                
                                               )
            force_eval_dft_subs['print'] = Section(name = 'PRINT', subsections = dft_print_subs)
            force_eval_dft = Section(name = 'DFT',subsections = force_eval_dft_subs)
            FORCE_EVAL = Section(name = 'FORCE_EVAL',subsections = {'force_eval_subs':force_eval_dft})
    
            MOTION = motion_section({'motion_print':motion_print()})
            
            VIBRATIONAL_ANALYSIS = Section(name = 'VIBRATIONAL_ANALYSIS',
                                           keywords = {'intensities':Keyword('INTENSITIES','T','\t #calculate IR or Raman')
                                                      }
                                          )
            inp_sections_dict = {}
            inp_sections_dict['global'] = GLOBAL
            inp_sections_dict['force_eval'] = FORCE_EVAL
            inp_sections_dict['motion'] = MOTION
            inp_sections_dict['vib'] = VIBRATIONAL_ANALYSIS
    
            write_cp2k_inp('add_IR',inp_sections_dict)
    
    
        
        elif int(other_settings_index.strip()) == 42:   #calculate Raman spectra via vibrational_analysis
            print('IR calculation not support k points in cp2k currently!\n')
            print('You should use supercell!!!\n')        
    
            GLOBAL = global_section('Raman','VIBRATIONAL_ANALYSIS')
    
            force_eval_subs = {}
            properties_subs = {}
            linear_subs = {}
            linear_subs['polar'] = Section(name = 'POLAR',
                                           keywords = {'do_raman':Keyword('DO_RAMAN','T','\t #calculate electric-dipole–electric-dipole polarizability'), 
                                                       'periodic_dipole_operator':Keyword('PERIODIC_DIPOLE_OPERATOR','T','\t #F-non periodic system, type of dipole operator: Berry phase (T) or Local (F)')
                                                      }
                                          )
            properties_subs['linear'] = Section(name = 'LINRES', 
                                                keywords = {'preconditioner':Keyword('PRECONDITIONER','FULL_ALL',
                                                                                    '\t #for CG minimization, FULL_ALL-almost all systems except very large ones, FULL_KINETIC-very large ones, FULL_SINGLE_INVERSE-for large systems'),
                                                            'eps':Keyword('EPS','1E-06','\t #target accuracy for the convergence of CG'),
                                                            'eps_filter':Keyword('EPS_FILTER','1E-08','\t #filter threshold for response density matrix'),
                                                            'max_iter':Keyword('MAX_ITER','200','\t #maximum number of CG interation')
                                                           }, 
                                                subsections = linear_subs)
            force_eval_subs['properties'] = Section(name = 'PROPERTIES',subsections = properties_subs)
    
            FORCE_EVAL = Section(name = 'FORCE_EVAL', subsections = force_eval_subs)
            
            MOTION = motion_section({'motion_print':motion_print()})
            
            VIBRATIONAL_ANALYSIS = Section(name = 'VIBRATIONAL_ANALYSIS',
                                           keywords = {'intensities':Keyword('INTENSITIES','T','\t #calculate IR or Raman')}
                                          )
    
            inp_sections_dict = {}
            inp_sections_dict['global'] = GLOBAL
            inp_sections_dict['force_eval'] = FORCE_EVAL
            inp_sections_dict['motion'] = MOTION
            inp_sections_dict['vib'] = VIBRATIONAL_ANALYSIS
    
            write_cp2k_inp('add_Raman',inp_sections_dict)
    
    
    
        elif int(other_settings_index.strip()) == 43:   #calculate IR and Raman spectra via vibrational_analysis
            print('Both IR  and Raman calculations not support k points in cp2k currently!\n')
            print('You should use supercell\n')     
    
            GLOBAL = global_section('IR_and_Raman','VIBRATIONAL_ANALYSIS')
    
            force_eval_subs = {}
            properties_subs = {}
            linear_subs = {}
            
            force_eval_dft_subs = {}
            dft_print_subs = {}
            dft_print_subs['moments'] = Section(name = 'MOMENTS',
                                                section_parameters = ['ON'], 
                                                keywords = {'periodic':Keyword('PERIODIC','T','\t #F-for non-periodic system'), 
                                                            'filename':Keyword('#FILENAME','IR-dipole')})
            force_eval_dft_subs['print'] = Section(name = 'PRINT', subsections = dft_print_subs)
            force_eval_dft = Section(name = 'DFT',subsections = force_eval_dft_subs)    
            force_eval_subs['dft'] = Section(name = 'DFT',subsections = force_eval_dft_subs)      #for IR
    
            
            linear_subs['polar'] = Section(name = 'POLAR',
                                           keywords = {'do_raman':Keyword('DO_RAMAN','T','\t #calculate electric-dipole–electric-dipole polarizability'), 
                                                       'periodic_dipole_operator':Keyword('PERIODIC_DIPOLE_OPERATOR','T','\t #F-non periodic system')})
            properties_subs['linear'] = Section(name = 'LINRES', 
                                                keywords = {'preconditioner':Keyword('PRECONDITIONER','FULL_ALL','\t #for CG minimization'),
                                                            'eps':Keyword('EPS','1E-06','\t #target accuracy for the convergence of CG'),
                                                            'eps_filter':Keyword('EPS_FILTER','1E-08','\t #filter threshold for response density matrix')
                                                           },
                                                subsections = linear_subs
                                               )
    
            force_eval_subs['properties'] = Section(name = 'PROPERTIES',subsections = properties_subs)
    
            FORCE_EVAL = Section(name = 'FORCE_EVAL', subsections = force_eval_subs)
    
    
            MOTION = motion_section({'motion_print':motion_print()})
            
            VIBRATIONAL_ANALYSIS = Section(name = 'VIBRATIONAL_ANALYSIS',
                                           keywords = {'intensities':Keyword('INTENSITIES','T','\t #calculate IR or Raman')
                                                      }
                                          )
            inp_sections_dict = {}
            inp_sections_dict['global'] = GLOBAL
            inp_sections_dict['force_eval'] = FORCE_EVAL
            inp_sections_dict['motion'] = MOTION
            inp_sections_dict['vib'] = VIBRATIONAL_ANALYSIS
    
            write_cp2k_inp('add_IR_and_Raman',inp_sections_dict)        
    
    
    
        elif int(other_settings_index.strip()) == 44:          # MSDA method for calculating hessian
            print('Available methods in mode selective vibration analysis (MSVA):\n')
            msva_method_dict = {0:'select atoms for calculation',
                                1:'set frequency range for calculation',
                                2:'set detailed some frequencies for calculation'
                               }
    
            print(yaml.dump(msda_method_dict, sort_keys = False, default_flow_style = False))
            
            x_2 = input('\nPlease choose the calculation method in MSVA, e.g. 0:\n')
            
            if int(x_2.strip()) == 0:       #select atoms for calculation
                msva_subs = {}
                msva_subs['involved atoms'] = Section(name = 'INVOLVED_ATOMS',
                                                      keywords = {'involed':Keyword('INVOLVED_ATOMS',1,2,3,'\t #same with ATOMS in &MODE_SELECTIVE')})
                vibration_msva = Section(name = 'MODE_SELECTIVE', 
                                         keywords = {'atoms':Keyword('ATOMS',15,16,'\t #atoms for calc.,default-whole system'), 
                                                     'eps_max_val':Keyword('EPS_MAX_VAL','5E-07','\t #default, for criterion in Davidson ALGO'), 
                                                     'eps_norm':Keyword('EPS_NORM','5E-07','\t #default-2E-06, for criterion in Davidson ALGO'),
                                                     'initial_guess':Keyword('#INITIAL_GUESS','ATOMIC','\t #others: BFGS_HESS, RESTART, RESTART_VEC, MOLDEN_RESTART'), 
                                                     'lowest_freq':Keyword('#LOWEST_FREQUENCY',0,'\t #default 0-no print imaginary freqs, if print, use very negative value'), 
                                                     'restart_file_name': Keyword('#RESTART_FILE_NAME','to be specified')},
                                         subsections = msva_subs)
                vibration_analysis_subs = {}
                vibration_analysis_subs['msva'] = vibration_msva
                VIBRATIONAL_ANALYSIS = Section(name = 'VIBRATIONAL_ANALYSIS',
                                               keywords = {'nproc_rep':Keyword('NPROC_REP',6,'\t #MSVA, >1 modes,suggest cp2k.psmp, number_of_replica = MPI/NPROC_REP')}, 
                                               subsections = vibration_analysis_subs)
        
                write_cp2k_inp('add_selected_atoms_MSVA',{'vib':VIBRATIONAL_ANALYSIS})
                
            elif int(x_2.strip()) == 1:       #frequency range for calculation
                msva_subs = {}
                vibration_msva = Section(name = 'MODE_SELECTIVE', 
                                         keywords = {'range':Keyword('RANGE',3000,4000,'\t #frequency range for calculation'), 
                                                     'eps_max_val':Keyword('EPS_MAX_VAL','5E-07','\t #default, for criterion in Davidson ALGO'), 
                                                     'eps_norm':Keyword('EPS_NORM','5E-07','\t #default-2E-06, for criterion in Davidson ALGO'),
                                                     'initial_guess':Keyword('#INITIAL_GUESS','ATOMIC','\t #default, others: BFGS_HESS, RESTART, RESTART_VEC, MOLDEN_RESTART'), 
                                                     'lowest_freq':Keyword('#LOWEST_FREQUENCY',0,'\t #default 0-no print imaginary freqs, if print, use very negative value'), 
                                                     'restart_file_name': Keyword('#RESTART_FILE_NAME','to be specified','\t #with restarted vectors')})
                vibration_analysis_subs = {}
                vibration_analysis_subs['msva'] = vibration_msva
                VIBRATIONAL_ANALYSIS = Section(name = 'VIBRATIONAL_ANALYSIS',
                                               keywords = {'nproc_rep':Keyword('NPROC_REP',6,'\t #MSVA, >1 modes,suggest cp2k.psmp, number_of_replica = MPI/NPROC_REP')}, 
                                               subsections = vibration_analysis_subs)
        
                write_cp2k_inp('add_selected_atoms_MSVA',{'vib':VIBRATIONAL_ANALYSIS})
    
            elif int(x_2.strip()) == 2:       #detailed calculation around some frequencies
                msva_subs = {}
                vibration_msva = Section(name = 'MODE_SELECTIVE', 
                                         keywords = {'frequency':Keyword('FREQUENCY',1500,'\t #detailed frequency for calculation'),
                                                     'eps_max_val':Keyword('EPS_MAX_VAL','5E-07','\t #default, for criterion in Davidson ALGO'), 
                                                     'eps_norm':Keyword('EPS_NORM','5E-07','\t #default: 2E-06, for criterion in Davidson ALGO'),
                                                     'initial_guess':Keyword('#INITIAL_GUESS','ATOMIC','\t #default, others: BFGS_HESS, RESTART, RESTART_VEC, MOLDEN_RESTART'), 
                                                     'lowest_freq':Keyword('#LOWEST_FREQUENCY',0,'\t #default 0-no print imaginary freqs, if print, use very negative value'), 
                                                     'restart_file_name': Keyword('#RESTART_FILE_NAME','to be specified','\t #with restarted vectors')}
                                        )
                vibration_analysis_subs = {}
                vibration_analysis_subs['msva'] = vibration_msva
                VIBRATIONAL_ANALYSIS = Section(name = 'VIBRATIONAL_ANALYSIS',
                                               keywords = {'nproc_rep':Keyword('NPROC_REP',6,'\t #MSDA, >1 modes, suggest cp2k.psmp, number_of_replica = MPI/NPROC_REP')}, 
                                               subsections = vibration_analysis_subs)
        
                write_cp2k_inp('add_selected_atoms_MSVA',{'vib':VIBRATIONAL_ANALYSIS})          
    
    
    
        elif int(other_settings_index.strip()) == 50:   #adding constraint list in &MOTION
            constraint_methods = {1:'by cartesian height',
                                  2:'by kinds',
                                  3:'your definition'
                                 }
            print('\nCurrently available constraint methods:\n')
            print(yaml.dump(constraint_methods, sort_keys = False, default_flow_style = False))

            constraint_method_index = input('\nPlease choose the constraint method, e.g. 1:\n')

            if int(constraint_method_index.strip()) == 1:   #choose the method by height
                atomic_cart_z = []
                z = '-1'
                while z != "":           #press enter to exit
                    z = input('\nPlease add the height window pair by pair in one line, left < right, Press enter to quit\ne.g. 3.2,4.2 for one pair\n')
                    atomic_cart_z.append(([z_i.strip() for z_i in z.split(',')]))
                atomic_cart_z
                z_coords = atomic_cart_z[:-1]
                
                for x_i in range(len(z_coords)):
                    for x_j in range(len(z_coords[x_i])):
                        z_coords[x_i][x_j] = float(z_coords[x_i][x_j])
                z_coords
                
                z_coords_array = np.array(z_coords)
                
                print('\nYour defined height gap pair(s):\n', z_coords_array, 'unit: Angstorm\n')
                
                z_coords_choose = [ [] for i in range(len(z_coords_array))]
                    
                for coords in range(len(cartesian_coords)):
                    for z_window in range(len(z_coords_array)):
                        if (cartesian_coords[coords][2] >= z_coords_array[z_window][0]) & (cartesian_coords[coords][2] <= z_coords_array[z_window][1]):
                            z_coords_choose[z_window] += [coords]
                z_coords_choose
                print('\nFind the atomic indexs:\n',z_coords_choose,'\n')   #find the element you want to constrain
                
                z_coords_choose_for_constraint = np.array(z_coords_choose) + 1   #each chosen atomic index + 1 for &FIXED_ATOMS LIST
                print('\nFor constraint in &FIX_ATOMS:\n',z_coords_choose_for_constraint,'\n')   #find the element you want to constrain
                
                z_coords_constraint = z_coords_choose_for_constraint.astype(str)
        
                fixed_atoms_kwds = {}
                fixed_atoms_kwds['COMPONENTS_TO_FIX'] = Keyword('COMPONENTS_TO_FIX','XYZ')
                
                for x_i in range(len(z_coords_constraint)):
                    fixed_atoms_kwds[x_i] = Keyword('LIST',''.join([x_j + ' ' for x_j in z_coords_constraint[x_i]]))
                fixed_atoms_kwds

            elif int(constraint_method_index.strip()) == 2:   #choose the method by kinds
                '''
                This function allows you to fix all the specified atomic kinds in structure
                '''
                print('\nCurrently obtained chemical species:', element,'\n')
                chosen_kinds = input('\nPlease type in the kinds you want to fix, e.g. Co,O,H\n')
                
                chosen_kinds_list = chosen_kinds.strip().split(',')


                constraint_list = []
                for kind_i in chosen_kinds_list:
                    for x_i, e_i in enumerate(labels):
                        if kind_i == e_i:
                            constraint_list.append(x_i + 1)

                print('\nFind atomic indexes:', constraint_list,'\n')
                
                fixed_atoms_kwds = {}
                fixed_atoms_kwds['COMPONENTS_TO_FIX'] = Keyword('COMPONENTS_TO_FIX','XYZ')
                fixed_atoms_kwds['LIST'] = Keyword('LIST',' '.join([str(y_i) for y_i in constraint_list]))

            
            elif int(constraint_method_index.strip()) == 3:   #your definition
                fix_inp = input('\nYour definition for constraint list, e.g. 1..10,15,20, where 1..10 means 1-10:\n')
                
                fix_inp_list = fix_inp.strip().split(',')

                #check the inp list, if 1-10 find, replace into 1..10
                for x_i in range(len(fix_inp_list)):
                    if '-' in fix_inp_list[x_i]:
                        fix_inp_list[x_i] = fix_inp_list[x_i].replace('-','..')

                print('\nYour definition:', fix_inp_list,'\n')
                
                fixed_atoms_kwds = {}
                fixed_atoms_kwds['COMPONENTS_TO_FIX'] = Keyword('COMPONENTS_TO_FIX','XYZ')
                fixed_atoms_kwds['LIST'] = Keyword('LIST',' '.join(fix_inp_list))

            #here for create the inp file
            motion_constraint_subs = {}
            motion_constraint_subs['fix_atoms'] = Section(name = 'FIXED_ATOMS', 
                                                          keywords = fixed_atoms_kwds)
            motion_constraint = Section(name = 'CONSTRAINT', subsections = motion_constraint_subs)
    
            motion_subs = {}
            motion_subs['CONSTRAINT'] = motion_constraint
            MOTION = Section(name = 'MOTION', subsections = motion_subs)
    
            write_cp2k_inp('add_list_for_constraint',{'motion': MOTION})

        

        elif int(other_settings_index.strip()) == 51:   #use reference cell when performing CELL_OPT
            vector_A = structure.lattice.matrix[0]
            vector_A_ref = structure.lattice.matrix[0] * 1.1
            A_ref = [f'{x:.8f}' for x in np.around(vector_A_ref,8)]
            
            vector_B = structure.lattice.matrix[1]
            vector_B_ref = structure.lattice.matrix[1] * 1.1
            B_ref = [f'{x:.8f}' for x in np.around(vector_B_ref,8)]
            
            vector_C = structure.lattice.matrix[2]
            vector_C_ref = structure.lattice.matrix[2] * 1.1
            C_ref = [f'{x:.8f}' for x in np.around(vector_C,8)]
            
            angles = structure.lattice.angles
            alpha = np.around(angles[0],1)
            beta = np.around(angles[1],1)
            gamma = np.around(angles[2],1)
    
            subsys_cell_subs = {}
            subsys_cell_subs['cell_ref'] = Section(name = 'CELL_REF', 
                                                   keywords = {'A_ref':Keyword('A','  ',A_ref[0],'  ',A_ref[1],'  ',A_ref[2]), 
                                                               'B_ref':Keyword('B','  ',B_ref[0],'  ',B_ref[1],'  ',B_ref[2]), 
                                                               'C_ref':Keyword('C','  ',C_ref[0],'  ',C_ref[1],'  ',C_ref[2]), 
                                                               'angels':Keyword('ALPHA_BETA_GAMMA',alpha,beta,gamma), 
                                                               'multi_cell':Keyword('MULTI_UNIT_CELL',1,1,1,'\t #if using supercell, same keyword should also be specified in &TOPOLOGY'), 
                                                               'periodic':Keyword('PERIODIC','XYZ', '\t #shoudmatch with that in &PSOLVER')
                                                              })
            subsys_cell = Section(name = 'CELL',subsections = subsys_cell_subs)
            force_eval_subsys = Section(name = 'SUBSYS',subsections = {'subsys_cell':subsys_cell})
            FORCE_EVAL = Section(name = 'FORCE_EVAL',subsections = {'force_eval_subsys':force_eval_subsys})
            
            write_cp2k_inp('add_CELL_REF',{'force_eval':FORCE_EVAL})


        
        elif int(other_settings_index.strip()) == 52:   #use MSST in AIMD simulation
            EACH = Section(name = 'EACH', keywords = {'md':Keyword('MD',1,'\t #output frequency')})
            
            md_subs = {}
            md_subs['msst'] = Section(name = 'MSST', 
                                      keywords = {'cmass':Keyword('CMASS','to be specified','\t #[m_e], effective cell mass'),
                                                  'vshock':Keyword('VSHOCK','to be specified','\t #[s^-1*m], shocking velocity'),
                                                  'energy':Keyword('ENERGY','to be specified','\t #[Hartree], initial energy'),
                                                  'volume':Keyword('VOLUME','to be specified','\t [angstrom^3], initial volume'),
                                                  'pressure':Keyword('PRESSURE','to be specified','\t #[bar], initial pressure'),
                                                 }
                                     )

            print_subs = {}
            print_subs['energy'] = Section(name = 'ENERGY', 
                                           keywords = {'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                       'iter':Keyword('COMMON_ITERATION_LEVELS',1),
                                                       'filename':Keyword('FILENAME','md_energy'),
                                                      },
                                           subsections = {'each':EACH}
                                          )
            print_subs['program_run_info'] = Section(name = 'PROGRAM_RUN_INFO', subsections = {'each':EACH})
            
            md_subs['print'] = Section(name = 'PRINT', 
                                       subsections = print_subs
                                      )
            
            motion_subs = {}
            motion_subs['md'] = Section(name = 'MD', 
                                        keywords = {'ensemble':Keyword('ENSEMBLE','MSST'), 
                                                    'steps':Keyword('STEPS',10000,'\t #number of MD steps to perform, counting from STEP_START_VAL'),
                                                    'max_steps':Keyword('#MAX_STEPS','1E+09','\t # number of MD steps to perform, counting from step 1'),
                                                    'step_start_val':Keyword('STEP_START_VAL',0,'\t #starting step value for the MD'),
                                                    'timestep':Keyword('TIMESTEP', 0.1,'\t #[fs], length of an integration step, decrease for high temperature'),
                                                    'time_start_val':Keyword('TIME_START_VAL', 0,'\t #starting timer value for the MD,[fs], value = STEP_START_VAL*TIMESTEP'),
                                                    'comvel_tol':Keyword('#COMVEL_TOL',0,'\t # [au_t^-1*bohr], maximum accepted velocity of the center of mass'),
                                                   },
                                        subsections = md_subs
                                       )
            MOTION = motion_section(motion_subs)

            subsys_subs = {}
            subsys_subs['velocity'] = Section(name = 'VELOCITY', keywords = {'mind':Keyword('#to be copied if you want to use')})
            subsys = Section(name = 'SUBSYS', subsections = subsys_subs)
            
            FORCE_EVAL = Section(name = 'FORCE_EVAL', subsections = {'subsys':subsys})

            print('\n&PRINT in &MOTION try function 55!\n')
            
            write_cp2k_inp('use_MSST_for_AIMD',{'force_eval':FORCE_EVAL, 'motion':MOTION})



        elif int(other_settings_index.strip()) == 53:   #other settings for AIMD
            dft_scf_subs = {}
            dft_scf_subs['print'] = Section(name = 'PRINT', 
                                            subsections = {'restart':Section(name = 'RESTART',
                                                                             section_parameters = ['OFF #do not generate wfn files']), 
                                                           'program_run_info':Section(name = 'PROGRAM_RUN_INFO', 
                                                                                      subsections = {'each':Section(name = 'EACH', 
                                                                                                                    keywords = {'md':Keyword('MD',20)
                                                                                                                               })
                                                                                                    }
                                                                                     )
                                                          }
                                           )
            
            dft_print_subs = {}
            dft_print_subs['mo_cubes'] = Section(name = 'MO_CUBES', 
                                                 keywords = {'nhomo':Keyword('NHOMO',2), 
                                                             'nlumo':Keyword('NLUMO',2),
                                                             'stride':Keyword('STRIDE',2) 
                                                            }, 
                                                 subsections = {'each':Section(name = 'EACH', keywords = {'md':Keyword('MD',10)})}
                                                )
            dft_print_subs['e_density_cube'] = Section(name = 'E_DENSITY_CUBE', 
                                                 keywords = {'stride':Keyword('STRIDE',2)}, 
                                                 subsections = {'each':Section(name = 'EACH', keywords = {'md':Keyword('MD',10)})}
                                                )
            
            
            
            dft_subs = {}
            dft_subs['scf'] = Section(name = 'SCF', subsections = dft_scf_subs)
            dft_subs['print'] = Section(name = 'PRINT', subsections = dft_print_subs)    #here is the inclusion of &DFT-&SCF and &DFT-&PRINT subs
            
            
            
            
            force_eval_print_subs = {}
            force_eval_print_subs['program_run_info'] = Section(name = 'PROGRAM_RUN_INFO', 
                                                                subsections = {'each': Section(name = 'EACH', 
                                                                                               keywords = {'md':Keyword('MD',20,'\t #every 20 steps in MD')}
                                                                                              )
                                                                              })                                  
            force_eval_subs = {}
            force_eval_subs['print'] = Section(name = 'PRINT', subsections = force_eval_print_subs)
            force_eval_subs['dft'] = Section(name = 'DFT', subsections = dft_subs)
            force_eval_subs['subsys'] = Section(name = 'SUBSYS', 
                                                subsections = {'velocity':Section(name = 'VELOCITY',keywords = {'velocities':Keyword('#copy from .restart file')})})
            
            FORCE_EVAL = Section(name = 'FORCE_EVAL', subsections = force_eval_subs)
    
            motion_md_subs = {}
            motion_md_subs['print'] = Section(name = 'PRINT', 
                                           subsections = {'program_run_info':Section(name = 'PROGRAM_RUN_INFO', 
                                                                                     subsections = {'each':Section(name = 'EACH', 
                                                                                                                   keywords = {'md':Keyword('MD',20)})
                                                                                                   }
                                                                                    )
                                                         })
    
            motion_print_subs = {}
    
            motion_print_subs['traj'] = Section(name = 'TRAJECTORY', 
                                                keywords = {'filename':Keyword('FILENAME','motion_trajecroty'), 
                                                            'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                            'format':Keyword('FORMAT','XYZ'),
                                                            'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                           }, 
                                                subsections = {'each':Section(name = 'EACH',keywords = {'md':Keyword('MD',50,'\t #every 50 steps in MD')})})
            motion_print_subs['velocity'] = Section(name = 'VELOCITIES', 
                                                    keywords = {'filename':Keyword('FILENAME','motion_velocity'), 
                                                                'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                                'format':Keyword('FORMAT','XYZ'),
                                                                'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                               }, 
                                                    subsections = {'each':Section(name = 'EACH',keywords = {'md':Keyword('MD',500,'\t #every 500 steps in MD')})})
            motion_print_subs['forces'] = Section(name = 'FORCES', 
                                                  keywords = {'filename':Keyword('FILENAME','motion_forces'), 
                                                              'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                              'format':Keyword('FORMAT','XYZ'),
                                                              'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                             }, 
                                                  subsections = {'each':Section(name = 'EACH',keywords = {'md':Keyword('MD',500,'\t #every 500 steps in MD')})})        
            motion_print_subs['restart'] = Section(name = 'RESTART', 
                                                   keywords = {'backup':Keyword('BACKUP_COPIES',0),
                                                               'filename':Keyword('FILENAME','motion_restart'), 
                                                               'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                               'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                              }, 
                                                   subsections = {'each':Section(name = 'EACH',keywords = {'md':Keyword('MD',10,'\t #every 10 steps in MD')})})
            motion_print_subs['restart_history'] = Section(name = 'RESTART_HISTORY',section_parameters = ['OFF'])
    
            motion_subs = {}
            motion_subs['md'] = Section(name = 'MD', subsections = motion_md_subs)
            motion_subs['print'] = Section(name = 'PRINT', subsections = motion_print_subs)
            
            MOTION = Section(name = 'MOTION', subsections = motion_subs)
            
            write_cp2k_inp('add_settings_for_AIMD',{'force_eval':FORCE_EVAL, 'motion':MOTION})


        
        elif int(other_settings_index.strip()) == 54:     #perform contrained MD calculation
            subsys_colvar_subs = {}
            
            colvar_types_dict = {1:'ANGLE',
                                 2:'DISTANCE',
                                 3:'TORSION',
                                 4:'HBP',
                                 5:'RMSD',
                                }
            
            num_of_colvar = input('\nHow many constraints (&COLVAR in &SUBSYS) you want to add, e.g. 1:\n')
            
            print('\nCurrently available constraint types:\n')
            print(yaml.dump(colvar_types_dict, sort_keys = False, default_flow_style = False))
            
            types_num_inp = input('\nType in {} number(s) of constraint types, e.g. 1,2,3:\n'.format(num_of_colvar))
            types_num_inp_list = types_num_inp.strip().split(',')
            types_name_list = []
            for x_i in types_num_inp_list:
                types_name_list.append(colvar_types_dict[int(x_i)])
            
            for x_i in range(int(num_of_colvar.strip())):
                subsys_colvar_subs[x_i] = Section(name = 'COLVAR', 
                                                  subsections = {x_i:Section(name = types_name_list[x_i])
                                                                }
                                                 )
                
            subsys_colvar = Section(name = 'SUBSYS',
                                    subsections = subsys_colvar_subs
                                   )

            force_eval_for_c_md = Section(name = 'FORCE_EVAL', subsections = {'subsys_c_md':subsys_colvar})
            
            #here defines the &MOTION
            constraint_c_md_subs = {}
            for x_i in range(int(num_of_colvar.strip())):
                constraint_c_md_subs[x_i] = Section(name = 'COLLECTIVE',
                                                    keywords = {'colvar':Keyword('COLVAR', x_i + 1),
                                                                'intermolecular':Keyword('INTERMOLECULAR','T'),
                                                                'target':Keyword('TARGET','[angstrom]','value_to_be_specified'),
                                                                'target_growth':Keyword('TARGET_GROWTH','[angstrom * fs^-1]','value_to_be_specified'),
                                                                'target_limit':Keyword('TARGET_LIMIT','[angstrom]','value_to_be_specified'),
                                                               }
                                                   )
                
            constraint_c_md_subs['lagrange_multipliers'] = Section(name = 'LAGRANGE_MULTIPLIERS',
                                                                   keywords = {'add_last':Keyword('ADD_LAST','NUMERIC'),
                                                                               'common_iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                                               'filename':Keyword('FILENAME','lagrange_multipliers'),
                                                                              },
                                                                   subsections = {'each':Section(name = 'EACH',
                                                                                                 keywords = {'qs_scf':Keyword('QS_SCF',0),
                                                                                                             'geo_opt':Keyword('#GEO_OPT',0),
                                                                                                             'cell_opt':Keyword('#CELL_OPT',0),
                                                                                                             'md':Keyword('MD',1)
                                                                                                            }
                                                                                                )
                                                                                 }
                                                                  )
            
            motion_for_constrained_md = Section(name = 'MOTION', 
                                                subsections = {'constraint':Section(name = 'CONSTRAINT', 
                                                                                    keywords = {'shake_tol':Keyword('SHAKE_TOLERANCE','1E-6')},
                                                                                    subsections = constraint_c_md_subs),
                                                               'motion_print':motion_print_for_md()
                                                              }
                                               )
                
            write_cp2k_inp('perform_constrained_MD',{'force_eval':force_eval_for_c_md, 'motion':motion_for_constrained_md})

        
        
        elif int(other_settings_index.strip()) == 55:   #other settings for using SCCS implicit solvent
            print('\nRecommend using structure after geo_opt for SCCS calculation!')
            print('If hard convergence, try to switch from GPW to GAPW, or loose the convergence parameters!')

            #1 mN/m = 1 dyn/cm
            print('\nSolvent parameters from: J. Chem. Phys. 150, 041710 (2019); doi: 10.1063/1.5050938')
            solvents_dict = {1:'1,4-dioxane',
                             2:'1-propanol',
                             3:'2,2,4-trimethylpentane',
                             4:'Acetic acid',
                             5:'Acetone',
                             6:'Acetophenone',
                             7:'Benzonitrile',
                             8:'Bromobenzene',
                             9:'Butanone',
                             10:'Carbon tetrachloride',
                             11:'Chlorobenzene',
                             12:'Chloroform',
                             13:'Cyclohexanone',
                             14:'Ethanol',
                             15:'Formamide',
                             16:'Heptane',
                             17:'Methanol',
                             18:'Pyridine',
                             19:'Toluene',
                             20:'Tetrahydrofuran',
                             21:'water',
                             22:'o-xylene',
                            }
            
            solvents_alpha_value_dict = {'1,4-dioxane':36.9,
                                         '1-propanol':45.4,
                                         '2,2,4-trimethylpentane':38.4,
                                         'Acetic acid':43.1,
                                         'Acetone':43.7,
                                         'Acetophenone':44.5,
                                         'Benzonitrile':43.8,
                                         'Bromobenzene':41.8,
                                         'Butanone':44.0,
                                         'Carbon tetrachloride':36.5,
                                         'Chlorobenzene':42.3,
                                         'Chloroform':37.7,
                                         'Cyclohexanone':43.8,
                                         'Ethanol':41.4,
                                         'Formamide':53.2,
                                         'Heptane':38.2,
                                         'Methanol':46.4,
                                         'Pyridine':42.7,
                                         'Toluene':38.4,
                                         'Tetrahydrofuran':40.3,
                                         'water':57.2,
                                         'o-xylene':37.8,
                                        }
            
            #the dielectric_constant is from Gaussian manuscript
            dielectric_constant_dict = {'water':78.3553,
                                        '1,4-dioxane':2.2099,
                                        '1-propanol':20.524,
                                        '2,2,4-trimethylpentane':1.9358,
                                        'Acetic acid':6.2528,
                                        'Acetone':20.493,
                                        'Acetophenone':17.44,
                                        'Benzonitrile':25.592,
                                        'Bromobenzene':5.3954,
                                        'Butanone':18.246,
                                        'Carbon tetrachloride':36.5,
                                        'Chlorobenzene':5.6968,
                                        'Chloroform':4.7113,
                                        'Cyclohexanone':15.619,
                                        'Ethanol':24.852,
                                        'Formamide':108.94,
                                        'Heptane':1.9113,
                                        'Methanol':32.613,
                                        'Pyridine':12.978,
                                        'Toluene':2.3741,
                                        'Tetrahydrofuran':7.4257,
                                        'o-xylene':2.5454,
                                       }
            
            
            print('\nCurrently available solvents for SCCS model:\n')
            print(yaml.dump(solvents_dict, sort_keys = False, default_flow_style = False))            

            solvent_idx = input('\nPlease choose the solvent, e.g. 33\n')
            solvent_name = solvents_dict[int(solvent_idx.strip())]
            print('\nYour choice:',solvent_name,'\n',)
            
            SCCS_EACH = Section(name = 'EACH', keywords = {'qs_scf':Keyword('QS_SCF',0,'\t #default-0, only print after final SCF'), 
                                                           'geo_opt':Keyword('#GEO_OPT',1),
                                                           'cell_opt':Keyword('#CELL_OPT',1),
                                                          })
                                       
            dft_sccs = Section(name = 'SCCS', section_parameters = ['ON'], 
                               keywords = {'alpha':Keyword('ALPHA','[mN/m]',solvents_alpha_value_dict[solvent_name],'\t #repulsion term G_rep = alpha * S, S is quantum surface of cavity'), 
                                           'beta':Keyword('BETA','[GPa]',-0.5,'\t #dispersion term G_diss = beta * V, V is quantum volume of cavity'), 
                                           'gamma':Keyword('GAMMA','[mN/m]',0.0,'\t #cavitation term G_cav = gamma * S, S is quantum surface of cavity, alpha + gamma is more important'), 
                                           'eps_scf':Keyword('EPS_SCF',0.5,'\t #default, SCCS SCF activated when SCF convergence reached'), 
                                           'eps_sccs':Keyword('EPS_SCCS','1E-06','\t #SCCS SCF convergence, default value'), 
                                           'max_iter':Keyword('MAX_ITER',150,'\t #maximum number of SCCS iteration steps'),
                                           'method':Keyword('METHOD','ANDREUSSI','\t #other: FATTEBERT-GYGI, smoothing the dielectric function'), 
                                           'relative_permitivity':Keyword('RELATIVE_PERMITTIVITY',dielectric_constant_dict[solvent_name],'\t #default-water, dielectric constant of solvent, ALAS: DIELECTRIC_CONSTANT ,EPSILON_RELATIVE ,EPSILON_SOLVENTfrom'),
                                           'derivative_method':Keyword('DERIVATIVE_METHOD','CD5','\t #default is FFT, others:CD3, CD5, CD7')
                                          },
                               subsections = {'andreussi':Section(name = 'ANDREUSSI', 
                                                                  keywords = {'rho_max':Keyword('RHO_MAX',0.0013604),
                                                                              'rho_min':Keyword('RHO_MIN',0.0001841)
                                                                             }
                                                                 )
                                             }
                              )
            
            print_sccs_subs = {}
            print_sccs_subs['dielectric_function'] = Section(name = 'DIELECTRIC_FUNCTION', 
                                                             keywords = {'stride':Keyword('STRIDE',2,'\t #for more fineness, set 1'),
                                                                         'filename':Keyword('FILENAME','sccs_dielectric_function'),
                                                                         'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                                         'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                                        },
                                                             subsections = {'each': SCCS_EACH})
            print_sccs_subs['polar_chg_density'] = Section(name = 'POLARISATION_CHARGE_DENSITY',
                                                           keywords = {'stride':Keyword('STRIDE',2,'\t #for more fineness, set 1'),
                                                                       'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                                       'filename':Keyword('FILENNAME','sccs_polar_charge_density'),
                                                                       'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                                      }, 
                                                           subsections = {'each': SCCS_EACH})
            print_sccs_subs['polar_pot'] = Section(name = 'POLARISATION_POTENTIAL',
                                                   keywords = {'stride':Keyword('STRIDE',2,'\t #for more fineness, set 1'),
                                                               'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                               'filename':Keyword('FILENNAME','sccs_polar_potential'),
                                                               'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0)
                                                              }, 
                                                   subsections = {'each': SCCS_EACH}) 
            print_sccs_subs['total_chg_density'] = Section(name = 'TOTAL_CHARGE_DENSITY',
                                                   keywords = {'stride':Keyword('STRIDE',2,'\t #for more fineness, set 1'),
                                                               'add_last':Keyword('ADD_LAST','NUMERIC','\t #even each set to 0, might print the last'),
                                                               'filename':Keyword('FILENNAME','sccs_total_charge_density'),
                                                               'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0)
                                                              }, 
                                                   subsections = {'each': SCCS_EACH})
            
            dft_print_sccs = Section(name = 'SCCS',subsections = print_sccs_subs)
    
    
            force_eval_dft = Section(name = 'DFT', subsections = {'sccs':dft_sccs, 
                                                                  'print':Section(name = 'PRINT', 
                                                                                  subsections = {'print_subs': dft_print_sccs})
                                                                 })
    
            FORCE_EVAL = Section(name = 'FORCE_EVAL',subsections = {'dft':force_eval_dft})
    
            write_cp2k_inp('add_SCCS_solvent_model', {'force_eval':FORCE_EVAL})
    
    
        elif int(other_settings_index.strip()) == 60:      ##calculate XAS
            print('\nCalculation of XAS prefers the hybrid functional!!\n')
            print('Recommend pcX-n(n=1,2,3,4) basis sets!!\n')
            print('the specified atom should use ae basis set\n')
            
            print('Currently find atom kinds:', np.unique(labels),'\n')
            
            specified_inp = input('Please type in the specified atom index and newly defined symbol for calculation: e.g. 1,O_A\n')
            specific_inp_list = [x_i.strip() for x_i in specified_inp.split(',')]
            specified_index = int(specific_inp_list[0])  # specified atom index
            specified_symbol = specific_inp_list[1]     # specified atom type for newly defined
            
            labels_new = copy.deepcopy(labels)                         #copy the labels list for newly defined
            labels_new[specified_index - 1] = specified_symbol         #this is the new symbol list
            
            specified_car_coords = {}      #here is the newly defined section for  &COORD
            for x_i in range(len(cartesian_coords)):
                specified_car_coords[x_i] = Keyword('{label}'.format(label = labels_new[x_i].strip()),'  ',
                                                     f'{cartesian_coords[x][0]:.8f}', '  ',
                                                     f'{cartesian_coords[x][1]:.8f}', '  ',
                                                     f'{cartesian_coords[x][2]:.8f}'
                                                    )
                specified_car_coords
            newly_coords = Section(name = 'COORD', keywords = specified_car_coords)
        
        
            #add the &KIND for newly defined atom 
            added_kind = Section(name = 'KIND', 
                                 section_parameters = ['{}    #to be excited in XAS'.format(specified_symbol)],
                                 keywords = {'element':Keyword('ELEMENT',labels[specified_index - 1]),
                                             'basis_set':Keyword('BASIS_SET',basis_set()),
                                             'basis_set_aux':Keyword('BASIS_SET','AUX_FIT',admm_basis_set()),
                                             'potential':Keyword('POTENTIAL',potential())
                                            }
                                )
            
            #defines the &DFT section
            new_dft_subs = {}
            new_dft_subs['qs'] = Section(name = 'QS',
                                         keywords = {'eps_default':Keyword('EPS_DEFAULT','1E-12'),
                                                     'eps_pgf_orb':Keyword('EPS_PGF_ORB','1E-12','\t #sets precision of the overlap matrix elements'),
                                                     'method':Keyword('METHOD','GAPW')
                                                    }
                                        )
        
            new_dft_subs['aux_den_matrix_method'] = Section(name = 'AUXILIARY_DENSITY_MATRIX_METHOD',
                                                            keywords = {'puri_method':Keyword('ADMM_PURIFICATION_METHOD','NONE','\t #do not apply any purification'),
                                                                        'method':Keyword('METHOD','BASIS_PROJECTION',
                                                                                         '\t #others:BLOCKED_PROJECTION_PURIFY_FULL, BLOCKED_PROJECTION, CHARGE_CONSTRAINED_PROJECTION'),
                                                                       }
                                                           )
        
            kernel_subs = {}
            kernel_subs['xc_functional'] = dft_xc_xc_functional(xc_functional())    #This returns the &XC_FUNCTIONAL
            kernel_subs['exact_exchange'] = Section(name = 'EXACT_EXCHANGE', section_parameters = ['T'],
                                                    keywords = {'fraction':Keyword('FRACTION','value refers to &HF section'),
                                                                'cutoff_radius':Keyword('CUTOFF_RADIUS','value refers to &HF section'),
                                                                'potential_type':Keyword('POTENTIAL_TYPE','type refers to &HF section'),
                                                                'omega':Keyword('OMEGA','value refers to &HF section'),
                                                                'eps_screening':Keyword('EPS_SCREENING','1E-8'),
                                                                'tcg':Keyword('T_C_G_DATA','t_c_g.dat'),
                                                               }
                                                   )
            dft_xas_tdp_subs = {}
            dft_xas_tdp_subs['kernel'] = Section(name = 'KERNEL', 
                                                 keywords = {'ri_region':Keyword('RI_REGION',2.0,'\t #[Angstrom], affect RI_XAS basis in the region,if 0, only the RI basis elements centered on the excited atom are used'),
                                                            },
                                                 subsections = kernel_subs
                                                )
            
            use_GW2X = input('\nIf use GW2X corrected XAS spectrum? [y/n]:\n')
            if use_GW2X.strip() == 'n':
                dft_xas_tdp_subs['donor_states'] = Section(name = 'DONOR_STATES', 
                                                           keywords = {'define_excited':Keyword('DEFINE_EXCITED','BY_INDEX'), 
                                                                       'atom_list':Keyword('ATOM_LIST', specified_index),   #to be specified
                                                                       'state_types':Keyword('STATE_TYPES','1S','\t #types of orbitals that are excited, 1S,2S,2P,NE(not excited),same number with ATOM_LIST or KIND_LIST'),   #to be specified, can be repeated
                                                                       'n_search':Keyword('N_SEARCH','-1','\t search donor core orbitals from all occupied orbitals'),
                                                                       'localize':Keyword('#LOCALIZE','T','\t #activate potential donor states, used in GW2X correction, default-F'),
                                                                      }
                                                          )
                
                new_dft_subs['XAS_TDP'] = Section(name = 'XAS_TDP', 
                                                  keywords = {'grid':Keyword(specified_symbol, 150,200, '\t #the enhanced grids for calculated atom'), 
                                                              'tamm_dancoff':Keyword('TAMM_DANCOFF','T','\t #default, use Tamm-Dancoff approximation'),
                                                              'energy_range':Keyword('ENERGY_RANGE',30, '\t #energy range [eV] for considered excitations'),
                                                             },
                                                  subsections = dft_xas_tdp_subs                                          
                                                 )
            elif use_GW2X.strip() == 'y':
                dft_xas_tdp_subs['gw2x'] = Section(name = 'GW2X')
                dft_xas_tdp_subs['donor_states'] = Section(name = 'DONOR_STATES', 
                                                           keywords = {'define_excited':Keyword('DEFINE_EXCITED','BY_INDEX'), 
                                                                       'atom_list':Keyword('ATOM_LIST', specified_index),   #to be specified
                                                                       'state_types':Keyword('STATE_TYPES','1S','\t #types of orbitals that are excited, 1S,2S,2P,NE(not excited), same number with ATOM_LIST or KIND_LIST'),   #to be specified, can be repeated
                                                                       'n_search':Keyword('N_SEARCH','-1','\t #search donor core orbitals from all occupied orbitals'),
                                                                       'localize':Keyword('LOCALIZE','T','\t #activate potential donor states, used in GW2X correction, default-F'),
                                                                      }
                                                          )
    
                new_dft_subs['XAS_TDP'] = Section(name = 'XAS_TDP', 
                                                  keywords = {'grid':Keyword(specified_symbol, 150,200, '\t #the enhanced grids for calculated atom'), 
                                                              'tamm_dancoff':Keyword('TAMM_DANCOFF','T','\t #default, use Tamm-Dancoff approximation'),
                                                              'energy_range':Keyword('ENERGY_RANGE',30, '\t #energy range [eV] for considered excitations'),
                                                             },
                                                  subsections = dft_xas_tdp_subs
                                                 )
    
            print('\nPlease choose the basis set information for excited atom, recommend: pcX-n series!\n')
            new_dft = Section(name = 'DFT', 
                              keywords = {'basis_set_excite_filename':Keyword('BASIS_SET_FILE_NAME',basis_set_filename(),'\t #to be added for excited atom, e.g. pcseg'), 
                                          'basis_set_excite_admm_filename':Keyword('BASIS_SET_FILE_NAME',basis_set_admm_filename(),'\t #auxiliary basis set filename for excited atom, e.g. pcseg-admm'),
                                          'auto_basis':Keyword('AUTO_BASIS','RI_XAS','MEDIUM','\t #generate auxiliary basis set for XAS, others:SMALLl,LARGE,HUGE'),
                                          'potential_filename':Keyword('POTENTIAL_FILE_NAME',potential_filename()),
                                         },
                              subsections = new_dft_subs
                             )
    
            force_eval_XAS_subs = {}
            force_eval_XAS_subs['subsys'] = Section(name = 'SUBSYS',
                                                    subsections = {'coord':newly_coords,
                                                                   'kind':added_kind,
                                                                  }
                                                   )
            force_eval_XAS_subs['dft'] = new_dft
            FORCE_EVAL_for_XAS = Section(name = 'FORCE_EVAL', 
                                         keywords = {'method':Keyword('METHOD','QUICKSTEP')},
                                         subsections = force_eval_XAS_subs
                                        )
    
            write_cp2k_inp('add_XAS_calculation',{'force_eval_for_xas':FORCE_EVAL_for_XAS})
    
    
    
        elif int(other_settings_index.strip()) == 61:      ##calculate excitation spectrum
            tddfpt_subs = {}
            tddfpt_subs['dipole_moments'] = Section(name = 'DIPOLE_MOMENTS', 
                                                    section_parameters = ['#compute oscillator strengths in the dipole approximation'],
                                                    keywords = {'form':Keyword('DIPOLE_FORM','BERRY',
                                                                               '\t #dipole transition integrals, BERRY-Berry phase(fully periodic molecular), LENGTH-non-periodic molecular, VELOCITY'),
                                                                'reference':Keyword('REFERENCE','COM',
                                                                                    '\t #reference point to calculate electric dipole moments, others: COAC(center of atomic charges), USER_DEFINED, ZERO(original coordinate system) ')
                                                               }
                                                   )
            
            tddfpt_subs['soc'] = Section(name = 'SOC', 
                                         keywords = {'eps_filter':Keyword('EPS_FILTER','1E-10','\t #threshold used for sparse matrix operations')}
                                        )
            tddftpt_subs['STDA'] = Section(name = 'STDA',
                                           keywords = {'do_ewald':Keyword('DO_EWALD','T','\t T-periodic, F-non-periodic'),
                                                       'do_exchange':Keyword('DO_EXCHANGE','T','\t #default, switch sTDA exchange'),
                                                       'fraction':Keyword('FRACTION','to be specified', '\t #fraction of TB HF exchange in Kernel, recommend: 0.2-0.6'),
                                                       'alpha':Keyword('MATAGA_NISHIMOTO_CEXP','to be specified','\t #exponent used in Mataga-Nishimoto formula for Coulomb (alpha), value depending on FRACTION'),
                                                       'beta':Keyword('MATAGA_NISHIMOTO_XEXP','to be specified','\t #Exponent used in Mataga-Nishimoto formula for Exchange (beta), value depending on FRACTION'),
                                                      }
                                          )
    
            tddfpt_print_subs = {}
            tddfpt_print_subs['soc_print'] = Section(name = 'SOC_PRINT', 
                                                     keywords = {'splitting':Keyword('#SPLITING','T','\t #default-F, add the SOC-Splitting as additional output'),
                                                                 'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                                 'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                                 'filename':Keyword('FILENAME','SOC'),
                                                                 'some':Keyword('#SOME','T','\t #default-F, add the SOC-Matrix as additional output in a different file')
                                                     }
                                                    )
            
            tddfpt_print_subs['detailed_energy'] = Section(name = 'DETAILED_ENERGY', 
                                                           section_parameters = ['output excitation energies each Davidson iteration'])
            
    
            tddfpt_subs['print'] = Section(name = 'PRINT', subsections = tddfpt_print_subs)
            
            properties_subs = {}
            properties_subs['tddfpt'] = Section(name = 'TDDFPT', section_parameters = ['T \t #only for GPW'],
                                                keywords = {'nstates':Keyword('NSTATES',5,'\t #number of excited states to calculate'),
                                                            'rks_triplets':Keyword('#RKS_TRIPLETS','T','\t #default-F, if compute triplet excited states'),
                                                            'convergence':Keyword('CONVERGENCE','[eV]','1E-04','\t #target accuracy for excited state energies, or with [hartree]'),
                                                            'min_amplititude':Keyword('MIN_AMPLITUDE','0.01','\t #default-0.05, smallest excitation amplitude to print'),
                                                            'restart':Keyword('#RESTART','T','\t #default-F,if calculate from RESTART, should add WFN_RESTART_FILE_NAME'),
                                                            'wfn_restart_filename':Keyword('WFN_RESTART_FILE_NAME','to be specified for your restart filename'),
                                                            'nlumo':Keyword('NLUMO','-1','\t #number of unoccupied orbitals to consider,-1 is all'),
                                                            'oe_corr':Keyword('OE_CORR','NONE','\t #default, orbital energy correction potential, others: LB94, GLLB, SAOP, SHIFT'),
                                                            'orthogonal_eps':Keyword('ORTHOGONAL_EPS','1E-04','\t #default, largest possible overlap between ground state and orthogonalised excited state wavefunctions'),
                                                           },
                                                subsections = tddfpt_subs
                                               )
    
            force_eval_ex_subs = {}
            force_eval_ex_subs['properties'] = Section(name = 'PROPERTIES', subsections = properties_subs)
            force_eval_for_excitation = Section(name = 'FORCE_EVAL', subsections =  force_eval_ex_subs)
    
            write_cp2k_inp('add_calculate_excitation',{'force_eval_for_excitation':force_eval_for_excitation})
    
    
        
        elif int(other_settings_index.strip()) == 62:      ##excited PES settings, such as opt, vib
            dft_for_pes_ex_subs = {}
            dft_for_pes_ex_subs['excited_states'] = Section(name = 'EXCITED_STATES', section_parameters = ['T \t #switch on for opt/vib tasks over PES'],
                                                            keywords = {'DEBUG_FORCES':Keyword('DEBUG_FORCES','T','\t #print intermediate forces in excited state force calculations'),
                                                                        'diff_order':Keyword('DIFF_ORDER',6),
                                                                        'eps_delta_rho':Keyword('EPS_DELTA_RHO','1E-03','\t #step size for finite difference calculation of functional derivatives'),
                                                                        'overlap_deltat':Keyword('#OVERLAP_DELTAT','T','\t #default-F, overlap matrix between two consecutive time steps'),
                                                                        'state':Keyword('STATE',1,'\t #excited state to be used in calculation, negative values indicate state following'),
                                                                        'xc_kernel_method':Keyword('XC_KERNEL_METHOD','BEST_AVAILABLE','\t #evaluate XC Kernel contributions to forces, others: ANALYTIC, NUMERIC')
                                                                       }
                                                           )
            
            dft_for_pes_ex = Section(name = 'DFT', subsections = dft_for_pes_ex_subs)
    
            force_eval_for_pes_ex = Section(name = 'FORCE_EVAL', subsections = {'sub':dft_for_pes_ex})
    
            write_cp2k_inp('add_excitation_PES_setting', {'force_eval':force_eval_for_pes_ex})
    
    
    
        elif int(other_settings_index.strip()) == 63:      ##calculate NMR
            project_name = input('\nPlease type in the project name:\n')
            EACH = Section(name = 'EACH', keywords = {'qs_scf':Keyword('QS_SCF',0),
                                                      'geo_opt':Keyword('#GEO_OPT',1),
                                                      'cell_opt':Keyword('#CELL_OPT',1),
                                                     })
            
            print('\nNMR calculation prefers GAPW method!\n')
    
            current_print_subs = {}
            current_print_subs['current_cubs'] = Section(name = 'CURRENT_CUBES', 
                                                         keywords = {'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                                     'add_last':Keyword('ADD_LAST','NUMERIC'),
                                                                     'filename':Keyword('FILENAME','lires_current_density'),
                                                                     'stride':Keyword('STRIDE',2,2,2)},
                                                         subsections = {'each':EACH}
                                                        )
            
            current_subs = {}
            current_subs['print'] = Section(name = 'PRINT', subsections = current_print_subs)
            
            linres_subs = {}
            linres_subs['current'] = Section(name = 'CURRENT', 
                                            section_parameters = ['#current density calculated by DFPT'],
                                            keywords = {'gauge':Keyword('GAUGE','R_AND_STEP_FUNCTION','\t #compute the induced current within GAPW, others: R(position gauge), ATOM'),
                                                        'gauge_atom_radius':Keyword('#GAUGE_ATOM_RADIUS','[angstrom]',4.0,'\t #default value, for gauge = ATOM'),
                                                        'orbital_center':Keyword('ORBITAL_CENTER','ATOM','\t #others: WANNIER, BOX and COMMON(only for isolate molecule),ATOM'),
                                                        'chi_pbc':Keyword('CHI_PBC','T','\t #calculate the succeptibility correction to the shift with PBC'),
                                                       },
                                             subsections = current_subs
                                           )
    
            localize_print_subs = {}
            localize_print_subs['molecular_dipoles'] = Section(name = 'MOLECULAR_DIPOLES', section_parameters = ['LOW'],
                                                           keywords = {'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                                       'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                                       'filename':Keyword('FILENAME','linres_local_molecular_dipoles'),
                                                                       'periodic':Keyword('PERIODIC','T','\t #use Berry phase formula, F-use simple operator with PERIODIC NONE'),
                                                                       'reference':Keyword('REFERENCE','COM','\t #others: COAC(center of atomic charges, USER_DEFINED, ZERO(origin coordinate system))'),
                                                                      },
                                                           subsections = {'each':EACH}
                                                          )
            localize_print_subs['molecular_moments'] = Section(name = 'MOLECULAR_MOMENTS', section_parameters = ['LOW'],
                                                           keywords = {'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                                       'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                                       'filename':Keyword('FILENAME','linres_local_molecular_multipole_moments'),
                                                                       'order':Keyword('ORDER',2,'\t #maximum order of mulitpoles to be calculated')
                                                                      },
                                                           subsections = {'each':EACH}
                                                          )    
            localize_print_subs['wannier_cubes'] = Section(name = 'WANNIER_CUBES', 
                                                           keywords = {'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                                       'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                                       'cubes_list':Keyword('CUBES_LIST','to be specified','\t #indexes of the states to be printed as cube files'),
                                                                       'cubes_lu_bounds':Keyword('CUBES_LU_BOUNDS','to be specified','\t #lower and upper index of the states to be printed as cube'),
                                                                       'filename':Keyword('FILENAME','wannier'),
                                                                       'stride':Keyword('stride',2,2,2),
                                                                      },
                                                           subsections = {'each':EACH}
                                                          )
            localize_print_subs['wannier_centers'] = Section(name = 'WANNIER_CENTERS', 
                                                           keywords = {'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                                       'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                                       'cubes_list':Keyword('CUBES_LIST','to be specified','\t #indexes of the states to be printed as cube files'),
                                                                       'cubes_lu_bounds':Keyword('CUBES_LU_BOUNDS','to be specified','\t #lower and upper index of the states to be printed as cube'),
                                                                       'filename':Keyword('FILENAME','wannier_centers'),
                                                                       'format':Keyword('FORMAT','XYZ'),
                                                                       'icon+centers':Keyword('IONS_CENTERS','T','\t #prints out the wannier centers together with the particles'),
                                                                       'unit':Keyword('UNIT','[angstrom]')
                                                                      },
                                                           subsections = {'each':EACH}
                                                          )        
            localize_subs = {}
            localize_subs['print'] = Section(name = 'PRINT', subsections = localize_print_subs)
            linres_subs['localize'] = Section(name = 'LOCALIZE', 
                                             keywords = {'eps_localization':Keyword('EPS_LOCALIZATION','1E-05','\t #tolerance used in the convergence criterion of the localization methods'),
                                                         'eps_occupation':Keyword('EPS_OCCUPATION','1E-08'),
                                                         'max_iter':Keyword('MAX_ITER',20000),
                                                         'method':Keyword('METHOD','JACOBI','\t #for optimization, others: CRAZY-much faster than JACOBI, GAPO, L1SD, DIRECT, SCDM'),
                                                         'jacobi_refine':Keyword('#JACOBI_REFINEMENT','T','\t #default-F, Jacobi method to refine the localisation by SCDM'),
                                                         'cg_po':Keyword('#CG_PO','T','\t #default, use CG with METHOD GAPO, if F, use steepest descent (L1SD)'),
                                                         'cpo_guess':Keyword('#CPO_GUESS','ATOMIC','\t #initial guess for coefficients if GAPO used, others: RESTART, RANDOM'),
                                                         'crazy_use_diag':Keyword('#CRAZY_USE_DIAG','T'),
                                                         'min_or_max':Keyword('MIN_OR_MAX','SPREADMIN','\t #others: SPREADMAX'),
                                                         'operator':Keyword('OPERATOR','BERRY','\t #others: BERRY, BOYS, PIPEK'),
                                                         'states':Keyword('STATES','OCCUPIED','\t #states to localize, LUMO up to now only available in GPW, others: UNOCCUPIED, MIXED, ALL')
                                                        },
                                              subsections = localize_subs
                                            )
            
            print_subs = {}
            print_subs['chi_tensor'] = Section(name = 'CHI_TENSOR', 
                                               keywords = {'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                           'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                           'filename':Keyword('FILENAME','NMR_susceptibility'),
                                                          },
                                               subsections = {'each':EACH}
                                              )
            print_subs['shielding_tensor'] = Section(name = 'SHIELDING_TENSOR', 
                                               keywords = {'iter_levels':Keyword('COMMON_ITERATION_LEVELS',1),
                                                           'filename':Keyword('FILENAME','NMR_chemical_shift'),
                                                           'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                           'atom_list':Keyword('#ATOM_LIST','to be specified','\t #list of atoms for which the shift is printed into a file'),
                                                           'atoms_lu_bounds':Keyword('#ATOMS_LU_BOUNDS','to be specified','\t #lower and upper atomic index for which the tensor is printed'),
                                                          },
                                               subsections = {'each':EACH}
                                              )
            print_subs['response_func'] = Section(name = 'RESPONSE_FUNCTION_CUBES', 
                                                  keywords = {'iter_levels':Keyword('COMMON_ITERATION_LEVELS',0),
                                                              'filename':Keyword('FILENAME','NMR_response_func'),
                                                              'add_last':Keyword('ADD_LAST','NUMERIC','\t #even set to 0, might print'),
                                                              'cube_list':Keyword('#CUBES_LIST','to be specified','\t #indexes of the states to be printed as cube files'),
                                                              'atoms_lu_bounds':Keyword('#CUBES_LU_BOUNDS','to be specified','\t #lower and upper index of the states to be printed as cube'),
                                                              'stride':Keyword('STRIDE',2,2,2),
                                                             },
                                                  subsections = {'each':EACH}
                                                 )   
            
            nmr_subs = {}
            nmr_subs['print'] = Section(name = 'PRINT', subsections = print_subs)
            linres_subs['nmr'] = Section(name = 'NMR', 
                                        keywords = {'nics':Keyword('#NICS','T','\t #calculate the chemical shift in a set of points given from an external file'),
                                                    'nics_filename':Keyword('#NICS_FILE_NAME','to be specified'),
                                                   },
                                         subsections = nmr_subs
                                       )
            
            linres_subs['epr'] = Section(name = 'EPR', section_parameters = ['T \t #calculate g tensor by DFPT '])
    
            properties_subs = {}
            properties_subs['linres'] = Section(name = 'LINRES', 
                                                section_parameters = ['#use linear response calculation'],
                                                keywords = {'preconditioner':Keyword('PRECONDITIONER','FULL_KINETIC',
                                                                                     '\t #for very large, FULL_ALL-almost all systems, except very large, FULL_SINGLE_INVERSE-large, FULL_SINGLE-cheaper, '),
                                                            'eps':Keyword('EPS','1E-08','\t #target accuracy for the convergence of CG'),
                                                            'eps_filter':Keyword('EPS_FILTER','1E-08','\t #filter threshold for response density matrix'),
                                                            'max_iter':Keyword('MAX_ITER',300,'\t #maximum number of CG'),
                                                            'restart_every':Keyword('RESTART_EVERY',50,'\t #restart CG after number of iters, if hard convergence, decrease value'),
                                                            'restart':Keyword('#RESTART','T','\t #if calculate from restart, shoud use wfn_restart_file'),
                                                            'wfn_restart_filename':Keyword('#WFN_RESTART_FILE_NAME','to be specified'),
                                                           },
                                                subsections = linres_subs
                                               )
            
            force_eval_nmr_subs = {}

            dft_for_nmr_subs = {}
            dft_for_nmr_subs['qs'] = Section(name = 'QS', keywords = {'method':Keyword('METHOD', 'GAPW')})
            force_eval_nmr_subs['dft'] = Section(name = 'DFT', subsections = dft_for_nmr_subs)
            force_eval_nmr_subs['properties'] = Section(name = 'PROPERTIES', subsections = properties_subs)
            
            force_eval_for_nmr = Section(name = 'FORCE_EVAL', subsections = force_eval_nmr_subs)

            global_for_nmr = Section(name = 'GLOBAL', 
                                     keywords = {'run_type':Keyword('RUN_TYPE','LR')}
                                    )
    
            write_cp2k_inp('calculate_NMR_{}'.format(project_name),{'global_for_nmr':global_for_nmr,
                                                                    'force_eval_for_nmr':force_eval_for_nmr})
    
    
    
        elif int(other_settings_index.strip()) == 66:      ##calculate GW correction
            project_name = input('\nPlease type in the project name:\n')
            SUBSYS_subs = {}
            for x in range(len(element)):
                SUBSYS_subs['KIND_{}'.format(x)] = Section(name = 'KIND',
                                                      section_parameters = [element[x]],
                                                      keywords = {'element': Keyword('ELEMENT',element[x]),
                                                                  'basis_set': Keyword('BASIS_SET','cc-QZ'),
                                                                  'basis_set_aux':Keyword('BASIS_SET','RI_AUX','RI_QZ'),
                                                                  'potential': Keyword('POTENTIAL','GTH-PBE')},
                                                          )
            
            RI_RPA_HF_subs = {}
            RI_RPA_HF_subs['screening'] = Section(name = 'SCREENING', 
                                                  keywords = {'eps_schwarz':Keyword('EPS_SCHWARZ','1E-07'),
                                                              'eps_schwarz_forces':Keyword('EPS_SCHWARZ_FORCES','1E-06'),
                                                              'screen_on_initial_p':Keyword('#SCREEN_ON_INITIAL_P','T','\t #default-F, screen on an initial density matrix'),
                                                              'screen_p_forces':Keyword('SCREEN_P_FORCES','T','\t #screens electronic repulsion integrals for forces using density matrix, disabled for response part of forces in MP2/RPA/TDDFT')
                                                             }
                                                 )
            
            RI_RPA_subs = {}
            RI_RPA_subs['hf'] = Section(name = 'HF', 
                                        keywords = {'fraction':Keyword('FRACTION',1.0,'\t #fraction of HF added in total energy. 1.0-standard HF if with XC_FUNCTIONAL NONE'),
                                                    'treat_lsd_in_core':Keyword('#TREAT_LSD_IN_CORE','T','\t #default-F,how spin densities are taken into account, T-beta spin density included via a second in core call, F-alpha and beta spins done in one shot'),
    
                                                   },
                                        subsections = RI_RPA_HF_subs
                                       )
    
            RI_RPA_subs['gw'] = Section(name = 'GW', 
                                        keywords = {'corr_mos_occ':Keyword('CORR_MOS_OCC',5,'\t #number of occupied MOs with energies corrected in GW, counting from HOMO'),
                                                    'corr_mos_virt':Keyword('CORR_MOS_VIRT',10,'\t #number of virtual MOs with energies corrected by GW, counting from LUMO'),
                                                    'crossing_search':Keyword('CROSSING_SEARCH','NEWTON','\t #how self_energy evaluated on real_axis, others: Z_SHOT, BISECTION'),
                                                    'eps_iter':Keyword('EPS_ITER','1.36E-03','\t #[eV], target accuracy for the eigenvalue self-consistency'),
                                                    'ev_gw_iter':Keyword('EV_GW_ITER',1,'\t #maximum number of iterations for eigenvalue self-consistency cycle for evGW'),
                                                    'sc_gw0_iter':Keyword('SC_GW0_ITER',1,'\t #maximum number of iterations for scGW0 self-consistency cycle'),
                                                    'self_consistency':Keyword('SELF_CONSISTENCY','G0W0','\t #default, use DFT eigenvals-not update, others:EVGW0-update DFT eigenvals-not in W, EVGW-update DFT eigenvals in G and W'),
                                                    'update_xc_energy':Keyword('UPDATE_XC_ENERGY','T'),
                                                    'periodic_correction':Keyword('PERIODIC_CORRECTION','F','\t #not recommend this correction, better use PERIODIC_LOW_SCALING'),
                                                   }
                                       )
            
            wf_correlation_subs = {}
            wf_correlation_subs['ri_rpa'] = Section(name = 'RI_RPA', 
                                                    section_parameters = ['T \t #parameters influencing RI-RPA and GW'],
                                                    keywords = {'quadrature_points':Keyword('QUADRATURE_POINTS', 40,'\t #number of quadrature points for the numerical integration in RI-RPA'),
                                                                'res':Keyword('#RES','T','\t #degault-F, whether to add singles correction'),
                                                                'scale_rpa':Keyword('SCALE_RPA',1.0,'\t #scales RPA energy contributions (RPA, exchange correction)'),
                                                               }, 
                                                    subsections = RI_RPA_subs
                                                   )
    
            intergrals_subs = {}
            intergrals_subs['wfc_gpw'] = Section(name = 'WFC_GPW', 
                                                 keywords = {'cutoff':Keyword('CUTOFF',350,'\t #in MP2 gpw integration'),
                                                             'rel_cutoff':Keyword('REL_CUTOFF',50,'\t #grid at which a Gaussian is mapped'),
                                                             'eps_filter':Keyword('EPS_FILTER','1E-12'),
                                                             'eps_grid':Keyword('EPS_GRID','1E-8','\t #threshold for the GPW based integration'),
                                                             'eps_pgf_orb_s':Keyword('EPS_PGF_ORB_S','1E-10','\t #screening for overlap matrix in RI, best to choose this parameter very small'),
                                                            }
                                                )
            wf_correlation_subs['intergrals'] = Section(name = 'INTERGRALS', 
                                                        subsections = intergrals_subs
                                                       )
            
            dft_xc_subs_GW = {}
            dft_xc_subs_GW['wf_correlation'] = Section(name = 'WF_CORRELATION', 
                                                       keywords = {'memory':Keyword('MEMORY',3000,'\t #maximum allowed total memory during MP2 methods, [MB]'),
                                                                   'group_size':Keyword('GROUP_SIZE',1,'\t #must be a divisor of the total number of MPI ranks')
                                                                  },
                                                       subsections = wf_correlation_subs)
            
            DFT_XC = Section(name = 'XC', subsections = dft_xc_subs_GW)
            DFT_for_GW = Section(name = 'DFT',
                                 keywords = {'basis_set_filename':Keyword('BASIS_SET_FILE_NAME','BASIS_RI_cc-TZ')},
                                 subsections = {'dft_subs':DFT_XC}
                                )
            
            SUBSYS = Section(name = 'SUBSYS', subsections = SUBSYS_subs)
            
            FORCE_EVAL_for_GW = Section(name = 'FORCE_EVAL', subsections = {'subsys':SUBSYS,
                                                                            'dft':DFT_for_GW
                                                                           })
            write_cp2k_inp('perform_GW_calculation_{}'.format(project_name.strip()),{'force_eval':FORCE_EVAL_for_GW})
    
    
    
        elif int(other_settings_index.strip()) == 70:      ##add CDFT in &QS
            cdft_subs = {}

            #first determine the number of atom groups for constraint
            num_of_atom_groups = input('\nType in the number of atom groups for constraint, e.g. 1:\n')            
            
            for num_i in range(int(num_of_atom_groups.strip())):            
                index_inp = input('\nPlease type in atom indexes for CDFT constraint: e.g. 1,2,3,11..15(11..15 = 11,12,13,14,15):\n')
                atoms_indexes = [index_i.strip() for index_i in index_inp.split(',')]
                
                atoms_indexes_copy = copy.deepcopy(atoms_indexes)   #copy for a bak
                
                for i,x_i in enumerate(atoms_indexes):
                    if '..' in x_i:
                        begin_value = int(atoms_indexes[i].split('..')[0])
                        end_value = int(atoms_indexes[i].split('..')[1])
                        
                        atoms_indexes_copy.remove(atoms_indexes[i])
    
                        added_atom_indexes_arr = np.linspace(begin_value, end_value, end_value - begin_value + 1, dtype = np.int16)   #e.g. replace the 1..5 into 1,2,3,4,5
                        
                        for y_i in added_atom_indexes_arr:
                            atoms_indexes_copy.append(str(y_i))
        
                keyword_atoms = ' '.join(atoms_indexes)
        
                coeff_inp = input('\nPlease type in the one-value cofficient for atoms you defined in atom group {}: only 1 or -1\n')
                coeff = [coeff_inp.strip()] * len(atoms_indexes_copy)
                keyword_coeff = ' '.join(coeff)

                print(f'\nNow set parameters for CDFT group {num_i + 1}')
                
                constraint_type_dict = {1:'CHARGE',
                                        2:'MAGNETIZATION',
                                        3:'ALPHA',
                                        4:'BETA',
                                       }
                
                print('\nCurrently available constraint types for atom group {}:\n'.format(num_i + 1))
                print(yaml.dump(constraint_type_dict, sort_keys = False, default_flow_style = False))                   

                c_type_idx = input('\nPlease choose the constraint for atom group {}, e.g. 1:\n'.format(num_i + 1))
                
                cdft_subs[f'atom_group_{num_i + 1}'] = Section(name = 'ATOM_GROUP', section_parameters = [f'#group {num_i + 1} for constraint, can be repeated'],
                                                  keywords = {'atoms':Keyword('ATOMS', keyword_atoms,'\t #list of atoms included in the constraint group'),
                                                              'coeff':Keyword('COEFF', keyword_coeff,'\t #coefficients for the atoms in the list of atoms, accepted values +/-1.0'),
                                                              'constraint_type':Keyword('CONSTRAINT_TYPE', constraint_type_dict[int(c_type_idx.strip())],'\t #others:MAGNETIZATION, ALPHA, BETA'),
                                                              'fragment_constraint':Keyword('#FRAGMENT_CONSTRAINT','T','\t #default-F, use a fragment based constraint, supports only static calculations'),
                                                              'reminder':Keyword('#when using FRAGMENT_CONSTRAINT, should provide FRAGMENT_FILE'),
                                                             }
                                                 )

            
            cdft_subs['outer_scf'] = Section(name = 'OUTER_SCF', 
                                             section_parameters = ['ON'], 
                                             keywords = {'type':Keyword('TYPE','CDFT_CONSTRAINT'),
                                                         'eps_scf':Keyword('EPS_SCF','1E-03'),
                                                         'extrapola':Keyword('EXTRAPOLATION_ORDER',3),
                                                         'max_scf':Keyword('MAX_SCF',50),
                                                         'optimizer':Keyword('OPTIMIZER','SECANT','\t #others: SD, DIIS, BISECT, BRODEN, NEWTON and NEWTON_LS only compatible with CDFT'),
                                                         'stepsize':Keyword('#STEP_SIZE',-1.0,'\t #initial step_size used in the optimizer (currently steepest descent)')
                                                        }
                                            )

            
            becke_or_hirshfeld = input('\nWhich CDFT constraint to use, 1-Hirshfeld, 2-Becke, type in 1 or 2:\n')
            if becke_or_hirshfeld.strip() == '1':     #choose hirshfeld
                cdft_subs['hirshfeld_constraint'] = Section(name = 'HIRSHFELD_CONSTRAINT', 
                                                            section_parameters = ['#CDFT with a Gaussian Hirshfeld constraint'],
                                                            keywords = {'shape_function':Keyword('SHAPE_FUNCTION','DENSITY','\t #for Hirshfeld partitioning, others:GAUSSIAN')
                                                                       }
                                                           )
                type_of_constraint_for_cdft = 'HIRSHFELD'
                
            elif becke_or_hirshfeld.strip() == '2':     #choose becke   
                cdft_subs['becke_constraint'] = Section(name = 'BECKE_CONSTRAINT', 
                                                            section_parameters = ['#CDFT with a Becke constraint'],
                                                            keywords = {'adjust_size':Keyword('#ADJUST_SIZE','T','\t #with defined radii'),
                                                                        'atomic_radii':Keyword('#ATOMIC_RADII','r_a','r_b','r_c','\t #one value per element'),
                                                                        'cavity_confine':Keyword('#CAVITY_CONFINE','T','\t #activates Gaussian cavity confinement'),
                                                                       }
                                                           )  
                type_of_constraint_for_cdft = 'BECKE'


            dummy_atoms_y_n = input('\nIf define extra group of atoms to only compute charges outside CDFT group atoms, [y/n]:\n')
            if dummy_atoms_y_n == 'y':
                cdft_subs['dummy_atoms'] = Section(name = 'DUMMY_ATOMS', 
                                                  keywords = {'atoms':Keyword('ATOMS',1,2,3)})
            
            cdft_subs['program_run_info'] = Section(name = 'PROGRAM_RUN_INFO', 
                                                    section_parameters = ['ON   #print WEIGHT_FUNCTION cube files with CDFT weight function(s)'],
                                                    keywords = {'add_last':Keyword('ADD_LAST','NUMERIC'),
                                                                'common_iter_level':Keyword('COMMON_ITERATION_LEVELS',5),
                                                                'filename':Keyword('FILENAME','cdft_info')
                                                               },
                                                    subsections = {'weight_function':Section(name = 'WEIGHT_FUNCTION', 
                                                                                             keywords = {'stride':Keyword('STRIDE',2,2,2),
                                                                                                         'remind':Keyword('#in multistep simulations, overwritten cube files each step'),
                                                                                                        }
                                                                                            ),
                                                                   'each':Section(name = 'EACH',
                                                                                  keywords = {'qs_scf':Keyword('QS_SCF',0),
                                                                                              'cell_opt':Keyword('#CELL_OPT',0),
                                                                                              'geo_opt':Keyword('#GEO_OPT',0),
                                                                                              'md':Keyword('#MD',10)
                                                                                             }
                                                                                 )
                                                                  }
                                                   )
    
            qs_cdft_subs = {}
            qs_cdft_subs['cdft'] = Section(name = 'CDFT',
                                           section_parameters = ['#switch on constrained DFT'],
                                           keywords = {'type of constraint':Keyword('TYPE_OF_CONSTRAINT',type_of_constraint_for_cdft,'\t #recommended hirshfeld, others:NONE, BECKE'),
                                                       'atomic charges':Keyword('#ATOMIC_CHARGES','T','\t #default-F, print atomic CDFT charges with selected weight function, Z = Z_core - Z_CDFT)'),
                                                       'strength':Keyword('STRENGTH',0,'\t #constraint force constants (Lagrange multipliers), one value per constraint group'),
                                                       'target':Keyword('TARGET','to be specified','\t #one value per constraint group, desired number of valence electrons, spin moment,num. of alpha or beta electrons on the atom'),
                                                       'reminder_1':Keyword('#fragment method is optimal'),
                                                       'flip_fragment_a':Keyword('#FLIP_FRAGMENT_A','T','\t #default-F, if allows for spin flip'),
                                                       'flip_fragment_b':Keyword('#FLIP_FRAGMENT_B','T','\t #default-F, if allows for spin flip'),
                                                       'fragment_a_filename':Keyword('#FRAGMENT_A_FILE_NAME','to be specified .cube'),
                                                       'fragment_b_filename':Keyword('#FRAGMENT_B_FILE_NAME','to be specified .cube'),
                                                       'reminder_2':Keyword('#above two files should be total electronic density cube'),
                                                       'fragment_a_spin_filename':Keyword('#FRAGMENT_A_SPIN_FILE_NAME','to be specified .cube'),
                                                       'fragment_b_spin_filename':Keyword('#FRAGMENT_B_SPIN_FILE_NAME','to be specified .cube'),                                                       
                                                      },
                                           subsections = cdft_subs
                                          )
            
            qs_for_cdft = Section(name = 'QS', subsections = qs_cdft_subs)

            dft_for_cdft = Section(name = 'DFT', subsections = {'qs':qs_for_cdft})

            force_eval_for_cdft = Section(name = 'FORCE_EVAL', subsections = {'dft':dft_for_cdft})
            
            write_cp2k_inp('add_CDFT_section',{'force_eval':force_eval_for_cdft})


    '''
    End the detailed various tasks
    '''

#create_inp()    #just for test, if compile to exe, please comment this line
#here, I define

# In[ ]:




